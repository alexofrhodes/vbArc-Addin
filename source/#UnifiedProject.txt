'ThisWorkbook	100

Private Sub Workbook_BeforeClose(Cancel As Boolean)
    '    DeleteAllBars
End Sub

Private Sub Workbook_Open()
    CreateAllBars
    FoldersCreate SNIP_FOLDER
    StartUpdate        'not working properly yet
End Sub


'Sheet34	100

Public Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    If Selection.Cells.count > 1 Then Exit Sub
    If BarExists("testtag") Then
        CommandBars("testtag").ShowPopup
        Cancel = True
    End If
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
    Application.EnableEvents = False

    If Replace(Target.Address, "$", "") = rMENU_TYPE Then
        Range(rBAR_LOCATION).ClearContents
        Range(rTARGET_CONTROL).ClearContents
    ElseIf Replace(Target.Address, "$", "") = rBAR_LOCATION Then
        Range(rTARGET_CONTROL).ClearContents
    End If
    Application.EnableEvents = True
End Sub

Public Sub Worksheet_SelectionChange(ByVal Target As Range)
    Calculate
    If Selection.Cells.count > 1 And Cells(Selection.row, 1) <> "" Then Exit Sub
    Dim dvtype As Integer
    dvtype = -1
    On Error Resume Next
    dvtype = Target.Validation.Type
    On Error GoTo 0
    If dvtype > -1 Then openUValiationDropdown
End Sub


'M_BarMan	1


Rem @Folder Barman
Public Const rBUILD_ON_OPEN = "I2"
Public Const rC_TAG = "I4"
Public Const rMENU_TYPE = "I5"
Public Const rBAR_LOCATION = "I6"
Public Const rTARGET_CONTROL = "I7"
Public C_TAG As String
Public MenuEvent As CVBECommandHandler
Public EventHandlers As New Collection
Public CmdBarItem As CommandBarControl
Public TargetCommandbar
Public TargetControl As CommandBarControl
Public MainMenu As CommandBarControl
Public MenuItem As CommandBarControl
Public ctrl As Office.CommandBarControl
Public MenuLevel, NextLevel, Caption, Divider, FaceId
Public action As String
Public MenuSheet As Worksheet
Public row As Integer
Public MenuType As Long
Public Const WorksheetMenu = 1
Public Const VbeMenu = 2
Public Const RightClickMenu = 3
Public BarLocation As String

Public Sub CreateAllBars()
    '#INCLUDE CommandBarBuilder
    Dim ws As Worksheet
    For Each ws In ThisWorkbook.Worksheets
        If UCase(left(ws.Name, 4)) = "BAR_" Then
            If ws.Range(rBUILD_ON_OPEN) = True Then CommandBarBuilder ws
        End If
    Next
End Sub

Public Sub DeleteAllBars()
    '#INCLUDE DeleteControlsAndHandlers
    Dim ws As Worksheet
    For Each ws In ThisWorkbook.Worksheets
        If UCase(left(ws.Name, 4)) = "BAR_" Then DeleteControlsAndHandlers ws
    Next
End Sub

Public Sub RestoreBars()
    '#INCLUDE CreateAllBars
    Application.OnTime Now, "CreateAllBars"
End Sub

Public Sub ListBars()
    '#INCLUDE ListWorksheetBars
    '#INCLUDE ListVBEBars
    ListWorksheetBars
    ListVBEBars
End Sub

Public Sub NewBar()
    '#INCLUDE lastBar
    Dim wsMain As Worksheet
    Set wsMain = ThisWorkbook.Worksheets("BAR_Main")
    Dim wsCopy As Worksheet
    wsMain.Copy After:=ThisWorkbook.SHEETS(ThisWorkbook.SHEETS.count)
    Set wsCopy = ThisWorkbook.SHEETS(ThisWorkbook.SHEETS.count)
    wsCopy.Name = "BAR_" & lastBar + 1
    wsCopy.Range("A1").CurrentRegion.OFFSET(1).ClearContents
    wsCopy.Range("I4:I7").ClearContents
    wsCopy.Range("I2") = False
End Sub

Private Function lastBar() As Long
    Dim counter As Long
    Dim ws As Worksheet
    For Each ws In ThisWorkbook.Worksheets
        If UCase(left(ws.Name, 4)) = "BAR_" Then counter = counter + 1
    Next
    lastBar = counter
End Function

Private Function SetCMDbar(ws As Worksheet) As Boolean
    C_TAG = ws.Range(rC_TAG)
    Select Case LCase(ws.Range(rMENU_TYPE))
        Case Is = LCase("WorksheetMenu")
            MenuType = WorksheetMenu
        Case Is = LCase("vbeMenu")
            MenuType = VbeMenu
        Case Is = LCase("RightClickMenu")
            MenuType = RightClickMenu
        Case Else
    End Select
    If ws.Range(rBAR_LOCATION) <> "" Then
        BarLocation = ws.Range(rBAR_LOCATION)
    Else
        BarLocation = 0
    End If
    If MenuType = VbeMenu Then
        Select Case BarLocation
            Case Is = "Menu Bar", "Code Window", "Project Window", "Edit", "Debug", "Userform"
                Set TargetCommandbar = Application.VBE.CommandBars(BarLocation)
                SetCMDbar = True
            Case Else
                Set TargetCommandbar = Application.VBE.CommandBars.Add(C_TAG, Position:=msoBarTop, Temporary:=True)
                TargetCommandbar.visible = True
        End Select
    ElseIf MenuType = WorksheetMenu Then
        Select Case ws.Range(rBAR_LOCATION)
            Case Is = "Worksheet Menu Bar", "Cell", "Column", "Row"
                Set TargetCommandbar = Application.CommandBars(BarLocation)
                SetCMDbar = True
            Case Else
        End Select
    Else
    End If
End Function

Public Function BarExists(findBarName As String) As Boolean
    Dim bar As CommandBar
    For Each bar In Application.CommandBars
        If UCase(bar.Name) = UCase(findBarName) Then
            BarExists = True
            Exit Function
        End If
    Next bar
    For Each bar In Application.VBE.CommandBars
        If UCase(bar.Name) = UCase(findBarName) Then
            BarExists = True
            Exit Function
        End If
    Next bar
End Function

Public Sub BuildBarFromShape()
    '#INCLUDE CommandBarBuilder
    CommandBarBuilder ActiveSheet
End Sub

Public Sub DeleteBarFromShape()
    '#INCLUDE DeleteControlsAndHandlers
    DeleteControlsAndHandlers ActiveSheet
End Sub

Public Sub CommandBarBuilder(ws As Worksheet)
    '#INCLUDE SetCMDbar
    '#INCLUDE SetVariables
    '#INCLUDE ReSetVariables
    '#INCLUDE CreateMainMenu
    '#INCLUDE CreatePopup
    '#INCLUDE CreateButton
    '#INCLUDE DirectButton
    '#INCLUDE DeleteControlsAndHandlers
    If ws.Range("I4") = "" Or ws.Range("I5") = "" Or ws.Range("I6") = "" Then
        MsgBox "Ranges I4, I5 and I6 cannot be empty"
        Exit Sub
    End If
    DeleteControlsAndHandlers ws
    SetCMDbar ws
    Set MenuSheet = ws
    row = 2
    If MenuType = VbeMenu Then
        If BarLocation = "Menu Bar" Then
            Select Case LCase(ws.Range(rTARGET_CONTROL))
                Case LCase(ws.Range(rC_TAG))
                    Set TargetControl = TargetCommandbar.Controls.Add(Type:=msoControlPopup, Temporary:=True)
                Case Else
                    Dim vbControl As String
                    vbControl = ws.Range(rTARGET_CONTROL)
                    Set TargetControl = TargetCommandbar.Controls(vbControl).Controls.Add(Type:=msoControlPopup, Temporary:=True)
            End Select
        Else
            If LCase(ws.Range(rTARGET_CONTROL)) <> LCase(ws.Range(rC_TAG)) _
        And ws.Range(rTARGET_CONTROL) <> "" Then _
                                      Set TargetControl = TargetCommandbar.Controls.Add(Type:=msoControlPopup, Temporary:=True)
        End If
        If Not TargetControl Is Nothing Then
            TargetControl.Caption = C_TAG
            TargetControl.Tag = C_TAG
        End If
    End If
    Do Until IsEmpty(MenuSheet.Cells(row, 1))
        With MenuSheet
            SetVariables
        End With
        Select Case MenuLevel
            Case 1
                If NextLevel > MenuLevel Then
                    CreateMainMenu
                Else
                    DirectButton
                End If
            Case 2
                If NextLevel > MenuLevel Then
                    CreatePopup
                Else
                    DirectButton
                End If
            Case 3
                CreateButton
        End Select
        row = row + 1
        ReSetVariables
    Loop
End Sub

Private Sub markControlType(ws As Worksheet)
    ws.Columns("F").ClearContents
    Dim idx As Long: idx = 0
    Dim Description() As Variant
    Dim cell As Range
    Set cell = ws.Cells(2, 1)
    Do Until IsEmpty(cell)
        idx = idx + 1
        ReDim Preserve Description(1 To idx)
        Description(idx) = IIf(cell.OFFSET(1) > cell, "PopUp", "Button")
        Set cell = cell.OFFSET(1)
    Loop
    ws.Range("F2").RESIZE(UBound(Description)) = WorksheetFunction.Transpose(Description)
End Sub

Private Sub SetVariables()
    With MenuSheet
        MenuLevel = .Cells(row, 1)
        Caption = .Cells(row, 2)
        action = .Cells(row, 3)
        Divider = .Cells(row, 4)
        FaceId = .Cells(row, 5)
        NextLevel = .Cells(row + 1, 1)
    End With
End Sub

Private Sub ReSetVariables()
    MenuLevel = ""
    Caption = ""
    action = ""
    Divider = ""
    FaceId = ""
    NextLevel = ""
End Sub

Private Sub CreateMainMenu()
    If MenuType = VbeMenu Then
        Set MainMenu = TargetCommandbar.Controls.Add(Type:=msoControlPopup)
    ElseIf MenuType = WorksheetMenu Then
        Set MainMenu = TargetCommandbar.Controls.Add(Type:=msoControlPopup, Temporary:=True)
    ElseIf MenuType = RightClickMenu Then
        On Error Resume Next
        CommandBars.Add C_TAG, msoBarPopup, , True
        On Error GoTo 0
        Set MainMenu = CommandBars(C_TAG).Controls.Add(Type:=msoControlPopup)
    End If
    With MainMenu
        .Caption = Caption
        .BeginGroup = Divider
        If FaceId <> "" And action <> "" Then .FaceId = FaceId
        .Tag = C_TAG
    End With
End Sub

Private Sub CreatePopup()
    If MenuType = RightClickMenu Then
        Set MenuItem = MainMenu.Controls.Add(Type:=msoControlPopup)
    Else
        Set MenuItem = MainMenu.Controls.Add(Type:=msoControlPopup)
    End If
    With MenuItem
        .Caption = Caption
        .BeginGroup = Divider
        If FaceId <> "" And action <> "" Then .FaceId = FaceId
        .Tag = C_TAG
    End With
End Sub

Private Sub CreateButton()
    If MenuType = VbeMenu Then
        Set MenuEvent = New CVBECommandHandler
    End If
    Set CmdBarItem = MenuItem.Controls.Add
    With CmdBarItem
        .Caption = Caption
        .BeginGroup = Divider
        .OnAction = action
        If FaceId <> "" Then .FaceId = FaceId
        .Tag = C_TAG
    End With
    If MenuType = VbeMenu Then
        Set MenuEvent.EvtHandler = Application.VBE.Events.CommandBarEvents(CmdBarItem)
        EventHandlers.Add MenuEvent
    End If
End Sub

Private Sub DirectButton()
    Dim CmdBarItem As CommandBarControl
    If MenuType = VbeMenu Then
        Set MenuEvent = New CVBECommandHandler
    End If
    Select Case MenuLevel
        Case Is = 1
            Set CmdBarItem = TargetCommandbar.Controls.Add
        Case Is = 2
            Set CmdBarItem = MainMenu.Controls.Add
    End Select
    With CmdBarItem
        .Style = msoButtonIconAndCaption
        .Caption = Caption
        .BeginGroup = Divider
        .OnAction = action
        If FaceId <> "" Then .FaceId = FaceId
        .Tag = C_TAG
    End With
    If MenuType = VbeMenu Then
        Set MenuEvent.EvtHandler = Application.VBE.Events.CommandBarEvents(CmdBarItem)
        EventHandlers.Add MenuEvent
    End If
End Sub

Private Sub DeleteControlsAndHandlers(ws As Worksheet)
    '#INCLUDE BarExists
    '#INCLUDE DeleteHandlersFor
    If ws.Range(rC_TAG).TEXT = vbNullString Then Exit Sub
    Select Case LCase(ws.Range(rMENU_TYPE))
        Case "vbemenu"
            MenuType = VbeMenu
        Case "worksheetmenu"
            MenuType = WorksheetMenu
        Case "rightclickmenu"
            MenuType = RightClickMenu
    End Select
    If MenuType = VbeMenu Then
        If BarExists(ws.Range(rC_TAG)) Then
            Application.VBE.CommandBars(ws.Range(rC_TAG).TEXT).Delete
            Set ctrl = Application.VBE.CommandBars.FindControl(Tag:=ws.Range(rC_TAG).TEXT)
        End If
        Rem
    ElseIf MenuType = WorksheetMenu Then
        Set ctrl = Application.CommandBars.FindControl(Tag:=ws.Range(rC_TAG).TEXT)
    ElseIf MenuType = RightClickMenu Then
        If BarExists(ws.Range(rC_TAG).TEXT) Then
            CommandBars(ws.Range(rC_TAG).TEXT).Delete
        End If
        Exit Sub
    End If
    On Error Resume Next
    Do
        ctrl.Delete
        If MenuType = VbeMenu Then
            Rem
            Set ctrl = Application.VBE.CommandBars.FindControl(Tag:=ws.Range(rC_TAG).TEXT)
        Else
            Set ctrl = Application.CommandBars.FindControl(Tag:=ws.Range(rC_TAG).TEXT)
        End If
    Loop While Not ctrl Is Nothing
    On Error GoTo 0
    DeleteHandlersFor ws
End Sub

Private Sub DeleteHandlersFor(ws As Worksheet)
    On Error Resume Next
    Dim cell As Range
    Set cell = ws.Cells(2, 6)
    Do Until IsEmpty(cell)
        If cell.TEXT = "Button" Then
            EventHandlers.Remove cell.OFFSET(0, -3).TEXT
        End If
        Set cell = cell.OFFSET(1)
    Loop
End Sub

Private Sub ListWorksheetBars()
    Dim oCB As CommandBar
    Dim oWK As Worksheet
    Set oWK = ThisWorkbook.SHEETS("ListSheetBars")
    oWK.Cells.clear
    Dim arr As Variant
    arr = Array("Type", "Index", "Name", "Built-in", "Visible")
    Dim iCol As Integer
    iCol = UBound(arr) + 1
    oWK.Range("a1").RESIZE(1, iCol) = arr
    oWK.Range("a1").RESIZE(1, iCol).Cells.Font.Bold = True
    Dim i As Long
    i = 2
    Dim cbVar(300, 4) As Variant
    For Each oCB In Excel.Application.CommandBars
        cbVar(i - 2, 0) = Choose(oCB.Type + 1, "Toolbar", "Menu", "PopUp")
        cbVar(i - 2, 1) = oCB.index
        cbVar(i - 2, 2) = oCB.Name
        cbVar(i - 2, 3) = oCB.BuiltIn
        cbVar(i - 2, 4) = oCB.visible
        i = i + 1
    Next
    oWK.Cells(2, 1).RESIZE(UBound(cbVar, 1) + 1, UBound(cbVar, 2) + 1) = cbVar
    oWK.Columns.AutoFit
End Sub

Private Sub ListVBEBars()
    Dim oCB As CommandBar
    Dim oWK As Worksheet
    Set oWK = ThisWorkbook.SHEETS("ListVBEBars")
    oWK.Cells.clear
    Dim arr As Variant
    arr = Array("Type", "Index", "Name", "Built-in", "Visible")
    Dim iCol As Integer
    iCol = UBound(arr) + 1
    oWK.Range("a1").RESIZE(1, iCol) = arr
    oWK.Range("a1").RESIZE(1, iCol).Cells.Font.Bold = True
    Dim i As Long
    i = 2
    Dim cbVar(300, 4) As Variant
    For Each oCB In Application.VBE.CommandBars
        cbVar(i - 2, 0) = Choose(oCB.Type + 1, "Toolbar", "Menu", "PopUp")
        cbVar(i - 2, 1) = oCB.index
        cbVar(i - 2, 2) = oCB.Name
        cbVar(i - 2, 3) = oCB.BuiltIn
        cbVar(i - 2, 4) = oCB.visible
        i = i + 1
    Next
    oWK.Cells(2, 1).RESIZE(UBound(cbVar, 1) + 1, UBound(cbVar, 2) + 1) = cbVar
    oWK.Columns.AutoFit
End Sub

Private Sub exampleOfControls()
    Dim cbc As CommandBarControl
    Dim cbb As CommandBarButton
    Dim cbcm As CommandBarComboBox
    Dim cbp As CommandBarPopup
    With Application.VBE.CommandBars("CodeArchive")
        Set cbc = .Controls.Add(ID:=3, Temporary:=True)
        Set cbb = .Controls.Add(Temporary:=True)
        cbb.Caption = "A new command"
        cbb.Style = msoButtonCaption
        cbb.OnAction = "NewCommand_OnAction"
        Set cbcm = .Controls.Add(Type:=msoControlComboBox, Temporary:=True)
        cbcm.Caption = "Combo:"
        cbcm.AddItem "list entry 1"
        cbcm.AddItem "list entry 2"
        cbcm.OnAction = "NewCommand_OnAction"
        cbcm.Style = msoComboLabel
        Set cbc = .Controls.Add(Type:=msoControlDropdown, Temporary:=True)
        cbc.Caption = "Dropdown:"
        cbc.AddItem "list entry 1"
        cbc.AddItem "list entry 2"
        cbc.OnAction = "MenuDropdown_OnAction"
        Set cbp = .Controls.Add(Type:=msoControlPopup, Temporary:=True)
        cbp.Caption = "new sub menu"
        Set cbb = cbp.Controls.Add
        cbb.Caption = "sub entry 1"
        Set cbb = cbp.Controls.Add
        cbb.Caption = "sub entry 2"
    End With
End Sub

Private Sub ImageFromEmbedded()
    Dim p As Excel.Picture
    Dim Btn As Office.CommandBarButton
    Set Btn = Application.CommandBars.FindControl(ID:=30007) _
        .Controls.Add(Type:=msoControlButton, Temporary:=True)
    Set p = Worksheets("Sheet1").Pictures("ThePict")
    p.CopyPicture xlScreen, xlBitmap
    With Btn
        .Caption = "Click Me"
        .Style = msoButtonIconAndCaption
        .PasteFace
    End With
End Sub

Private Sub ImageFromExternalFile()
    Dim Btn As Office.CommandBarButton
    Set Btn = Application.CommandBars.FindControl(ID:=30007) _
        .Controls.Add(Type:=msoControlButton, Temporary:=True)
    With Btn
        .Caption = "Click Me"
        .Style = msoButtonIconAndCaption
        .Picture = LoadPicture("C:\TestPic.bmp")
    End With
End Sub

Private Sub ResetCBAR()
    Excel.Application.CommandBars("Cell").Reset
End Sub

Public Function IsLoaded(FormName As String) As Boolean
    Dim frm As Object
    For Each frm In VBA.UserForms
        If frm.Name = FormName Then
            IsLoaded = True
            Exit Function
        End If
    Next frm
    IsLoaded = False
End Function

Sub openUValiationDropdown()
    lngValType = ActiveCell.Validation.Type
    Select Case lngValType
        Case Is = 3
            uValidationDropdown.Show
        Case Else
            Unload uValidationDropdown
    End Select
End Sub

'''''NOTES'''''''
'''''''''''''''''
'----------------------
'WORKSHEET COMMAND BARS
'----------------------
'Application.CommandBars("Worksheet Menu Bar").Controls.Add
'Application.CommandBars("Cell").Controls.Add
'Application.CommandBars("Column").Controls.Add
'Application.CommandBars("Row").Controls.Add
'----------------------
''VBE COMMAND BARS
'----------------------
'----------------------
''add your own command bar
'----------------------
'With Application.VBE.CommandBars.Add("CodeArchive", Position:=msoBarFloating, Temporary:=True)
'    .Visible = True
'End With
'Application.VBE.CommandBars("CodeArchive").Delete
'----------------------
''use existing command bars
'----------------------
'Set TargetControl = Application.VBE.CommandBars("Menu Bar").Controls.Add(Type:=msoControlPopup, Temporary:=True)
'Set TargetControl = Application.VBE.CommandBars("Code Window").Controls.Add(Type:=msoControlPopup, Temporary:=True)
'Set TargetControl = Application.VBE.CommandBars("Project Window").Controls.Add(Type:=msoControlPopup, Temporary:=True)
'Set TargetControl = Application.VBE.CommandBars("Edit").Controls.Add(Type:=msoControlPopup, Temporary:=True)
'Set TargetControl = Application.VBE.CommandBars("Debug").Controls.Add(Type:=msoControlPopup, Temporary:=True)
'Set TargetControl = Application.VBE.CommandBars("Userform").Controls.Add(Type:=msoControlPopup, Temporary:=True)
'----------------------
''use existing controls
'----------------------
'Set TargetControl = Application.VBE.CommandBars("Menu Bar").Controls.("Tools")
'-----------
'Use combobox
'-----------
''call a sub through class events handler
''the sub to contain the following
'With Application.VBE.ActiveCodePane
'  Text = Application.VBE.CommandBars(mcToolBar).Controls(mcInsertList).Text
'  .GetSelection StartLine, StartColumn, EndLine, EndColumn
'  .CodeModule.InsertLines StartLine, Text
'  .SetSelection StartLine, 1, StartLine, 1
'End With



'CVBECommandHandler	2

Public WithEvents EvtHandler As VBIDE.CommandBarEvents

Public Sub EvtHandler_Click(ByVal CommandBarControl As Object, _
                            Handled As Boolean, CancelDefault As Boolean)
    On Error Resume Next
    Application.Run CommandBarControl.OnAction
    Handled = True
    CancelDefault = True
End Sub



'uValidationDropdown	3


'Private Sub CommandButton1_Click()
'    If Me.Height > 224 Then
'        Me.Height = 175
'        CommandButton1.Caption = "V"
'    Else
'        Me.Height = 225
'        CommandButton1.Caption = "Ë"
'    End If
'End Sub

Private Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim lngValType As Long
    On Error Resume Next
    lngValType = ActiveCell.Validation.Type
    On Error GoTo 0
    If lngValType = 3 Then updateData
End Sub

Private Sub ListBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    '    If KeyCode = 13 Then
    '        updateData
    '    End If
    '    UVDRefreshList
End Sub

Private Sub TextBox1_Change()
    UVDRefreshList
End Sub

Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = 13 Then
        updateData
    End If
End Sub

Private Sub TextBox1_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Select Case KeyCode
        Case 27        'ESC
            Unload Me
    End Select
End Sub

Private Sub UserForm_Activate()
    UVDRefreshList
End Sub

Sub updateData()
    '#INCLUDE UVDRefreshList
    ActiveCell.Value = Me.ListBox1.Value
    If Me.oClose.Value = True Then
        Me.TextBox1.Value = ""
        Unload Me
    ElseIf Me.oDown.Value = True Then
        ActiveCell.OFFSET(1, 0).Select
        If Me.TextBox1.Value <> "" Then
            Me.TextBox1.Value = ""
        Else
            UVDRefreshList
        End If
        If Me.ListBox1.ListCount = 0 Then Unload Me
    ElseIf Me.oRight.Value = True Then
        ActiveCell.OFFSET(0, 1).Select
        If Me.TextBox1.Value <> "" Then
            Me.TextBox1.Value = ""
        Else
            UVDRefreshList
        End If
        If Me.ListBox1.ListCount = 0 Then Unload Me
    ElseIf Me.oNone.Value = True Then
        Me.TextBox1.Value = ""
    End If
End Sub

Sub UVDRefreshList()
    '#INCLUDE ValidRange
    '#INCLUDE isValidation
    Me.ListBox1.clear
    Dim rng As Range
    Dim cell As Range
    If isValidation(ActiveCell) = False Then Exit Sub
    If ValidRange(ActiveCell.Validation.Formula1) = True Then
        Set rng = Range(Replace(ActiveCell.Validation.Formula1, "=", ""))
        For Each cell In rng
            If Me.TextBox1.Value = "" Then
                Me.ListBox1.AddItem cell.Value
            Else
                If InStr(cell.Value, UCase(Me.TextBox1.Value)) > 0 Then
                    Me.ListBox1.AddItem cell.Value
                End If
            End If
        Next
    ElseIf InStr(1, ActiveCell.Validation.Formula1, ",") > 0 Then
        Dim var
        var = Split(ActiveCell.Validation.Formula1, ",")
        Dim element
        For Each element In var
            Me.ListBox1.AddItem element
        Next
    Else
        Unload Me
    End If
    
    FilterListboxByColumn ListBox1, TextBox1
    
    On Error Resume Next
    Me.ListBox1.ListIndex = 0
    On Error GoTo 0

End Sub

Function ValidRange(str As String) As Boolean
    Dim rng As Range
    On Error Resume Next
    Set rng = Range(Replace(str, "=", ""))
    On Error GoTo 0
    If rng Is Nothing Then
        ValidRange = False
    Else
        ValidRange = True
    End If
End Function

Function isValidation(rng As Range) As Boolean
    Dim dvtype As Integer
    On Error Resume Next
    dvtype = rng.Validation.Type
    On Error GoTo 0
    If dvtype = 3 Then
        isValidation = True
    Else
        isValidation = False
    End If
End Function

Private Sub UserForm_Initialize()
    LoadUserformOptions Me
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    SaveUserformOptions Me, , , False, False
End Sub


'Sheet29	100



'M_BarmanExample	1

Rem @Folder BarmanExamples Declarations
Public Const Mname As String = "MyPopUpMenu"

Rem @Folder BarmanExamples
Sub DeletePopUpMenu()
    'Delete PopUp menu if it exist
    On Error Resume Next
    Application.CommandBars(Mname).Delete
    On Error GoTo 0
End Sub

Sub CreateDisplayPopUpMenu()
    'Delete PopUp menu if it exist
    '#INCLUDE DeletePopUpMenu
    '#INCLUDE Custom_PopUpMenu_1
    Call DeletePopUpMenu
    'Create the PopUpmenu
    Call Custom_PopUpMenu_1
    'Show the PopUp menu
    On Error Resume Next
    Application.CommandBars(Mname).ShowPopup
    On Error GoTo 0
End Sub

Sub Custom_PopUpMenu_1()
    '#INCLUDE TestMacro
    Dim MenuItem As CommandBarPopup
    'Add PopUp menu
    With Application.CommandBars.Add(Name:=Mname, Position:=msoBarPopup, _
                                     MenuBar:=False, Temporary:=True)
        'First add two buttons
        With .Controls.Add(Type:=msoControlButton)
            .Caption = "Button 1"
            .FaceId = 71
            .OnAction = "'" & ThisWorkbook.Name & "'!" & "TestMacro"
        End With
        With .Controls.Add(Type:=msoControlButton)
            .Caption = "Button 2"
            .FaceId = 72
            .OnAction = "'" & ThisWorkbook.Name & "'!" & "TestMacro"
        End With
        'Second Add menu with two buttons
        Set MenuItem = .Controls.Add(Type:=msoControlPopup)
        With MenuItem
            .Caption = "My Special Menu"
            With .Controls.Add(Type:=msoControlButton)
                .Caption = "Button 1 in menu"
                .FaceId = 71
                .OnAction = "'" & ThisWorkbook.Name & "'!" & "TestMacro"
            End With
            With .Controls.Add(Type:=msoControlButton)
                .Caption = "Button 2 in menu"
                .FaceId = 72
                .OnAction = "'" & ThisWorkbook.Name & "'!" & "TestMacro"
            End With
        End With
        'Third add one button
        With .Controls.Add(Type:=msoControlButton)
            .Caption = "Button 3"
            .FaceId = 73
            .OnAction = "'" & ThisWorkbook.Name & "'!" & "TestMacro"
        End With
    End With
End Sub

Sub TestMacro()
    MsgBox "Hi There, greetings from the Netherlands"
End Sub

Sub TestProcedure()
    MsgBox "ok"
End Sub

Sub DeleteNotBuiltInCommandbars()
    For Each b In Application.CommandBars
        If b.BuiltIn = False Then b.Delete
    Next
End Sub



'Sheet4	100



'Sheet5	100



'F_VbeFormat	1


Rem @Folder Format Declarations
Public Enum ProcedureScope
    PRIVATE_SCOPE = 1
    Public_SCOPE = 2
    FRIEND_SCOPE = 3
    DEFAULT_SCOPE = 4
End Enum

Public Enum LineSplits
    LineSplitRemove = 0
    LineSplitKeep = 1
    LineSplitConvert = 2
End Enum

Public Type ProcInfo
    procName As String
    ProcKind As VBIDE.vbext_ProcKind
    ProcStartLine As Long
    ProcBodyLine As Long
    ProcCountLines As Long
    ProcedureScope As ProcedureScope
    ProcDeclaration As String
End Type

Rem @Folder FormatVBATools Declarations
Private Const vbTab2 = vbTab & vbTab
Private Const vbTab4 = vbTab2 & vbTab2
Private Const ctFormat = "dd-mm-yyyy hh:nn"

Rem @Folder Format
Sub FormatVBA7()
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE ActiveModule
    '#INCLUDE CLIP
    '#INCLUDE collectionToString
    '#INCLUDE SortCollection
    Dim selectedText
    selectedText = ActiveModule.CodeModule.Lines(CodePaneSelectionStartLine, CodePaneSelectionEndLine - CodePaneSelectionStartLine + 1)
    selectedText = Split(selectedText, vbNewLine)
    Dim IsVba7 As String
    Dim NotVba7 As String
    Dim colIsVBA7 As New Collection
    Dim colNotVBA7 As New Collection
    Dim i As Long
    For i = LBound(selectedText) To UBound(selectedText)
        If InStr(1, selectedText(i), "PtrSafe", vbTextCompare) Then
            IsVba7 = selectedText(i)
            NotVba7 = Replace(selectedText(i), "Declare ptrsafe ", "Declare ", , , vbTextCompare)
        Else
            IsVba7 = Replace(selectedText(i), "Declare ", "Declare PtrSafe ")
            NotVba7 = selectedText(i)
        End If
        colIsVBA7.Add IsVba7
        colNotVBA7.Add NotVba7
    Next
    Set colIsVBA7 = SortCollection(colIsVBA7)
    Set colNotVBA7 = SortCollection(colNotVBA7)
    Dim out As String
    out = "#If VBA7 then" & vbNewLine & _
          collectionToString(colIsVBA7, vbNewLine) & vbNewLine & _
          "#Else" & vbNewLine & _
          collectionToString(colNotVBA7, vbNewLine) & vbNewLine & _
          "#End If"
    CLIP out
    MsgBox "copied to clipboard"
End Sub

Sub AlignVbeComments()
    '#INCLUDE AlignCodepaneLineElements
    AlignCodepaneLineElements "'"
End Sub

Sub AlignDimAs()
    '#INCLUDE AlignCodepaneLineElements
    AlignCodepaneLineElements "As"
End Sub

Sub AlignCodepaneLineElements(AlignString As String, Optional AlignAtColumn As Long)
    '#INCLUDE Inject
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE CodePaneSelectionSet
    '#INCLUDE ActiveModule
    Dim firstRow As Long
    firstRow = CodePaneSelectionStartLine
    Dim LastRow As Long
    LastRow = CodePaneSelectionEndLine
    Dim elementOriginalColumn As Long
    Dim LineText As String
    Dim i As Long
    Dim rightMostColumn As Long
    For i = firstRow To LastRow
        LineText = ActiveModule.CodeModule.Lines(i, 1)
        elementOriginalColumn = InStrRev(LineText, AlignString)
        If elementOriginalColumn > rightMostColumn Then rightMostColumn = elementOriginalColumn
    Next
    If AlignAtColumn = 0 Then AlignAtColumn = rightMostColumn
    Dim numberOfSpacesToInsert
    For i = firstRow To LastRow
        LineText = ActiveModule.CodeModule.Lines(i, 1)
        elementOriginalColumn = InStr(1, LineText, AlignString)
        If elementOriginalColumn > 0 Then
            numberOfSpacesToInsert = AlignAtColumn - elementOriginalColumn
            If numberOfSpacesToInsert > 0 Then
                elementOriginalColumn = InStrRev(LineText, AlignString)
                CodePaneSelectionSet i, elementOriginalColumn, i, elementOriginalColumn
                Inject Space(numberOfSpacesToInsert)
            End If
        End If
    Next
End Sub

Sub InsertTimerToProcedure(Optional TargetWorkbook As Workbook, Optional Procedure As String)
    '#INCLUDE InsertStringToProcedureBody
    '#INCLUDE InsertStringToProcedureEnd
    '#INCLUDE StartTimer
    '#INCLUDE EndTimer
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveProcedure
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If Procedure = "" Then Procedure = ActiveProcedure
    Dim ProcedureText As String
    ProcedureText = GetProcText(ModuleOfProcedure(TargetWorkbook, Procedure), Procedure)
    If InStr(1, ProcedureText, "StartTimer") > 0 Then Exit Sub
    InsertStringToProcedureBody TargetWorkbook, CStr(Procedure), "StartTimer"
    Sleep 100
    InsertStringToProcedureEnd TargetWorkbook, CStr(Procedure), "EndTimer"
End Sub

Sub InsertStringToProcedureStart(TargetWorkbook As Workbook, Procedure As String, AddThis As String, Optional SkipIfExists As Boolean = True)
    Rem as comment before Procedure declaration
    '#INCLUDE ProcedureStartLine
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    Dim Module As VBComponent: Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
    If SkipIfExists = True Then
        If InStr(1, GetProcText(Module, Procedure), AddThis) > 0 Then Exit Sub
    End If
    Module.CodeModule.InsertLines ProcedureStartLine(Module, Procedure), vbNewLine & "'" & AddThis
End Sub

Sub InsertStringToProcedureBody(TargetWorkbook As Workbook, Procedure As String, AddThis As String, Optional SkipIfExists As Boolean = True)
    '#INCLUDE ProcedureFirstLine
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    Dim Module As VBComponent: Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
    If SkipIfExists = True Then
        If InStr(1, GetProcText(Module, CStr(Procedure)), AddThis) > 0 Then Exit Sub
    End If
    Module.CodeModule.InsertLines ProcedureFirstLine(Module, Procedure), AddThis
End Sub

Sub InsertStringToProcedureEnd(TargetWorkbook As Workbook, Procedure As String, AddThis As String, Optional SkipIfExists As Boolean = True)
    '#INCLUDE ProcedureEndLine
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    Dim Module As VBComponent: Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
    If SkipIfExists = True Then
        If InStr(1, GetProcText(Module, CStr(Procedure)), AddThis) > 0 Then Exit Sub
    End If
    Module.CodeModule.InsertLines ProcedureEndLine(Module, Procedure), AddThis
End Sub

Sub CaseProperModulesOfWorkbook(Optional TargetWorkbook As Workbook)
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Name <> "ThisWorkbook" Then
            Module.Name = UCase(left(Module.Name, 1)) & Mid(Module.Name, 2)
        End If
    Next
End Sub

Sub MODULEINFO(Optional Module As VBComponent)
    '#INCLUDE ProcListCollection
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    s = s & vbNewLine
    s = s & vbNewLine & "'" & "Module Name: " & Module.Name & "'"
    s = s & vbNewLine & "'" & "Procedures Count: " & ProcListCollection(Module).count
    s = s & vbNewLine & "'" & "Lines: " & Module.CodeModule.CountOfLines & " of which " & Module.CodeModule.CountOfDeclarationLines & " are declaration or comments at the top"
    s = s & vbNewLine
    Module.CodeModule.InsertLines 1, s
End Sub

Sub InjectDevInfo()
    '#INCLUDE DevInfo
    '#INCLUDE Inject
    '#INCLUDE CodepaneSelection
    If Len(CodepaneSelection) = 0 Then Inject DevInfo
End Sub

Function DevInfo() As String
    '#INCLUDE DpHeader
    '#INCLUDE CLIP
    Dim i As Long: i = 14
    Dim Character As String: Character = "_"
    DevInfo = DpHeader(Array( _
                       "AUTHOR     " & AUTHOR_NAME, _
                       "EMAIL      " & AUTHOR_EMAIL, _
                       "GITHUB     " & AUTHOR_GITHUB, _
                       "YOUTUBE    " & AUTHOR_YOUTUBE, _
                       "VK         " & AUTHOR_VK) _
                       , , , True, True)
    CLIP DevInfo
End Function

Sub CreateShapeButtonToRunProcedure(Optional Procedure As String = "")
    '#INCLUDE ActiveProcedure
    '#INCLUDE AddShape
    If TypeName(Selection) <> "Range" Then
        MsgBox "Select cell to contain the shape"
        Exit Sub
    End If
    If Procedure = "" Then Procedure = ActiveProcedure
    With AddShape
        .OnAction = Procedure
        .Name = "ProcButton_" & Procedure
        .TextFrame2.TextRange.TEXT = Procedure
        .TextFrame2.TextRange.Font.Bold = msoTrue
        .TextFrame2.TextRange.Font.Size = 14
        .TextFrame.HorizontalAlignment = xlHAlignCenter
        .TextFrame2.WordWrap = msoFalse
        .TextFrame2.AutoSize = msoAutoSizeShapeToFitText
        .left = Selection.left
        .top = Selection.top
    End With
End Sub

Public Sub RemoveBlankLinesFromModule(Optional Module As VBComponent)
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    Dim n As Long, s As String
    With Module.CodeModule
        For n = .CountOfLines To 1 Step -1
            s = .Lines(n, 1)
            If Trim(s) = vbNullString Then
                If n > 1 Then
                    If InStr(1, Module.CodeModule.Lines(n - 1, 1), "End Sub") = 0 _
                                                                                Or InStr(1, Module.CodeModule.Lines(n - 1, 1), "End Function") = 0 Then
                        Module.CodeModule.DeleteLines n
                    End If
                End If
            ElseIf left(Trim(s), 1) = "'" Then
            Else
            End If
        Next n
    End With
End Sub

Public Sub RemoveBlankLinesFromActiveProcedure()
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    Dim n As Long, s As String
    Dim Module As VBIDE.VBComponent: Set Module = ActiveModule
    Dim procName As String: procName = ActiveProcedure
    For n = ProcedureEndLine(Module, procName) To ProcedureStartLine(Module, procName) Step -1
        s = Module.CodeModule.Lines(n, 1)
        If Trim(s) = vbNullString Then
            If n > 1 Then
                If InStr(1, Module.CodeModule.Lines(n - 1, 1), "End Sub") = 0 Or _
                                                                            InStr(1, Module.CodeModule.Lines(n - 1, 1), "End Function") = 0 Then
                    Module.CodeModule.DeleteLines n
                End If
            End If
        ElseIf left(Trim(s), 1) = "'" Then
        Else
        End If
    Next
End Sub

Public Sub RemoveBlankLinesFromWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE RemoveBlankLinesFromModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        RemoveBlankLinesFromModule Module
    Next
End Sub

Public Sub CaseLower()
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & LCase(Code) & _
                    PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Public Sub CaseProper()
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & WorksheetFunction.Proper(Code) & _
                                       PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Public Sub CaseUpper()
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & UCase(Code) & _
                    PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Sub RemoveEmptyModules(Optional TargetWorkbook As Workbook)
    '#INCLUDE ProcListCollection
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Type = vbext_ct_StdModule Then
            If ProcListCollection(Module).count = 0 And Module.CodeModule.CountOfLines < 3 Then TargetWorkbook.VBProject.VBComponents.Remove Module
        End If
    Next
End Sub

Sub MoveProcedureToOtherModule(ProcedureName As String, FromWorkbook As Workbook, TargetModule As VBComponent)
    '#INCLUDE ModuleOfProcedure
    Dim Module As VBComponent
    Set Module = ModuleOfProcedure(FromWorkbook, ProcedureName)
    With Module.CodeModule
        c00 = .Lines(.ProcStartLine(ProcedureName, 0), .ProcCountLines(ProcedureName, 0))
        .DeleteLines .ProcStartLine(ProcedureName, 0), .ProcCountLines(ProcedureName, 0)
    End With
    TargetModule.CodeModule.AddFromString c00
End Sub

Sub MoveModuleTextToOtherModule(FromModule As VBComponent, TargetModule As VBComponent)
    Dim ModuleDeclarations As String
    Dim ModuleCode As String
    Dim counter As Long
    If FromModule.CodeModule.CountOfDeclarationLines > 0 Then
        ModuleDeclarations = "Rem @Folder " & FromModule.Name
        For counter = 1 To FromModule.CodeModule.CountOfDeclarationLines
            ModuleDeclarations = ModuleDeclarations & vbNewLine & FromModule.CodeModule.Lines(counter, 1)
        Next
    End If
    If FromModule.CodeModule.CountOfLines - FromModule.CodeModule.CountOfDeclarationLines > 0 Then
        For counter = FromModule.CodeModule.CountOfDeclarationLines + 1 To FromModule.CodeModule.CountOfLines
            ModuleCode = ModuleCode & vbNewLine & FromModule.CodeModule.Lines(counter, 1)
        Next
    End If
    With TargetModule.CodeModule
        .InsertLines 1, ModuleDeclarations
        .InsertLines .CountOfLines + 1, ModuleCode
    End With
    With FromModule.CodeModule
        If .CountOfLines > 0 Then
            For counter = 1 To .CountOfLines
                .ReplaceLine counter, "' " & .Lines(counter, 1)
            Next
        End If
    End With
End Sub

Sub MergeModules( _
    FromWorkbook As Workbook, _
    TargetModule As VBComponent, _
    Optional OnlyTheseModules As Variant)
    '#INCLUDE MoveModuleTextToOtherModule
    Dim Module As VBComponent
    If OnlyTheseModules Is Nothing Then
        For Each Module In FromWorkbook.VBProject.VBComponents
            If Module.Type = vbext_ct_StdModule Then
                If Module.Name <> TargetModule.Name Then MoveModuleTextToOtherModule Module, TargetModule
            End If
        Next
    Else
        For Each Module In OnlyTheseModules
            MoveModuleTextToOtherModule Module, TargetModule
        Next
    End If
End Sub

Sub MoveProceduresFromAllUserformsToModules(Optional TargetWorkbook As Workbook)
    '#INCLUDE MoveProceduresFromUserformToModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Type = vbext_ct_MSForm Then
            MoveProceduresFromUserformToModule Module
        End If
    Next
End Sub

Sub MoveProceduresFromUserformToModule(Optional form As VBComponent)
    '#INCLUDE ProcListCollection
    '#INCLUDE ActiveModule
    '#INCLUDE CreateOrSetModule
    '#INCLUDE GetProcText
    '#INCLUDE WorkbookOfModule
    If form Is Nothing Then Set form = ActiveModule
    Rem Procedures without underscore "_" can be moved to a module
    Rem possible error if the procedures rely on const or enums or variables contained in form codemodule
    If form.Type <> vbext_ct_MSForm Then Exit Sub
    Dim TargetModule As VBComponent
    Set TargetModule = CreateOrSetModule("m" & form.Name, vbext_ct_StdModule, WorkbookOfModule(form))
    Dim strProc As String, StartLine As Long, totalLines As Long
    Dim Procedure As Variant
    Dim procedures As New Collection
    Set procedures = ProcListCollection(form)
    For Each Procedure In procedures
        If InStr(1, Procedure, "_") > 0 Then
        Else
            strProc = GetProcText(form, CStr(Procedure))
            StartLine = form.CodeModule.ProcStartLine(CStr(Procedure), vbext_pk_Proc)
            totalLines = form.CodeModule.ProcCountLines(CStr(Procedure), vbext_pk_Proc)
            TargetModule.CodeModule.AddFromString strProc
            form.CodeModule.DeleteLines StartLine, totalLines
        End If
    Next Procedure
End Sub

Sub RemoveLinesFromWorkbook(Optional TargetWorkbook As Workbook, Optional ContainsThis As String)
    '#INCLUDE RemoveLinesFromModule
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE InputboxString
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If ContainsThis = "" Then ContainsThis = InputboxString("Delete lines from " & TargetWorkbook.Name, _
                                                            "Delete lines containing what text?")
    If ContainsThis = "" Then Exit Sub
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        RemoveLinesFromModule Module, ContainsThis
    Next
End Sub

Public Sub RemoveLinesFromModule(Optional Module As VBComponent, Optional ContainsThis As String)
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    With Module.CodeModule
        For j = .CountOfLines To 1 Step -1
            LineText = Trim(.Lines(j, 1))
            If InStr(1, LineText, ContainsThis, vbTextCompare) > 0 Then
                .DeleteLines j, 1
            End If
        Next
    End With
End Sub

Public Sub RemoveCommentsFromModule(Optional Module As VBComponent, Optional RemoveRem As Boolean)
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    Dim n               As Long
    Dim i               As Long
    Dim j               As Long
    Dim k               As Long
    Dim l               As Long
    Dim LineText        As String
    Dim exitString      As String
    Dim QUOTES          As Long
    Dim Q               As Long
    Dim StartPos        As Long
    With Module.CodeModule
        For j = .CountOfLines To 1 Step -1
            LineText = Trim(.Lines(j, 1))
            If LineText = "ExitString = " & _
               """" & "Ignore Comments In This Module" & """" Then
                Exit For
            End If
            StartPos = 1
retry:
            n = InStr(StartPos, LineText, "'")
            Q = InStr(StartPos, LineText, """")
            QUOTES = 0
            If Q < n Then
                For l = 1 To n
                    If Mid(LineText, l, 1) = """" Then
                        QUOTES = QUOTES + 1
                    End If
                Next l
            End If
            If QUOTES = Application.WorksheetFunction.Odd(QUOTES) Then
                StartPos = n + 1
                GoTo retry:
            Else
                Select Case n
                    Case Is = 0
                    Case Is = 1
                        .DeleteLines j, 1
                    Case Is > 1
                        .ReplaceLine j, left(LineText, n - 1)
                End Select
                If RemoveRem Then
                    If left(LineText, 4) = "Rem " Then .ReplaceLine j, " "
                End If
            End If
        Next j
    End With
    exitString = "Ignore Comments In This Module"
End Sub

Public Sub RemoveCommentsFromActiveProcedure(Optional RemoveRem As Boolean)
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim n               As Long
    Dim i               As Long
    Dim j               As Long
    Dim k               As Long
    Dim l               As Long
    Dim LineText        As String
    Dim exitString      As String
    Dim QUOTES          As Long
    Dim Q               As Long
    Dim StartPos        As Long
    Dim StartLine As Long
    StartLine = ProcedureStartLine(Module, ActiveProcedure)
    Dim EndLine As Long
    EndLine = ProcedureEndLine(Module, ActiveProcedure)
    With Module.CodeModule
        For j = EndLine To StartLine Step -1
            LineText = Trim(.Lines(j, 1))
            If LineText = "ExitString = " & _
               """" & "Ignore Comments In This Module" & """" Then
                Exit For
            End If
            StartPos = 1
retry:
            n = InStr(StartPos, LineText, "'")
            Q = InStr(StartPos, LineText, """")
            QUOTES = 0
            If Q < n Then
                For l = 1 To n
                    If Mid(LineText, l, 1) = """" Then
                        QUOTES = QUOTES + 1
                    End If
                Next l
            End If
            If QUOTES = Application.WorksheetFunction.Odd(QUOTES) Then
                StartPos = n + 1
                GoTo retry:
            Else
                Select Case n
                    Case Is = 0
                    Case Is = 1
                        .DeleteLines j, 1
                    Case Is > 1
                        .ReplaceLine j, left(LineText, n - 1)
                End Select
                If RemoveRem Then
                    If left(LineText, 4) = "Rem " Then .ReplaceLine j, " "
                End If
            End If
        Next j
    End With
    exitString = "Ignore Comments In This Module"
End Sub

Public Sub RemoveCommentsFromWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE RemoveCommentsFromModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBIDE.VBComponent
    For Each Module In ActiveCodepaneWorkbook.VBProject.VBComponents
        RemoveCommentsFromModule Module
    Next
End Sub

Public Sub ReplaceQuoteWithRemInProcedure(Optional Module As VBComponent, Optional procName As String)
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    If Module Is Nothing Then Set Module = ActiveModule
    If procName = "" Then procName = ActiveProcedure
    Dim n As Long
    Dim s As String
    With Module.CodeModule
        For n = ProcedureEndLine(Module, ActiveProcedure) To ProcedureStartLine(Module, ActiveProcedure) Step -1
            s = .Lines(n, 1)
            If left(Trim(s), 1) = "'" Then
                .ReplaceLine n, Replace(s, "'", "Rem ", , 1)
            End If
        Next n
    End With
End Sub

Public Sub ReplaceQuoteWithRemInModule(Optional Module As VBComponent)
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    Dim n As Long
    Dim s As String
    With Module.CodeModule
        For n = .CountOfLines To 1 Step -1
            If .CountOfLines = 0 Then Exit For
            s = .Lines(n, 1)
            If left(Trim(s), 1) = "'" Then
                .ReplaceLine n, Replace(s, "'", "Rem ", , 1)
            End If
        Next n
    End With
End Sub

Public Sub ReplaceQuoteWithRemInWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE ReplaceQuoteWithRemInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    For Each vbComp In TargetWorkbook.VBProject.VBComponents
        ReplaceQuoteWithRemInModule vbComp
    Next
End Sub

Public Sub DisableDebugPrintInModule(Optional Module As VBComponent)
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    Dim n As Long
    Dim s As String
    With Module.CodeModule
        For n = .CountOfLines To 1 Step -1
            If .CountOfLines = 0 Then Exit For
            s = .Lines(n, 1)
            If left(Trim(s), 5) = "Debug" Then
                .ReplaceLine n, "'" & s
            End If
        Next n
    End With
End Sub

Public Sub DisableDebugPrintInProcedure(Optional Module As VBComponent, Optional procName As String)
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    If Module Is Nothing Then Set Module = ActiveModule
    If procName = "" Then procName = ActiveProcedure
    Dim n As Long
    Dim s As String
    With Module.CodeModule
        For n = ProcedureEndLine(Module, ActiveProcedure) To ProcedureStartLine(Module, ActiveProcedure) Step -1
            s = .Lines(n, 1)
            If left(Trim(s), 5) = "Debug" Then
                .ReplaceLine n, "'" & s
            End If
        Next n
    End With
End Sub

Public Sub DisableDebugPrintInWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE DisableDebugPrintInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each vbComp In TargetWorkbook.VBProject.VBComponents
        DisableDebugPrintInModule Module
    Next
End Sub

Public Sub EnableDebugPrintInModule(Optional Module As VBComponent)
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    Dim n As Long
    Dim s As String
    With Module.CodeModule
        For n = .CountOfLines To 1 Step -1
            If .CountOfLines = 0 Then Exit For
            s = .Lines(n, 1)
            If left(Trim(s), 6) = "'Debug" Then
                s = Replace(s, "'", "", , 1)
                .ReplaceLine n, s
            ElseIf left(Trim(s), 1) = "'" Then
            Else
            End If
        Next n
    End With
End Sub

Public Sub EnableDebugPrintInProcedure(Optional Module As VBComponent, Optional procName As String)
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    If Module Is Nothing Then Set Module = ActiveModule
    If procName = "" Then procName = ActiveProcedure
    Dim n As Long
    Dim s As String
    With Module.CodeModule
        For n = ProcedureEndLine(Module, ActiveProcedure) To ProcedureStartLine(Module, procName) Step -1
            s = .Lines(n, 1)
            If left(Trim(s), 6) = "'Debug" Then
                s = Replace(s, "'", "", , 1)
                .ReplaceLine n, s
            ElseIf left(Trim(s), 1) = "'" Then
            Else
            End If
        Next n
    End With
End Sub

Public Sub EnableDebugPrintInWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE EnableDebugPrintInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        EnableDebugPrintInModule Module
    Next
End Sub

Public Sub DisableStopInModule(Optional Module As VBComponent)
    '#INCLUDE InStrExact
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    Dim n As Long
    Dim s As String
    Dim keyword As String
    keyword = "Stop"
    With Module.CodeModule
        For n = .CountOfLines To 1 Step -1
            If .CountOfLines = 0 Then Exit For
            s = .Lines(n, 1)
            If InStrExact(1, s, keyword) > 0 Then
                .ReplaceLine n, "'" & s
            End If
        Next n
    End With
End Sub

Public Sub DisableStopInProcedure(Optional Module As VBComponent, Optional procName As String)
    '#INCLUDE InStrExact
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    If Module Is Nothing Then Set Module = ActiveModule
    If procName = "" Then procName = ActiveProcedure
    Dim n As Long
    Dim s As String
    Dim keyword As String
    keyword = "Stop"
    With Module.CodeModule
        For n = ProcedureEndLine(Module, ActiveProcedure) To ProcedureStartLine(Module, ActiveProcedure) Step -1
            s = .Lines(n, 1)
            If InStrExact(1, s, keyword) > 0 Then
                .ReplaceLine n, "'" & s
            End If
        Next n
    End With
End Sub

Public Sub DisableStopInWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE DisableStopInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each vbComp In TargetWorkbook.VBProject.VBComponents
        DisableStopInModule Module
    Next
End Sub

Public Sub EnableStopInModule(Optional Module As VBComponent)
    '#INCLUDE InStrExact
    '#INCLUDE ActiveModule
    If Module Is Nothing Then Set Module = ActiveModule
    Dim n As Long
    Dim s As String
    Dim keyword As String
    keyword = "Stop"
    With Module.CodeModule
        For n = .CountOfLines To 1 Step -1
            If .CountOfLines = 0 Then Exit For
            s = .Lines(n, 1)
            If InStrExact(1, s, keyword) > 0 Then
                s = Replace(s, "'", "", , 1)
                .ReplaceLine n, s
            End If
        Next n
    End With
End Sub

Public Sub EnableStopInProcedure(Optional Module As VBComponent, Optional procName As String)
    '#INCLUDE InStrExact
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    If Module Is Nothing Then Set Module = ActiveModule
    If procName = "" Then procName = ActiveProcedure
    Dim n As Long
    Dim s As String
    Dim keyword As String
    keyword = "Stop"
    With Module.CodeModule
        For n = ProcedureEndLine(Module, ActiveProcedure) To ProcedureStartLine(Module, procName) Step -1
            s = .Lines(n, 1)
            If InStrExact(1, s, keyword) > 0 Then
                s = Replace(s, "'", "", , 1)
                .ReplaceLine n, s
            End If
        Next n
    End With
End Sub

Public Sub EnableStopInWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE EnableStopInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        EnableStopInModule Module
    Next
End Sub

Sub AssignEnumValues(Optional ToThePower As Boolean = True)
    '#INCLUDE CodepaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String: Code = CodepaneSelection
    Dim arr: arr = Split(Code, vbNewLine)
    Code = ""
    Dim out As String
    Dim i As Long
    For i = 0 To UBound(arr)
        If InStr(1, arr(i), "=") > 0 Then arr(i) = Split(arr(i), "=")(0)
        arr(i) = Space(4) & Trim(arr(i))
    Next
    If ToThePower = True Then
        For i = 0 To UBound(arr)
            out = arr(i) & "= 2 ^ " & i
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        Next
    Else
        For i = 0 To UBound(arr)
            out = arr(i) & "= " & i + 1
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        Next
    End If
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Rem Sub ReplaceCodePaneSelection(TargetString As String)
Rem     Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
Rem     Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
Rem End Sub
Sub EncapsulateQuotes()
    '#INCLUDE EncapsulateCodepaneSelection
    EncapsulateCodepaneSelection Chr(34), Chr(34)
End Sub

Sub EncapsulateParenthesis()
    '#INCLUDE EncapsulateCodepaneSelection
    EncapsulateCodepaneSelection "(", ")"
End Sub

Public Sub EncapsulateCodepaneSelection(Before As String, After As String)
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & Before & Code & After & _
        PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Sub EncapsulateMultipleCommaSeparatedWithQuotes()
    '#INCLUDE EncapsulateMultipleInCodepaneSelection
    EncapsulateMultipleInCodepaneSelection Chr(34), Chr(34), ","
End Sub

Sub EncapsulateMultipleCommaSeparatedWithParenthesis()
    '#INCLUDE EncapsulateMultipleInCodepaneSelection
    EncapsulateMultipleInCodepaneSelection "(", ")", ","
End Sub

Sub EncapsulateMultipleLinesWithParenthesis()
    '#INCLUDE EncapsulateMultipleInCodepaneSelection
    EncapsulateMultipleInCodepaneSelection "(", ")", ","
End Sub

Sub EncapsulateMultipleLinesWithQuotes()
    '#INCLUDE EncapsulateMultipleInCodepaneSelection
    EncapsulateMultipleInCodepaneSelection Chr(34), Chr(34), vbNewLine
End Sub

Public Sub EncapsulateMultipleInCodepaneSelection(LeftCapsule As String, RightCapsule As String, Splitter As String)
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Dim arr
    arr = Split(Code, Splitter)
    Dim counter As Long
    For counter = LBound(arr) To UBound(arr) - IIf(Right(UBound(arr), Len(Splitter)) = Splitter, Len(Splitter), 0)
        arr(counter) = LeftCapsule & arr(counter) & RightCapsule
    Next
    Code = Join(arr, Splitter)
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & Code & _
        PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Public Sub UnFoldLine(Optional Splitter As String = "_" & vbNewLine, Optional joiner As String = " ")
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & Join(Split(Code, Splitter), joiner) & _
                                            PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Public Sub FoldLine(Optional Splitter As String = ",", Optional joiner As String = ", _" & vbNewLine)
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & Join(Split(Code, Splitter), joiner) & _
                                            PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Public Function FirstDigit(ByVal strData As String) As Integer
    Dim RE As Object
    Dim REMatches As Object
    Set RE = CreateObject("vbscript.regexp")
    RE.Pattern = "[0-9]"
    Set REMatches = RE.Execute(strData)
    FirstDigit = REMatches(0).FirstIndex + 1
End Function

Sub FlipNewline()
    '#INCLUDE FLIP
    FLIP vbNewLine
End Sub

Sub FlipEqualSign()
    '#INCLUDE FLIP
    FLIP "="
End Sub

Sub FlipComma()
    '#INCLUDE FLIP
    FLIP ","
End Sub

Public Sub FLIP(delim As String)
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) & _
                                                                                   Split(Code, delim)(1) & delim & Split(Code, delim)(0) & _
                                                                                   PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Sub FlipMultipleEqualSignOnMultipleLines()
    '#INCLUDE FlipMultiple
    FlipMultiple "=", vbNewLine
End Sub

Public Sub FlipMultiple(flipper As String, Optional Splitter)
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    '#INCLUDE ArrayRemoveEmptyElemets
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Dim arr As Variant
    arr = Split(Code, Splitter)
    arr = ArrayRemoveEmptyElemets(arr)
    Dim counter As Long
    For counter = LBound(arr) To UBound(arr) - IIf(Right(UBound(arr), Len(Splitter)) = Splitter, Len(Splitter), 0)
        arr(counter) = Split(arr(counter), flipper)(1) & flipper & Split(arr(counter), flipper)(0)
    Next
    Code = Join(arr, Splitter)
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & Code & _
        PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Sub FlipRotateCommas()
    '#INCLUDE FlipRotate
    FlipRotate ","
End Sub

Sub FlipRotateLines()
    '#INCLUDE FlipRotate
    FlipRotate vbNewLine
End Sub

Public Sub FlipRotate(delim As String)
    Rem Rotate multiple  eg. a,b,c,d -> b,c,d,a
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    '#INCLUDE RotateArray
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = Join(RotateArray(Split(Code, delim)), delim)
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) & _
                                                                                   Code & _
                                                                                   PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Sub RemLines()
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE ActiveModule
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim blockStart As Long
    blockStart = CodePaneSelectionStartLine
    Dim blockEnd As Long
    blockEnd = CodePaneSelectionEndLine
    Dim i As Long
    For i = blockStart To blockEnd
        Module.CodeModule.ReplaceLine i, "Rem " & Module.CodeModule.Lines(i, 1)
    Next
End Sub

Sub UnRemLines()
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE ActiveModule
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim blockStart As Long
    blockStart = CodePaneSelectionStartLine
    Dim blockEnd As Long
    blockEnd = CodePaneSelectionEndLine
    Dim i As Long
    For i = blockStart To blockEnd
        With Module.CodeModule
            If left(Trim(.Lines(i, 1)), 4) = "Rem " Then
                .ReplaceLine i, Replace(.Lines(i, 1), "Rem ", "", , 1)
            End If
        End With
    Next
End Sub

Sub CommentLines()
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE ActiveModule
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim blockStart As Long
    blockStart = CodePaneSelectionStartLine
    Dim blockEnd As Long
    blockEnd = CodePaneSelectionEndLine
    Dim i As Long
    For i = blockStart To blockEnd
        Module.CodeModule.ReplaceLine i, "'" & Module.CodeModule.Lines(i, 1)
    Next
End Sub

Sub UnCommentLines()
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE ActiveModule
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim blockStart As Long
    blockStart = CodePaneSelectionStartLine
    Dim blockEnd As Long
    blockEnd = CodePaneSelectionEndLine
    Dim i As Long
    For i = blockStart To blockEnd
        With Module.CodeModule
            If left(Trim(.Lines(i, 1)), 1) = "'" Then
                .ReplaceLine i, Replace(.Lines(i, 1), "'", "", , 1)
            End If
        End With
    Next
End Sub

Sub LineDuplicate()
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE ProcedureFirstLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    Dim RowNumber As Long
    RowNumber = CodePaneSelectionStartLine
    Dim activeLine As Long
    activeLine = RowNumber
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim lineString As String
    Do While Len(Trim(ActiveModule.CodeModule.Lines(RowNumber, 1))) = 0 And RowNumber - 1 > ProcedureFirstLine(Module, ActiveProcedure)
        RowNumber = RowNumber - 1
    Loop
    If Len(Trim(ActiveModule.CodeModule.Lines(RowNumber, 1))) > 0 Then
        lineString = Module.CodeModule.Lines(RowNumber, 1)
    End If
    Module.CodeModule.InsertLines activeLine, lineString
End Sub

Sub LineIncrement()
    '#INCLUDE IncreaseAllNumbersInString
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE ProcedureFirstLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    Dim RowNumber As Long
    RowNumber = CodePaneSelectionStartLine
    Dim activeLine As Long
    activeLine = RowNumber
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim lineString As String
    Do While Len(Trim(ActiveModule.CodeModule.Lines(RowNumber, 1))) = 0 And RowNumber - 1 >= ProcedureFirstLine(Module, ActiveProcedure)
        RowNumber = RowNumber - 1
    Loop
    If Len(Trim(ActiveModule.CodeModule.Lines(RowNumber, 1))) > 0 Then
        lineString = Module.CodeModule.Lines(RowNumber, 1)
    End If
    lineString = IncreaseAllNumbersInString(lineString)
    Module.CodeModule.InsertLines activeLine, lineString
End Sub

Sub CutLines()
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE ActiveModule
    '#INCLUDE CLIP
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim blockStart As Long
    blockStart = CodePaneSelectionStartLine
    Dim blockEnd As Long
    blockEnd = CodePaneSelectionEndLine
    Dim blockCountOfLines As Long
    blockCountOfLines = blockEnd - blockStart + 1
    Dim blockString As String
    blockString = Module.CodeModule.Lines(blockStart, blockCountOfLines)
    CLIP blockString
    Module.CodeModule.DeleteLines blockStart, blockCountOfLines
End Sub

Sub CopyLines()
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE ActiveModule
    '#INCLUDE CLIP
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim blockStart As Long
    blockStart = CodePaneSelectionStartLine
    Dim blockEnd As Long
    blockEnd = CodePaneSelectionEndLine
    Dim blockCountOfLines As Long
    blockCountOfLines = blockEnd - blockStart + 1
    Dim blockString As String
    blockString = Module.CodeModule.Lines(blockStart, blockCountOfLines)
    CLIP blockString
End Sub

Sub LinesMoveUp()
    '#INCLUDE LinesMove
    LinesMove moveUp:=True
End Sub

Sub LinesMoveDown()
    '#INCLUDE LinesMove
    LinesMove moveUp:=False
End Sub

Sub LinesMove(moveUp As Boolean)
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE CodePaneSelectionEndLine
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim blockStart As Long
    blockStart = CodePaneSelectionStartLine
    Dim blockEnd As Long
    blockEnd = CodePaneSelectionEndLine
    Dim blockCountOfLines As Long
    blockCountOfLines = blockEnd - blockStart + 1
    Dim blockString As String
    blockString = Module.CodeModule.Lines(blockStart, blockCountOfLines)
    Dim insertBlockAtLine As Long
    Select Case moveUp
        Case True
            insertBlockAtLine = blockStart - 1
            Select Case insertBlockAtLine
                Case 1, ProcedureStartLine(Module, ActiveProcedure)
                    Exit Sub
            End Select
        Case False
            insertBlockAtLine = blockStart + 1
            Select Case insertBlockAtLine + blockCountOfLines - 1
                Case Module.CodeModule.CountOfLines, ProcedureEndLine(Module, ActiveProcedure)
                    Exit Sub
            End Select
    End Select
    Module.CodeModule.DeleteLines blockStart, blockCountOfLines
    Module.CodeModule.InsertLines insertBlockAtLine, blockString
    Module.CodeModule.CodePane.SetSelection insertBlockAtLine, 1, insertBlockAtLine + blockCountOfLines - 1, 300
End Sub

Sub MoveProcedureUp()
    '#INCLUDE MoveProcedure
    MoveProcedure moveUp:=True
End Sub

Sub MoveProcedureDown()
    '#INCLUDE MoveProcedure
    MoveProcedure moveUp:=False
End Sub

Sub MoveProcedure(moveUp As Boolean)
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim Procedure As String
    Procedure = ActiveProcedure
    Dim blockStart As Long
    blockStart = ProcedureStartLine(Module, Procedure)
    Dim blockEnd As Long
    blockEnd = ProcedureEndLine(Module, Procedure)
    Dim blockCountOfLines As Long
    blockCountOfLines = blockEnd - blockStart + 1
    Dim blockString As String
    blockString = Module.CodeModule.Lines(blockStart, blockCountOfLines)
    Dim NextProcedure As String
    Dim insertBlockAtLine As Long
    Dim i As Long
    Dim counter As Long
    On Error Resume Next
    Select Case moveUp
        Case Is = True
            For i = blockStart - 1 To 1 Step -1
                NextProcedure = Module.CodeModule.ProcOfLine(i, vbext_pk_Proc)
                If NextProcedure <> vbNullString Then Exit For
            Next
            insertBlockAtLine = ProcedureStartLine(Module, NextProcedure)
        Case Is = False
            For i = blockEnd + 1 To Module.CodeModule.CountOfLines
                NextProcedure = Module.CodeModule.ProcOfLine(i, vbext_pk_Proc)
                If NextProcedure <> vbNullString Then counter = counter + 1
                i = ProcedureEndLine(Module, NextProcedure) + 1
                If counter = 1 Then NextProcedure = vbNullString
                If counter = 2 Then Exit For
            Next
            If counter = 1 Then Exit Sub
            insertBlockAtLine = ProcedureStartLine(Module, NextProcedure)
    End Select
    On Error GoTo 0
    If moveUp = True Then
        Module.CodeModule.DeleteLines blockStart, blockCountOfLines
        Module.CodeModule.InsertLines insertBlockAtLine, blockString
    Else
        Module.CodeModule.InsertLines insertBlockAtLine, blockString
        Module.CodeModule.DeleteLines blockStart, blockCountOfLines
    End If
End Sub

Function IncreaseAllNumbersInString(str As String)
    Dim output As String
    Dim counter As Long
    counter = Len(str)
    Dim i As Long
    For i = 1 To Len(str)
        counter = i
        If IsNumeric(Mid(str, i, 1)) Then
            Do
                output = output & Mid(str, counter, 1)
                counter = counter + 1
            Loop While IsNumeric(Mid(str, counter, 1))
            i = counter - 1
            IncreaseAllNumbersInString = IncreaseAllNumbersInString & val(output + 1)
        Else
            output = output & Mid(str, i, 1)
            IncreaseAllNumbersInString = IncreaseAllNumbersInString & output
        End If
        output = ""
    Next
End Function

Public Function GetArguments( _
       Optional Procedure As String, _
       Optional TargetWorkbook As Workbook) _
        As String
    '#INCLUDE GetProcedureDeclaration
    '#INCLUDE CodepaneSelection
    '#INCLUDE ModReplaceMulti
    '#INCLUDE dp
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    '#INCLUDE ModuleOfProcedure
    '#INCLUDE CLIP
    Dim s As String
    s = CodepaneSelection
    If Procedure = "" Then
        If Len(s) > 0 Then
            Procedure = s
        Else
            Procedure = ActiveProcedure
        End If
    End If
    Dim Module As VBComponent
    If TargetWorkbook Is Nothing Then
        Set Module = ActiveModule
    Else
        Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
    End If
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim str As Variant, element As Long, line As String
    Dim firstPart As String, secondPart As String, output As String
    str = GetProcedureDeclaration(Module, Procedure, ProcKind)
    If IsEmpty(str) Then GetArgs = "": Exit Function
    output = Procedure & "( _"
    Dim Indentation As String: Indentation = String(Len(output), " ")
    str = Right(str, Len(str) - InStr(1, str, "("))
    str = left(str, InStrRev(str, ")") - 1)
    If InStr(1, str, Chr(34) & "," & Chr(34)) > 0 Then str = Replace(str, Chr(34) & "," & Chr(34), Chr(34) & "###" & Chr(34))
    str = Split(str, ",")
    For i = LBound(str) To UBound(str)
        str(i) = Replace(str(i), Chr(34) & "###" & Chr(34), Chr(34) & "," & Chr(34))
    Next
    If UBound(str) = -1 Then Exit Function
    For element = LBound(str) To UBound(str)
        line = ModReplaceMulti(vbTextCompare, Trim(str(element)), "", "Optional ", "As ", "ByVal ", "ByRef", "ParamArray ", "_")
        firstPart = Split(line, " ")(0): secondPart = Split(line, " ")(1)
        output = output & vbNewLine & Indentation & firstPart & ":= " & "as" & secondPart & IIf(element <> UBound(str), ", _", ")")
    Next
    CLIP output
    dp output
    GetArguments = output
End Function

Public Function GetProcedureDeclaration(Module As VBComponent, _
                                        procName As String, _
                                        Optional LineSplitBehavior As LineSplits = LineSplitRemove)
    '#INCLUDE SingleSpace
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim LineNum As Long
    Dim s As String
    Dim Declaration As String
    On Error Resume Next
    LineNum = Module.CodeModule.ProcBodyLine(procName, ProcKind)
    If err.Number <> 0 Then
        Exit Function
    End If
    s = Module.CodeModule.Lines(LineNum, 1)
    Do While Right(s, 1) = "_"
        Select Case True
            Case LineSplitBehavior = LineSplitConvert
                s = left(s, Len(s) - 1) & vbNewLine
            Case LineSplitBehavior = LineSplitKeep
                s = s & vbNewLine
            Case LineSplitBehavior = LineSplitRemove
                s = left(s, Len(s) - 1) & " "
        End Select
        Declaration = Declaration & s
        LineNum = LineNum + 1
        s = Module.CodeModule.Lines(LineNum, 1)
    Loop
    Declaration = SingleSpace(Declaration & s)
    GetProcedureDeclaration = Declaration
End Function

Public Sub IndentModule(Optional vbComp As VBComponent)
    '#INCLUDE ActiveModule
    '#INCLUDE IsBlockEnd
    '#INCLUDE IsBlockStart
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    If vbComp.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim nIndent As Integer
    Dim nLine As Long
    Dim strNewLine As String
    For nLine = 1 To vbComp.CodeModule.CountOfLines
        strNewLine = vbComp.CodeModule.Lines(nLine, 1)
        strNewLine = LTrim$(strNewLine)
        If IsBlockEnd(strNewLine) Then nIndent = nIndent - 1
        If nIndent < 0 Then nIndent = 0
        If strNewLine <> "" Then vbComp.CodeModule.ReplaceLine nLine, Space$(nIndent * 4) & strNewLine
        If IsBlockStart(strNewLine) Then nIndent = nIndent + 1
    Next nLine
End Sub

Public Sub IndentProcedure(Optional TargetWorkbook As Workbook, Optional ProcedureName As String)
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureType
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    '#INCLUDE IsBlockEnd
    '#INCLUDE IsBlockStart
    '#INCLUDE ModuleOfProcedure
    '#INCLUDE WorkbookOfModule
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    Dim Module As VBComponent
    If ProcedureName = ActiveProcedure Then
        Set Module = ActiveModule
    Else
        Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
    End If
    On Error GoTo eh
    If Module.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim FirstLine As Long: FirstLine = Module.CodeModule.ProcStartLine(ProcedureName, vbext_pk_Proc)
    Dim EndLine As Long: EndLine = ProcedureEndLine(Module, ProcedureName)
    Rem = Module.CodeModule.ProcCountLines(ProcedureName, vbext_pk_Proc)
    Rem = ProcedureType(WorkbookOfModule(Module), ProcedureName)
    Dim nIndent As Integer
    Dim nLine As Long
    Dim strNewLine As String
    For nLine = FirstLine To EndLine
        strNewLine = Module.CodeModule.Lines(nLine, 1)
        strNewLine = LTrim$(strNewLine)
        If IsBlockEnd(strNewLine) Then nIndent = nIndent - 1
        If nIndent < 0 Then nIndent = 0
        If strNewLine <> "" Then Module.CodeModule.ReplaceLine nLine, Space$(nIndent * 4) & strNewLine
        If IsBlockStart(strNewLine) Then nIndent = nIndent + 1
    Next nLine
eh:
End Sub

Public Sub IndentWorkbook(Optional wb As Workbook)
    '#INCLUDE IndentModule
    '#INCLUDE dp
    '#INCLUDE ActiveCodepaneWorkbook
    If wb Is Nothing Then Set wb = ActiveCodepaneWorkbook
    dp wb.Name
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        IndentModule vbComp
    Next
End Sub

Function AddVariable(VariableName As String, Optional VariableType As String = "variant") As Boolean
    '#INCLUDE Inject
    If Len(VariableName) < 5 Then Debug.Print VariableName & " is not descriptive enough"
    Dim output As String
    VariableName = WorksheetFunction.Proper(VariableName)
    VariableName = Replace(VariableName, " ", "_")
    Select Case LCase(VariableType)
        Case "string"
            output = "Dim " & VariableName & " As String"
        Case "integer"
            output = "Dim " & VariableName & " As Integer"
        Case "variant"
            output = "Dim " & VariableName & " As Variant"
        Case "collection"
            output = "Dim " & VariableName & " As Collection"
            output = output & vbNewLine & "Set Output = New Collection"
        Case "boolean"
            output = "Dim " & VariableName & " As Boolean"
        Case Else
            AddVariable = False
            Exit Function
    End Select
    Inject output
    AddVariable = True
End Function

Public Sub Inject(str As String)
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    If Len(Code) > 0 Then Exit Sub
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & str & _
        PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    On Error Resume Next
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Public Function CodepaneSelection() As String
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    If EndLine - StartLine = 0 Then
        CodepaneSelection = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(StartLine, 1), StartColumn, EndColumn - StartColumn)
        Exit Function
    End If
    Dim str As String
    Dim i As Long
    For i = StartLine To EndLine
        If str = "" Then
            str = Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), StartColumn)
        ElseIf i < EndLine Then
            str = str & vbNewLine & Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), 1)
        Else
            str = str & vbNewLine & Mid(Application.VBE.ActiveCodePane.CodeModule.Lines(i, 1), 1, EndColumn - 1)
        End If
    Next
    CodepaneSelection = str
End Function

Public Function PartAfterCodePaneSelection(StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long)
    Dim str As String
    str = Application.VBE.ActiveCodePane.CodeModule.Lines(EndLine, 1)
    str = Mid(str, EndColumn)
    PartAfterCodePaneSelection = str
End Function

Public Function PartBeforeCodePaneSelection(StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long)
    Dim str As String
    str = Application.VBE.ActiveCodePane.CodeModule.Lines(StartLine, 1)
    str = Mid(str, 1, StartColumn - 1)
    PartBeforeCodePaneSelection = str
End Function

Sub ListProceduresInModule(Optional vbComp As VBComponent)
    '#INCLUDE ProcListArray
    '#INCLUDE ActiveModule
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    Dim procedures As Variant
    procedures = ProcListArray(vbComp)
    Dim txt As String
    txt = "'" & Join(procedures, vbNewLine & "'") & vbNewLine
    vbComp.CodeModule.InsertLines 1, txt
End Sub

Sub ListProceduresInAllModulesOfWorkbook(Optional wb As Workbook)
    '#INCLUDE ListProceduresInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If wb Is Nothing Then Set wb = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        ListProceduresInModule vbComp
    Next
End Sub

Sub MakeProceduresInModulePrivate(Optional vbComp As VBComponent)
    '#INCLUDE ActiveModule
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    Dim n As Long
    Dim s As String
    Dim lineString As String
    With vbComp.CodeModule
        If .CountOfLines = 0 Then Exit Sub
        For n = .CountOfLines To 1 Step -1
            s = .Lines(n, 1)
            If Trim(s) Like "Public Sub *" Then
                .ReplaceLine n, Strings.Replace(s, "Public Sub ", "Private Sub ", , 1)
            ElseIf Trim(s) Like "Public Function *" Then
                .ReplaceLine n, Strings.Replace(s, "Public Function ", "Private Function ", , 1)
            ElseIf Trim(s) Like "Function *" Then
                .ReplaceLine n, Strings.Replace(s, "Function ", "Private Function ", , 1)
            ElseIf Trim(s) Like "Sub *" Then
                .ReplaceLine n, Strings.Replace(s, "Sub ", "Private Sub ", , 1)
            ElseIf Trim(s) Like "Public Const *" Then
                .ReplaceLine n, Strings.Replace(s, "Public Const ", "Private Const ", , 1)
            ElseIf Trim(s) Like "Public *" Then
                .ReplaceLine n, Strings.Replace(s, "Public ", "Private ", , 1)
            End If
        Next n
    End With
End Sub

Sub MakeProceduresInWorkbookPrivate(Optional wb As Workbook)
    '#INCLUDE MakeProceduresInModulePrivate
    '#INCLUDE ActiveCodepaneWorkbook
    If wb Is Nothing Then Set wb = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        MakeProceduresInModulePrivate vbComp
    Next
End Sub

Sub MakeProceduresInModulePublic(Optional vbComp As VBComponent)
    '#INCLUDE ActiveModule
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    Dim n As Long
    Dim s As String
    Dim lineString As String
    With vbComp.CodeModule
        If .CountOfLines = 0 Then Exit Sub
        For n = .CountOfLines To 1 Step -1
            s = .Lines(n, 1)
            If Trim(s) Like "Private Sub *" Then
                .ReplaceLine n, Strings.Replace(s, "Private Sub ", "Public Sub ", , 1)
            ElseIf Trim(s) Like "Private Function *" Then
                .ReplaceLine n, Strings.Replace(s, "Private Function ", "Public Function ", , 1)
            ElseIf Trim(s) Like "Function *" Then
                .ReplaceLine n, Strings.Replace(s, "Function ", "Public Function ", , 1)
            ElseIf Trim(s) Like "Sub *" Then
                .ReplaceLine n, Strings.Replace(s, "Sub ", "Public Sub ", , 1)
            ElseIf Trim(s) Like "Private *" Then
                .ReplaceLine n, Strings.Replace(s, "Private ", "Public ", , 1)
            ElseIf Trim(s) Like "Declare *" Then
                .ReplaceLine n, Strings.Replace(s, "Declare ", "Public Declare ", , 1)
            ElseIf Trim(s) Like "Private Declare *" Then
                .ReplaceLine n, Strings.Replace(s, "Private Declare", "Public Declare ", , 1)
            ElseIf Trim(s) Like "Const *" Then
                .ReplaceLine n, Strings.Replace(s, "Const ", "Public Const ", , 1)
            ElseIf Trim(s) Like "Private Const *" Then
                .ReplaceLine n, Strings.Replace(s, "Private Const ", "Public Const ", , 1)
            End If
        Next n
    End With
End Sub

Sub MakeProceduresInWorkbookPublic(Optional TargetWorkbook As Workbook)
    '#INCLUDE MakeProceduresInModulePublic
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    For Each vbComp In TargetWorkbook.VBProject.VBComponents
        MakeProceduresInModulePublic vbComp
    Next
End Sub

Public Function ModReplaceMulti( _
       ByVal compare As VbCompareMethod, _
       ByVal str As String, _
       toStr As String, _
       ParamArray replacements() As Variant) _
        As String
    Rem ModReplaceMulti vbTextCompare, "a b c d", "X",array("a","c")
    Rem returns: "X b X d"
    '#INCLUDE compare
    Dim element As Variant
    For Each element In replacements
        str = Replace(str, element, toStr, , , compare)
    Next
    ModReplaceMulti = str
End Function

Public Sub AddLineNumbersToModule(Optional vbComp As VBComponent)
    '#INCLUDE AddLineNumbersToProcedure
    '#INCLUDE ProceduresOfModule
    '#INCLUDE ActiveModule
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    Dim element
    For Each element In ProceduresOfModule(vbComp)
        AddLineNumbersToProcedure vbComp, CStr(element)
    Next
End Sub

Public Sub RemoveLineNumbersFromModule(Optional vbComp As VBComponent)
    '#INCLUDE RemoveLineNumbersFromProcedure
    '#INCLUDE ProceduresOfModule
    '#INCLUDE ActiveModule
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    Dim element
    For Each element In ProceduresOfModule(vbComp)
        RemoveLineNumbersFromProcedure vbComp, CStr(element)
    Next
End Sub

Public Sub AddLineNumbersToProcedure( _
       Optional vbComp As VBComponent, _
       Optional ProcedureName As String)
    Rem number & ":" or number & vbtab
    '#INCLUDE IsCodepaneLineNumberAble
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    '#INCLUDE GetProcText
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    Dim txt
    Dim varr
    Dim i As Long
    Dim a As Long
    a = 1
    varr = Split(GetProcText(vbComp, ProcedureName), vbNewLine)
    For i = LBound(varr) To UBound(varr)
        If txt = "" Then
            If IsCodepaneLineNumberAble(varr(i)) Then
                txt = a & ":" & varr(i)
                a = a + 1
            Else
                txt = varr(i)
            End If
        Else
            If IsCodepaneLineNumberAble(varr(i)) And Right(Trim(varr(i - 1)), 1) <> "_" Then
                txt = txt & vbNewLine & a & ":" & varr(i)
                a = a + 1
            Else
                txt = txt & vbNewLine & varr(i)
            End If
        End If
    Next i
    StartLine = vbComp.CodeModule.ProcStartLine(ProcedureName, vbext_pk_Proc)
    NumLines = vbComp.CodeModule.ProcCountLines(ProcedureName, vbext_pk_Proc)
    vbComp.CodeModule.DeleteLines StartLine:=StartLine, count:=NumLines
    vbComp.CodeModule.InsertLines StartLine, txt
End Sub

Public Sub RemoveLineNumbersFromProcedure(Optional Module As VBComponent, Optional ProcedureName As String)
    '#INCLUDE FirstDigit
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    '#INCLUDE GetProcText
    If Module Is Nothing Then Set Module = ActiveModule
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    Dim StartLine As Long
    Dim NumLines As Long
    Dim txt
    Dim varr
    varr = Split(GetProcText(Module, ProcedureName), vbNewLine)
    Dim i As Long
    For i = LBound(varr) To UBound(varr)
        If txt = "" Then
            If Not IsNumeric(left(Trim(varr(i)), 1)) Then
                txt = varr(i)
            Else
                txt = left(varr(i), FirstDigit(varr(i)) - 1) & Right(varr(i), Len(varr(i)) - InStr(1, varr(i), ":") - 1)
            End If
        Else
            If Not IsNumeric(left(Trim(varr(i)), 1)) Then
                txt = txt & vbNewLine & varr(i)
            Else
                varr(i) = varr(i) & " "
                txt = txt & vbNewLine & left(varr(i), FirstDigit(varr(i)) - 1) & Right(varr(i), Len(varr(i)) - InStr(1, varr(i), ":") - 1)
            End If
        End If
    Next i
    StartLine = Module.CodeModule.ProcStartLine(ProcedureName, vbext_pk_Proc)
    NumLines = Module.CodeModule.ProcCountLines(ProcedureName, vbext_pk_Proc)
    Module.CodeModule.DeleteLines StartLine:=StartLine, count:=NumLines
    Module.CodeModule.InsertLines StartLine, txt
End Sub

Public Function IsCodepaneLineNumberAble(ByVal str As String) As Boolean
    Dim test As String
    test = Trim(str)
    If Len(test) = 0 Then Exit Function
    If Right(test, 1) = ":" Then Exit Function
    If IsNumeric(left(test, 1)) Then Exit Function
    If test Like "'*" Then Exit Function
    If test Like "Rem*" Then Exit Function
    If test Like "Dim*" Then Exit Function
    If test Like "Sub*" Then Exit Function
    If test Like "Public*" Then Exit Function
    If test Like "Private*" Then Exit Function
    If test Like "Function*" Then Exit Function
    If test Like "End Sub*" Then Exit Function
    If test Like "End Function*" Then Exit Function
    If test Like "Debug*" Then Exit Function
    IsCodepaneLineNumberAble = True
End Function

Public Function ProcedureInfo(Module As VBComponent, ProcedureName As String, ProcKind As VBIDE.vbext_ProcKind) As ProcInfo
    '#INCLUDE GetProcedureDeclaration
    Dim PInfo As ProcInfo
    Dim BodyLine As Long
    Dim Declaration As String
    Dim FirstLine As String
    BodyLine = Module.CodeModule.ProcStartLine(ProcedureName, ProcKind)
    If BodyLine > 0 Then
        PInfo.procName = ProcedureName
        PInfo.ProcKind = ProcKind
        PInfo.ProcBodyLine = Module.CodeModule.ProcBodyLine(ProcedureName, ProcKind)
        PInfo.ProcCountLines = Module.CodeModule.ProcCountLines(ProcedureName, ProcKind)
        PInfo.ProcStartLine = Module.CodeModule.ProcStartLine(ProcedureName, ProcKind)
        FirstLine = Module.CodeModule.Lines(PInfo.ProcBodyLine, 1)
        If StrComp(left(FirstLine, Len("Public")), "Public", vbBinaryCompare) = 0 Then
            PInfo.ProcedureScope = Public_SCOPE
        ElseIf StrComp(left(FirstLine, Len("Private")), "Private", vbBinaryCompare) = 0 Then
            PInfo.ProcedureScope = PRIVATE_SCOPE
        ElseIf StrComp(left(FirstLine, Len("Friend")), "Friend", vbBinaryCompare) = 0 Then
            PInfo.ProcedureScope = FRIEND_SCOPE
        Else
            PInfo.ProcedureScope = DEFAULT_SCOPE
        End If
        PInfo.ProcDeclaration = GetProcedureDeclaration(Module, ProcedureName, LineSplitKeep)
    End If
    ProcedureInfo = PInfo
End Function

Function ProceduresOfModule(Module As VBComponent) As Collection
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim LineNum As Long
    Dim coll As New Collection
    Dim procName As String
    With Module.CodeModule
        LineNum = .CountOfDeclarationLines + 1
        Do Until LineNum >= .CountOfLines
            procName = .ProcOfLine(LineNum, ProcKind)
            coll.Add procName
            LineNum = .ProcStartLine(procName, ProcKind) + .ProcCountLines(procName, ProcKind) + 1
        Loop
    End With
    Set ProceduresOfModule = coll
End Function

Public Sub SeparateProceduresAndFunctionsInModule(Optional vbComp As VBComponent)
    '#INCLUDE GetProcedureDeclaration
    '#INCLUDE ProcListArray
    '#INCLUDE ActiveModule
    '#INCLUDE GetProcText
    '#INCLUDE SortArray
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    If vbComp.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim StartLine As Long
    StartLine = vbComp.CodeModule.CountOfDeclarationLines
    Dim totalLines As Long
    totalLines = vbComp.CodeModule.CountOfLines - vbComp.CodeModule.CountOfDeclarationLines
    Dim TheSubs As String, TheFunctions As String, TheOther As String
    Dim sProcedureDeclaration As String
    Dim sProcedureText As String
    Dim sProcedureName As String
    Dim i As Long
    Dim varr
    varr = ProcListArray(vbComp)
    SortArray varr
    For i = LBound(varr) To UBound(varr)
        sProcedureName = CStr(varr(i))
        sProcedureDeclaration = GetProcedureDeclaration(vbComp, sProcedureName, 0)
        sProcedureText = GetProcText(vbComp, sProcedureName)
        If InStr(1, sProcedureDeclaration, "Sub " & sProcedureName) > 0 Then
            TheSubs = IIf(TheSubs = "", sProcedureText, TheSubs & vbNewLine & sProcedureText)
        ElseIf InStr(1, sProcedureDeclaration, "Function " & sProcedureName) > 0 Then
            TheFunctions = IIf(TheFunctions = "", sProcedureText, TheFunctions & vbNewLine & sProcedureText)
        End If
    Next i
    vbComp.CodeModule.DeleteLines IIf(StartLine <> 0, StartLine, StartLine + 1), totalLines
    vbComp.CodeModule.AddFromString TheFunctions & vbNewLine
    vbComp.CodeModule.AddFromString TheSubs & vbNewLine
End Sub

Public Sub SeparateProceduresAndFunctionsInWorkbook(Optional wb As Workbook)
    '#INCLUDE SeparateProceduresAndFunctionsInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If wb Is Nothing Then Set wb = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        If vbComp.Type = vbext_ct_StdModule Then SeparateProceduresAndFunctionsInModule vbComp
    Next
End Sub

Public Sub SeparatePublicAndPrivateInWorkbook(Optional wb As Workbook)
    '#INCLUDE SeparatePublicAndPrivateInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If wb Is Nothing Then Set wb = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        If vbComp.Type = vbext_ct_StdModule Then SeparatePublicAndPrivateInModule vbComp
    Next
End Sub

Public Sub SeparatePublicAndPrivateInModule(Optional vbComp As VBComponent)
    '#INCLUDE GetProcedureDeclaration
    '#INCLUDE ProcListArray
    '#INCLUDE ActiveModule
    '#INCLUDE GetProcText
    '#INCLUDE SortArray
    If vbComp Is Nothing Then Set vbComp = ActiveModule
    If vbComp.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim StartLine As Long
    StartLine = vbComp.CodeModule.CountOfDeclarationLines
    Dim totalLines As Long
    totalLines = vbComp.CodeModule.CountOfLines - vbComp.CodeModule.CountOfDeclarationLines
    Dim ThePublic As String, ThePrivate As String, TheOther As String
    Dim sProcedureDeclaration As String
    Dim sProcedureText As String
    Dim sProcedureName As String
    Dim i As Long
    Dim varr
    varr = ProcListArray(vbComp)
    SortArray varr
    For i = LBound(varr) To UBound(varr)
        sProcedureName = CStr(varr(i))
        sProcedureDeclaration = GetProcedureDeclaration(vbComp, sProcedureName, 0)
        sProcedureText = GetProcText(vbComp, sProcedureName)
        If InStr(1, sProcedureDeclaration, "Public ") > 0 Then
            ThePublic = IIf(ThePublic = "", sProcedureText, ThePublic & vbNewLine & sProcedureText)
        Else
            ThePrivate = IIf(ThePrivate = "", sProcedureText, ThePrivate & vbNewLine & sProcedureText)
        End If
    Next i
    vbComp.CodeModule.DeleteLines IIf(StartLine <> 0, StartLine, StartLine + 1), totalLines
    vbComp.CodeModule.AddFromString ThePrivate & vbNewLine
    vbComp.CodeModule.AddFromString ThePublic & vbNewLine
End Sub

Public Sub SetToNothing(Optional ProcedureName As String, Optional TargetWorkbook As Workbook)
    '#INCLUDE ProcedureFirstLine
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    '#INCLUDE ModuleOfProcedure
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    Dim Module As VBComponent
    If TargetWorkbook Is Nothing Then
        Set Module = ActiveModule
    Else
        Set Module = ModuleOfProcedure(TargetWorkbook, ProcedureName)
    End If
    Dim FirstLine As Long, LastLine As Long, LineNumber As Long
    Dim strLine As String, Append As String, Terminate As String
    FirstLine = ProcedureFirstLine(Module, ProcedureName)
    LastLine = ProcedureEndLine(Module, ProcedureName)
    For LineNumber = FirstLine To LastLine
        strLine = Trim(Module.CodeModule.Lines(LineNumber, 1))
        If strLine Like "Set * = *" Or strLine Like "Dim*As New*" Then
            Terminate = Split(strLine, " ")(1)
            Append = Append & vbNewLine & "Set " & Terminate & " = Nothing"
        End If
    Next
    If Append <> "" Then Module.CodeModule.InsertLines LastLine, Append
End Sub

Public Sub ShowProcedureInfo(Module As VBComponent, procName As String)
    '#INCLUDE ProcedureInfo
    Dim ProcKind As VBIDE.vbext_ProcKind: ProcKind = vbext_pk_Proc
    Dim PInfo As ProcInfo: PInfo = ProcedureInfo(Module, procName, ProcKind)
    Debug.Print "ProcName: " & PInfo.procName
    Debug.Print "ProcKind: " & CStr(PInfo.ProcKind)
    Debug.Print "ProcStartLine: " & CStr(PInfo.ProcStartLine)
    Debug.Print "ProcBodyLine: " & CStr(PInfo.ProcBodyLine)
    Debug.Print "ProcCountLines: " & CStr(PInfo.ProcCountLines)
    Debug.Print "ProcedureScope: " & CStr(PInfo.ProcedureScope)
    Debug.Print "ProcDeclaration: " & PInfo.ProcDeclaration
End Sub

Public Function SingleSpace(ByVal TEXT As String) As String
    Dim pos As String
    pos = InStr(1, TEXT, Space(2), vbBinaryCompare)
    Do Until pos = 0
        TEXT = Replace(TEXT, Space(2), Space(1))
        pos = InStr(1, TEXT, Space(2), vbBinaryCompare)
    Loop
    SingleSpace = TEXT
End Function

Public Sub SortArrayBetween(vArray As Variant, inLow As Long, inHi As Long)
    Dim tmpSwap As Variant
    Dim tmpLow  As Long:    tmpLow = inLow
    Dim tmpHi   As Long:      tmpHi = inHi
    Dim pivot   As Variant:    pivot = vArray((inLow + inHi) \ 2)
    While (tmpLow <= tmpHi)
        While (vArray(tmpLow) < pivot And tmpLow < inHi)
            tmpLow = tmpLow + 1
        Wend
        While (pivot < vArray(tmpHi) And tmpHi > inLow)
            tmpHi = tmpHi - 1
        Wend
        If (tmpLow <= tmpHi) Then
            tmpSwap = vArray(tmpLow)
            vArray(tmpLow) = vArray(tmpHi)
            vArray(tmpHi) = tmpSwap
            tmpLow = tmpLow + 1
            tmpHi = tmpHi - 1
        End If
    Wend
    If (inLow < tmpHi) Then SortArrayBetween vArray, inLow, tmpHi
    If (tmpLow < inHi) Then SortArrayBetween vArray, tmpLow, inHi
End Sub

Public Sub SortProceduresInModule(Optional Module As VBComponent)
    '#INCLUDE ProcListArray
    '#INCLUDE ActiveModule
    '#INCLUDE GetProcText
    '#INCLUDE SortArray
    If Module Is Nothing Then Set Module = ActiveModule
    If Module.CodeModule.CountOfLines = 0 Then Exit Sub
    Dim varr: varr = ProcListArray(Module)
    Dim StartLine As Long: StartLine = Module.CodeModule.ProcStartLine(varr(0), vbext_pk_Proc)
    Dim totalLines As Long: totalLines = Module.CodeModule.CountOfLines - Module.CodeModule.CountOfDeclarationLines
    varr = SortArray(varr)
    Dim ReplacedProcedures As String
    Dim i As Long
    For i = LBound(varr) To UBound(varr)
        If ReplacedProcedures = "" Then
            ReplacedProcedures = GetProcText(Module, CStr(varr(i)))
        Else
            ReplacedProcedures = ReplacedProcedures & vbNewLine & _
                                 GetProcText(Module, CStr(varr(i)))
        End If
    Next i
    Module.CodeModule.DeleteLines StartLine, totalLines
    Module.CodeModule.AddFromString ReplacedProcedures
End Sub

Public Sub SortProceduresWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE SortProceduresInModule
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        SortProceduresInModule Module
    Next
End Sub

Sub SortOnComma()
    '#INCLUDE SortSelection
    SortSelection ","
End Sub

Sub SortOnNewline()
    '#INCLUDE SortSelection
    SortSelection vbNewLine
End Sub

Public Sub SortSelection(delimeter As String)
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    '#INCLUDE SortSelectionArray
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Dim arr
    arr = Split(Code, delimeter)
    SortSelectionArray arr
    Code = Join(arr, delimeter)
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & Code & _
        PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Public Sub SortSelectionArray(ByRef tempArray As Variant)
    Dim MaxVal As Variant
    Dim MaxIndex As Integer
    Dim i As Integer, j As Integer
    For i = UBound(tempArray) To 0 Step -1
        MaxVal = tempArray(i)
        MaxIndex = i
        For j = 0 To i
            If tempArray(j) > MaxVal Then
                MaxVal = tempArray(j)
                MaxIndex = j
            End If
        Next j
        If MaxIndex < i Then
            tempArray(MaxIndex) = tempArray(i)
            tempArray(i) = MaxVal
        End If
    Next i
End Sub

Public Sub CodePaneSelectionSubstitute(OldValue As String, NewValue As String)
    '#INCLUDE CodepaneSelection
    '#INCLUDE PartAfterCodePaneSelection
    '#INCLUDE PartBeforeCodePaneSelection
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    Dim Code As String
    Code = CodepaneSelection
    Code = PartBeforeCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn) _
      & Replace(Code, OldValue, NewValue, , , vbTextCompare) & _
                                                             PartAfterCodePaneSelection(StartLine, StartColumn, EndLine, EndColumn)
    Application.VBE.ActiveCodePane.CodeModule.DeleteLines StartLine, EndLine - StartLine + 1
    Application.VBE.ActiveCodePane.CodeModule.InsertLines StartLine, Code
End Sub

Public Function CodePaneSelectionStartLine() As Long
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    CodePaneSelectionStartLine = StartLine
End Function

Public Function CodePaneSelectionStartColumn() As Long
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    CodePaneSelectionStartColumn = StartColumn
End Function

Public Function CodePaneSelectionEndLine() As Long
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    CodePaneSelectionEndLine = EndLine
End Function

Public Function CodePaneSelectionEndColumn() As Long
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    CodePaneSelectionEndColumn = EndColumn
End Function

Public Function CodepaneSelectionRowsCount() As Long
    Dim StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long
    Application.VBE.ActiveCodePane.GetSelection StartLine, StartColumn, EndLine, EndColumn
    CodepaneSelectionRowsCount = EndLine - StartLine + 1
End Function

Sub CodePaneSelectionSet(StartLine As Long, StartColumn As Long, EndLine As Long, EndColumn As Long)
    Application.VBE.ActiveCodePane.SetSelection StartLine, StartColumn, EndLine, EndColumn
End Sub

Rem @Folder FormatVBATools
Sub sysAddHeader()
    '#INCLUDE GetProcedureDeclaration
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE GetCurrentProcInfo
    '#INCLUDE AddStringParameterFromProcedureDeclaration
    '#INCLUDE TypeProcedureComment
    '#INCLUDE ActiveModule
    Dim txtName As String
    txtName = AUTHOR_NAME
    If txtName = vbNullString Then txtName = Environ("UserName")
    Dim txtContacts As String
    txtContacts = AUTHOR_EMAIL
    If txtContacts <> vbNullString Then txtContacts = "'* Contacts   :" & vbTab & txtContacts & vbCrLf
    Dim txtCopyright As String
    txtCopyright = AUTHOR_COPYRIGHT
    If txtCopyright <> vbNullString Then txtCopyright = "'* Copyright  :" & vbTab & txtCopyright & vbCrLf
    Dim txtOther As String
    txtOther = AUTHOR_OTHERTEXT
    If txtOther <> vbNullString Then txtOther = "'* Other      :" & vbTab & txtOther & vbCrLf
    Dim txtMedia As String
    txtMedia = "'* " & vbLf & AUTHOR_MEDIA
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim CurentCodePane As CodePane
    Set CurentCodePane = Module.CodeModule.CodePane
    Dim nLine  As Long
    Dim i      As Byte
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim sProc  As String
    Dim sTemp  As String
    Dim sTime  As String
    Dim sType  As String
    Dim sProcDeclartion As String
    Dim sProcArguments As String
    On Error Resume Next
    With CurentCodePane
        GetCurrentProcInfo nLine, sProc, CurentCodePane
        sTemp = Replace(String(90, "*"), "**", "* ")
        sTime = Format(Now, ctFormat)
        If sProc = "" Or CodePaneSelectionStartLine = 1 Then
            sType = "* Module     :"
            sProc = .CodeModule.Name
            nLine = 1
        Else
            txtMedia = ""
            For i = 0 To 4
                ProcKind = i
                sProcDeclartion = GetProcedureDeclaration(Module, sProc, ProcKind)
                If sProcDeclartion <> vbNullString Then Exit For
            Next
            sProcArguments = AddStringParameterFromProcedureDeclaration(sProcDeclartion)
            sType = TypeProcedureComment(sProcDeclartion)
        End If
        sTemp = vbLf & "'" & sTemp & vbCrLf & _
                "'" & sType & vbTab & sProc & vbCrLf & _
                "'* Created    :" & vbTab & sTime & vbTab & vbCrLf & _
                "'* Author     :" & vbTab & txtName & vbCrLf & _
                txtContacts & _
                txtCopyright & _
                txtOther & _
                txtMedia & _
                sProcArguments & _
                "'" & sTemp
        .CodeModule.InsertLines nLine, sTemp & vbNewLine
    End With
End Sub

Sub sysAddModified()
    Rem Author VBATools
    '#INCLUDE GetCurrentProcInfo
    '#INCLUDE ActiveModule
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim CurentCodePane As CodePane
    Set CurentCodePane = Module.CodeModule.CodePane
    Dim nLine  As Long
    Dim sProc  As String
    Dim sTime  As String
    Dim sSecondLine As String
    Dim sUser As String
    Const sUPDATE As String = "'* Updated    :"
    Const sFersLine As String = "'* Modified   :" & vbTab & "Date and Time" & vbTab2 & "Author" & vbTab4 & "Description" & vbCrLf
    On Error Resume Next
    With CurentCodePane
        GetCurrentProcInfo nLine, sProc, CurentCodePane
        sTime = Format(Now, ctFormat)
        sUser = "Alex"
        If sUser = vbNullString Then sUser = Environ("UserName")
        sSecondLine = sUPDATE & vbTab & sTime & vbTab & sUser & vbTab2
        If Not .CodeModule.Lines(nLine - 2, 1) Like sUPDATE & "*" Then
            sSecondLine = sFersLine & sSecondLine
        End If
        .CodeModule.InsertLines nLine - 1, sSecondLine
    End With
End Sub

Private Sub GetCurrentProcInfo(ByRef nLine As Long, ByRef sProc As String, ByRef CurentCodePane As CodePane)
    Dim t      As Long
    With CurentCodePane
        .GetSelection nLine, t, t, t
        sProc = .CodeModule.ProcOfLine(nLine, vbext_pk_Proc)
        If sProc = "" Then
            Do While .CodeModule.Find("'*", nLine, 1, .CodeModule.CountOfDeclarationLines, 2)
                nLine = nLine + 1
                If nLine > .CodeModule.CountOfDeclarationLines Then Exit Do
            Loop
        Else
            nLine = .CodeModule.ProcBodyLine(sProc, vbext_pk_Proc)
        End If
    End With
End Sub

Private Function AddStringParameterFromProcedureDeclaration(ByVal sPocDeclartion As String) As String
    Dim sDeclaration As String
    sDeclaration = Right$(sPocDeclartion, Len(sPocDeclartion) - InStr(1, sPocDeclartion, "("))
    sDeclaration = left$(sDeclaration, InStr(1, sDeclaration, ")") - 1)
    If sDeclaration = vbNullString Then Exit Function
    Dim arStr() As String
    Dim sTemp  As String
    Dim i      As Byte
    Dim iMaxLen As Byte
    Dim iTempLen As Byte
    arStr = Split(sDeclaration, ",")
    iMaxLen = 0
    For i = 0 To UBound(arStr)
        iTempLen = Len(Trim$(arStr(i)))
        If iMaxLen < iTempLen Then iMaxLen = iTempLen
    Next i
    sDeclaration = "'*" & vbLf & "'* Argument(s):" & String$(iMaxLen - Len(Trim$("'* Argument(s):")), " ") & vbTab2 & "Description" & vbCrLf & "'*" & vbCrLf
    For i = 0 To UBound(arStr)
        sTemp = "'* " & Trim$(arStr(i)) & String$(iMaxLen - Len(Trim$(arStr(i))), " ") & " :"
        sDeclaration = sDeclaration & sTemp & vbCrLf
    Next i
    AddStringParameterFromProcedureDeclaration = sDeclaration & "'* " & vbCrLf
End Function

Private Function TypeProcedureComment(ByRef StrDeclarationProcedure As String) As String
    If StrDeclarationProcedure Like "*Sub*" Then
        TypeProcedureComment = "* Sub        :"
    ElseIf StrDeclarationProcedure Like "*Function*" Then
        TypeProcedureComment = "* Function   :"
    ElseIf StrDeclarationProcedure Like "*Property Set*" Then
        TypeProcedureComment = "* Prop Set   :"
    ElseIf StrDeclarationProcedure Like "*Property Get*" Then
        TypeProcedureComment = "* Prop Get   :"
    ElseIf StrDeclarationProcedure Like "*Property Let*" Then
        TypeProcedureComment = "* Prop Let   :"
    Else
        TypeProcedureComment = "* Un Type    :"
    End If
End Function



'uCodeFinder	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uCodeFinder
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Dim CalledFromModule As VBComponent
Dim CalledFromProcedure As String

Private Sub CommandButton2_Click()
    ReturnToCaller
End Sub

Private Sub UserForm_Initialize()
    '#INCLUDE ImageListLoadProjectIcons
    MakeUserFormChildOfVBEditor uCodeFinder.Caption

    With TreeView1
        .Sorted = True
        .Appearance = ccFlat
        .LineStyle = tvwRootLines
        .Style = tvwTreelinesPlusMinusPictureText
        .Font.Size = 10
        .Indentation = 2
    End With

    ImageListLoadProjectIcons ImageList1, TreeView1
    
    Set CalledFromModule = ActiveModule
    CalledFromProcedure = ActiveProcedure
    
End Sub

Sub ReturnToCaller()
    On Error GoTo HELL
    GoToModule CalledFromModule
    Dim i As Long
    For i = 1 To Module.CodeModule.CountOfLines
        If InStr(1, Module.CodeModule.Lines(i, 1), "Sub " & CalledFromProcedure) > 0 Or _
                                                                                 InStr(1, Module.CodeModule.Lines(i, 1), "Function " & CalledFromProcedure) > 0 Then
            Module.CodeModule.CodePane.SetSelection i, 1, i, 1
            Exit Sub
        End If
    Next
HELL:
End Sub

Private Sub CommandButton1_Click()
    '#INCLUDE TreeviewClear
    '#INCLUDE FindCodeEverywhere
    '#INCLUDE TreeviewAssignProjectImages
    '#INCLUDE TreeviewExpandAllNodes
    Dim tvtop As Long, tvleft As Long
    
    'TreeView1.Visible = False
    TreeviewClear TreeView1
    FindCodeEverywhere TextBox1, TreeView1
    TreeviewAssignProjectImages TreeView1
    TreeviewExpandAllNodes TreeView1

    'TreeView1.Visible = True
    TreeView1.Nodes(1).Expanded = True
End Sub

Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = 13 Then
        CommandButton1_Click
    End If
End Sub

Private Sub TreeView1_DblClick()
    '#INCLUDE TreeviewGotoProjectElement
    TreeviewGotoProjectElement TreeView1
End Sub



'uReferences	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uReferences
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Option Explicit

Private Sub cADD_Click()
    If ListBox1.ListIndex = -1 Then
        MsgBox "Select target workbook first"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(ListBox1.list(ListBox1.ListIndex))
    On Error Resume Next
    TargetWorkbook.VBProject.REFERENCES.AddFromGuid LReferences.list(LReferences.ListIndex, 1), 0, 0
       
    Call PopulateLRefActive

End Sub

Private Sub cClearFilter_Click()
    '    LReferences.Clear
    '    Call PopulateLReferences
    tFilterReferences.TEXT = ""
End Sub

Private Sub cRemove_Click()
    If ListBox1.ListIndex = -1 Then
        MsgBox "Select target workbook first"
        Exit Sub
    End If
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(ListBox1.list(ListBox1.ListIndex))
    On Error Resume Next
    
    RemoveReferenceByGUID TargetWorkbook, LRefActive.list(LReferences.ListIndex, 2)
       
    PopulateLRefActive
End Sub

Private Sub ListBox1_Change()
    Call PopulateLRefActive
End Sub

Private Sub tFilterReferences_Change()
    'Reload list so if you type and delete you'll get the items back
    LReferences.clear
    Call PopulateLReferences
    
    Dim i               As Long
    Dim n               As Long
    Dim str             As String
    Dim sTemp           As String
   
    'Equals is always case sensitive
    'Remove LCase if you want it to be case sensitive
    str = LCase(tFilterReferences.TEXT)
   
    n = LReferences.ListCount
   
    For i = n - 1 To 0 Step -1        'Work backwards when deleting items
        'Equals is always case sensitive
        'Remove LCase if you want it to be case sensitive
        sTemp = LCase(LReferences.list(i, 0))
       
        If InStr(sTemp, str) = 0 Then
            LReferences.RemoveItem (i)
            'Exit Sub   'Uncomment to Exit if value found
        End If
    Next i
End Sub

Private Sub UserForm_Activate()
    '    MakeUserFormChildOfVBEditor Me.Caption
End Sub

Private Sub UserForm_Initialize()
    Call PopulateLReferences
    
    Dim X, Y As Variant
    On Error Resume Next
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not ProtectedVBProject(Workbooks(Y.Name)) Then
                If err.Number = 0 Then
                    ListBox1.AddItem Y.Name
                End If
            End If
            err.clear
        Next
    Next

End Sub

Function PopulateLRefActive()
    '#INCLUDE SortListboxOnColumn
    '#INCLUDE DP
    Dim FromWorkbook As Workbook
    Set FromWorkbook = Workbooks(ListBox1.list(ListBox1.ListIndex))
    Dim i As Long
    i = 0
    LRefActive.clear
    Dim myRef As Reference
    For Each myRef In FromWorkbook.VBProject.REFERENCES
        uReferences.LRefActive.AddItem
        uReferences.LRefActive.list(i, 0) = myRef.IsBroken
        uReferences.LRefActive.list(i, 1) = IIf(myRef.Description <> "", myRef.Description, myRef.Name)
        uReferences.LRefActive.list(i, 2) = myRef.GUID
        dp myRef.Name
        i = i + 1
    Next myRef

    Call SortListboxOnColumn(uReferences.LRefActive, 1)
End Function

Sub PopulateLReferences()
    Dim i As Long
    i = 0
    Dim rng As Range
    Set rng = ThisWorkbook.SHEETS("REFERENCES").Range("A1").CurrentRegion
    Set rng = rng.OFFSET(1).RESIZE(rng.rows.count - 1)
    Dim cell As Range
    For Each cell In rng.Columns(1).Cells
        uReferences.LReferences.AddItem
        uReferences.LReferences.list(i, 0) = cell.TEXT
        uReferences.LReferences.list(i, 1) = cell.OFFSET(0, 1).TEXT
        uReferences.LReferences.list(i, 2) = cell.OFFSET(0, 2).TEXT
        uReferences.LReferences.list(i, 3) = cell.OFFSET(0, 3).TEXT
        i = i + 1
    Next cell
    
End Sub


'M_Bookmarks	1

Rem @Folder Bookmarks
Sub BookmarkSave(Optional index As Long = 0)
    '#INCLUDE CommandBarBuilder
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE UpdateBookmarkLabel
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    '#INCLUDE CreateOrSetSheet
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("VbeBookmarks", ThisWorkbook)
    Dim cell As Range
    If index = 0 Then
        Set cell = ws.Range("A9999").End(xlUp)
        If cell <> "" Then Set cell = cell.OFFSET(1, 0)
        index = cell.row
    Else
        Set cell = ws.Cells(index, 1)
    End If
    Dim delim As String
    delim = " | "
    Dim Procedure As String
    On Error Resume Next
    Procedure = ActiveProcedure
    On Error GoTo 0
    If Procedure = "" Then Procedure = "N/A"
    Dim Module As VBComponent
    Set Module = ActiveModule
    Dim BookmarkLine As String
    BookmarkLine = ActiveCodepaneWorkbook.Name & delim & _
                   Module.Name & delim & _
                   Procedure & delim & _
                   Module.CodeModule.Lines(CodePaneSelectionStartLine, 1)
    cell = cell.row
    cell.OFFSET(0, 1) = BookmarkLine
    If index < 11 Then
        UpdateBookmarkLabel index, IIf(Procedure <> "N/A", Procedure, Module.Name)
        CommandBarBuilder ThisWorkbook.SHEETS("BAR_Bookmarks")
    End If
End Sub

Sub UpdateBookmarkLabel(index As Long, newLabel As String)
    Application.EnableEvents = False
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("BAR_Bookmarks")
    Dim cell As Range
    Set cell = ws.Columns(3).SpecialCells(xlCellTypeConstants).Find("bmSave" & index, LookAt:=xlWhole)
    cell.OFFSET(0, -1).Value = newLabel
    Set cell = ws.Columns(3).SpecialCells(xlCellTypeConstants).Find("bmLoad" & index, LookAt:=xlWhole)
    cell.OFFSET(0, -1).Value = newLabel
    Application.EnableEvents = True
End Sub

Sub ResetBookmarkLabels()
    '#INCLUDE CommandBarBuilder
    '#INCLUDE UpdateBookmarkLabel
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("BAR_Bookmarks")
    Dim cell As Range
    Dim index As Long
    For index = 1 To 10
        UpdateBookmarkLabel index, CStr(index)
    Next
    CommandBarBuilder ws
End Sub

Sub bmSave1()
    '#INCLUDE BookmarkSave
    BookmarkSave 1
End Sub

Sub bmSave2()
    '#INCLUDE BookmarkSave
    BookmarkSave 2
End Sub

Sub bmSave3()
    '#INCLUDE BookmarkSave
    BookmarkSave 3
End Sub

Sub bmSave4()
    '#INCLUDE BookmarkSave
    BookmarkSave 4
End Sub

Sub bmSave5()
    '#INCLUDE BookmarkSave
    BookmarkSave 5
End Sub

Sub bmSave6()
    '#INCLUDE BookmarkSave
    BookmarkSave 6
End Sub

Sub bmSave7()
    '#INCLUDE BookmarkSave
    BookmarkSave 7
End Sub

Sub bmSave8()
    '#INCLUDE BookmarkSave
    BookmarkSave 8
End Sub

Sub bmSave9()
    '#INCLUDE BookmarkSave
    BookmarkSave 9
End Sub

Sub bmSave10()
    '#INCLUDE BookmarkSave
    BookmarkSave 10
End Sub

Sub BookmarkList()
    '#INCLUDE dp
    '#INCLUDE CreateOrSetSheet
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("VbeBookmarks", ThisWorkbook)
    If ws.Cells(1, 1) = "" Then
        MsgBox "No bookmarks found"
        Exit Sub
    End If
    Dim cell As Range, rng As Range
    For Each cell In ws.Columns(1).SpecialCells(xlCellTypeConstants)
        If rng Is Nothing Then
            Set rng = Union(cell, cell.OFFSET(0, 1))
        Else
            Set rng = Union(rng, Union(cell, cell.OFFSET(0, 1)))
        End If
    Next
    dp rng
End Sub

Sub BookmarkLoad(Optional index As Long = 0, Optional movingForward As Boolean)
    '#INCLUDE GoToModule
    '#INCLUDE ProcedureExists
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ProcedureStartLine
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE GetProcText
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("VbeBookmarks")
    Dim lr As Long
    lr = ws.Cells(9999, 1).End(xlUp).row
    Dim cell As Range
retry:
    If index = 0 Then
        Set cell = ws.Cells(lr, 1)
        index = cell.row
    Else
        Set cell = ws.Cells(index, 1)
    End If
    If cell = "" Then Exit Sub
    Dim delim As String
    delim = " | "
    Dim var
    var = Split(cell.OFFSET(0, 1), delim)
    Dim targetworkbookname As String
    targetworkbookname = var(0)
    Dim ModuleName As String
    ModuleName = var(1)
    Dim Procedure As String
    Procedure = var(2)
    Dim BookmarkLine As String
    BookmarkLine = var(3)
    If targetworkbookname <> ActiveCodepaneWorkbook.Name Then
        index = index + IIf(movingForward = True, 1, -1)
        GoTo retry
    End If
    Dim wb As Workbook
    Dim Module As VBComponent
    On Error Resume Next
    Set wb = Workbooks(targetworkbookname)
    Set Module = wb.VBProject.VBComponents(ModuleName)
    If Module Is Nothing Then Set Module = Workbooks(targetworkbookname).VBProject.VBComponents(ModuleName)
    On Error GoTo 0
    If wb Is Nothing Then
        index = index + IIf(movingForward = True, 1, -1)
        GoTo retry
    End If
    ws.Range("O1").Value = index
    If Module Is Nothing Then Exit Sub
    GoToModule Module
    If Procedure = "N/A" Then
    ElseIf ProcedureExists(Procedure, wb) Then
        ProcFirstline = ProcedureStartLine(Module, Procedure)
        Module.CodeModule.CodePane.SetSelection ProcFirstline, 1, ProcFirstline, 1
        If BookmarkLine <> "" Then
            If InStr(1, GetProcText(Module, Procedure), BookmarkLine) > 0 Then
                Dim i As Long
                For i = ProcedureStartLine(Module, Procedure) To ProcedureEndLine(Module, Procedure)
                    If InStr(1, Module.CodeModule.Lines(i, 1), BookmarkLine, vbTextCompare) > 0 Then
                        Module.CodeModule.CodePane.SetSelection i, 1, i, 1
                        Exit Sub
                    End If
                Next
            End If
        End If
    Else
        Debug.Print "Procedure " & Procedure & " not found in workbook " & targetworkbookname
    End If
End Sub

Rem @TODO unidentified error
Rem         causes the subs to run multiple times
Rem         when calling from vbe button but not
Rem         when calling from immediate window
Rem     Dim ws As Worksheet
Rem     Set ws = ThisWorkbook.Sheets("VbeBookmarks")
Rem
Rem     Dim LastBookmark As Range
Rem     Set LastBookmark = ws.Range("O1")
Rem         LastBookmark.Value = LastBookmark.Value + 1
Rem
Rem     Dim index As Long
Rem         index = LastBookmark.Value
Rem
Rem     Dim lr As Long
Rem         lr = ws.Cells(9999, 1).End(xlUp).row
Rem
Rem     If index > lr Then
Rem         LastBookmark.Value = 1
Rem         index = 1
Rem     End If
Rem
Rem     Dim LoadThisBookmark As Range
Rem     Set LoadThisBookmark = ws.Cells(index, 1)
Rem
Rem     Do While LoadThisBookmark.TEXT = vbNullString
Rem         index = index + 1
Rem         LastBookmark.Value = index
Rem         If index > lr Then
Rem             LastBookmark.Value = vbNullString
Rem             Exit Sub
Rem         End If
Rem         Set LoadThisBookmark = ws.Cells(index, 1)
Rem     Loop
Rem     BookmarkLoad index
Rem End Sub
Rem
Rem Sub BookMarkPrevious()
Rem     Dim ws As Worksheet
Rem     Set ws = ThisWorkbook.Sheets("VbeBookmarks")
Rem
Rem     Dim LastBookmark As Range
Rem     Set LastBookmark = ws.Range("O1")
Rem         LastBookmark.Value = LastBookmark.Value - 1
Rem
Rem     Dim index As Long
Rem         index = LastBookmark.Value
Rem
Rem     Dim lr As Long
Rem         lr = ws.Cells(9999, 1).End(xlUp).row
Rem
Rem     If index < 1 Then
Rem         LastBookmark.Value = lr
Rem         index = lr
Rem     End If
Rem
Rem     Dim LoadThisBookmark As Range
Rem     Set LoadThisBookmark = ws.Cells(index, 1)
Rem
Rem     Do While LoadThisBookmark.TEXT = vbNullString
Rem         index = index - 1
Rem         LastBookmark.Value = index
Rem         If index < 1 Then
Rem             LastBookmark.Value = vbNullString
Rem             Exit Sub
Rem         End If
Rem         Set LoadThisBookmark = ws.Cells(index, 1)
Rem     Loop
Rem     BookmarkLoad index, False
Rem End Sub
Sub bmload1()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 1
End Sub

Sub bmload2()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 2
End Sub

Sub bmload3()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 3
End Sub

Sub bmload4()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 4
End Sub

Sub bmload5()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 5
End Sub

Sub bmload6()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 6
End Sub

Sub bmload7()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 7
End Sub

Sub bmload8()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 8
End Sub

Sub bmload9()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 9
End Sub

Sub bmload10()
    '#INCLUDE BookmarkLoad
    BookmarkLoad 10
End Sub

Sub BookmarkDelete(Optional index As Long)
    '#INCLUDE CommandBarBuilder
    '#INCLUDE UpdateBookmarkLabel
    '#INCLUDE CreateOrSetSheet
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("VbeBookmarks", ThisWorkbook)
    Dim cell As Range
    If index = 0 Then
        Set cell = ws.Cells(9999, 1).End(xlUp)
        cell.RESIZE(1, 2).clear
    Else
        ws.Cells(index, 1).RESIZE(1, 2).clear
    End If
    If index > 0 And index <= 10 Then UpdateBookmarkLabel index, CStr(index)
    CommandBarBuilder ws
End Sub

Sub BookmarkReset()
    '#INCLUDE ResetBookmarkLabels
    '#INCLUDE CreateOrSetSheet
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("VbeBookmarks", ThisWorkbook)
    ws.Cells.clear
    ResetBookmarkLabels
End Sub



'M_VbaLinkedProcedures	1

Rem @Folder STACK
Function getWhichProceduresCallTargetProcedure(TargetWorkbook As Workbook, Optional ProcedureName As String)
    Rem @TODO
    Rem This may be faster than the previous method i used in Stack
    '#INCLUDE ProceduresOfModule
    '#INCLUDE InStrExact
    '#INCLUDE ActiveProcedure
    '#INCLUDE GetProcText
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    Dim Module As VBIDE.VBComponent
    Dim Procedure As Variant
    Dim i As Long
    Dim output As String
    Dim matchCollection As New Collection
    Dim ProcedureText As String
    For Each Module In TargetWorkbook.VBProject.VBComponents
        For Each Procedure In ProceduresOfModule(Module)
            ProcedureText = GetProcText(Module, Procedure)
            If InStr(1, ProcedureText, ProcedureName, vbTextCompare) Then
                If InStrExact(1, ProcedureText, ProcedureName, False) > 0 Then
                    output = IIf(output = "", Procedure, output & vbNewLine & Procedure)
                End If
            End If
        Next
    Next
    getWhichProceduresCallTargetProcedure = output
End Function

Sub ListAllProcedureImportsInWorkbook(Optional TargetWorkbook As Workbook)
    Rem CommentsRemoveWorkbook thisworkbook
    '#INCLUDE AddListOfLinkedProceduresToProcedure
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim procedures As Collection: Set procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Procedure
    For Each Procedure In procedures
        AddListOfLinkedProceduresToProcedure CStr(Procedure), procedures, TargetWorkbook
    Next
End Sub

Sub ListAllProcedureImportsInModule(Optional Module As VBComponent)
    '#INCLUDE ProceduresOfModule
    '#INCLUDE AddListOfLinkedProceduresToProcedure
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ActiveModule
    '#INCLUDE WorkbookOfModule
    If Module Is Nothing Then Set Module = ActiveModule
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = WorkbookOfModule(Module)
    Dim procedures As Collection: Set procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Procedure
    For Each Procedure In ProceduresOfModule(Module)
        AddListOfLinkedProceduresToProcedure CStr(Procedure), procedures, TargetWorkbook
    Next
End Sub

Sub ExportAllProcedures(Optional TargetWorkbook As Workbook)
    Rem CommentsRemoveWorkbook thisworkbook
    '#INCLUDE ExportProcedure
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim procedures As Collection: Set procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Procedure
    For Each Procedure In procedures
        ExportProcedure CStr(Procedure), TargetWorkbook
    Next
End Sub

Sub ExportProcedure( _
    Optional ProcedureName As String, _
    Optional FromWorkbook As Workbook)
    Rem @star
    '#INCLUDE CodepaneSelection
    '#INCLUDE AddListOfLinkedProceduresToProcedure
    '#INCLUDE ExportTargetProcedure
    '#INCLUDE LinkedProcs
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ProcedureExists
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveProcedure
    '#INCLUDE ListContainedProceduresInTXT
    '#INCLUDE FollowLink
    '#INCLUDE TxtOverwrite
    '#INCLUDE TxtRead
    '#INCLUDE CollectionContains
    If ProcedureName = "" Then
        If Len(CodepaneSelection) = 0 Then
            ProcedureName = ActiveProcedure
        Else
            ProcedureName = CodepaneSelection
        End If
    End If
    If FromWorkbook Is Nothing Then Set FromWorkbook = ActiveCodepaneWorkbook
    If ProcedureExists(ProcedureName, FromWorkbook) = False Then
        MsgBox ProcedureName & " not found in workbook " & FromWorkbook.Name
        Exit Sub
    End If
    AddListOfLinkedProceduresToProcedure CStr(ProcedureName), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
    Dim ExportedProcedures As New Collection
    Dim Proccessed As New Collection
    On Error Resume Next
    ExportTargetProcedure ProcedureName
    ExportedProcedures.Add CStr(ProcedureName), CStr(ProcedureName)
    For Each Procedure In LinkedProcs(ProcedureName, FromWorkbook)
        AddListOfLinkedProceduresToProcedure CStr(Procedure), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
        ExportTargetProcedure CStr(Procedure), FromWorkbook
        ExportedProcedures.Add CStr(Procedure), CStr(Procedure)
    Next
    Dim ProceduresCount As Long
    ProceduresCount = ExportedProcedures.count
retry:
    For Each Procedure In ExportedProcedures
        For Each element In LinkedProcs(Procedure, FromWorkbook)
            If Not CollectionContains(ExportedProcedures, , element) Then
                AddListOfLinkedProceduresToProcedure CStr(element), ProceduresOfWorkbook(FromWorkbook), FromWorkbook
                ExportedProcedures.Add CStr(element), CStr(element)
            End If
        Next
    Next
    If ExportedProcedures.count > ProceduresCount Then
        ProceduresCount = ExportedProcedures.count
        GoTo retry
    End If
    On Error GoTo 0
    If ExportedProcedures.count > 1 Then
        Dim MergedName As String
        Dim procFile As String
        MergedName = "Merged_" & ProcedureName
        Dim MergedString As String
        For Each Procedure In ExportedProcedures
            procFile = SNIP_FOLDER & CStr(Procedure) & ".txt"
            MergedString = IIf(MergedString = "", TxtRead(procFile), MergedString & vbNewLine & TxtRead(procFile))
        Next
        TxtOverwrite SNIP_FOLDER & MergedName & ".txt", MergedString
        ListContainedProceduresInTXT SNIP_FOLDER & MergedName & ".txt"
    End If
    FollowLink SNIP_FOLDER
End Sub

Sub AddListOfLinkedProceduresToProcedure(Optional ProcedureName As String, Optional procedures As Collection, Optional FromWorkbook As Workbook)
    '#INCLUDE RegexTest
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ProcedureFirstLine
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveProcedure
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    If FromWorkbook Is Nothing Then Set FromWorkbook = ActiveCodepaneWorkbook
    If procedures Is Nothing Then Set procedures = ProceduresOfWorkbook(FromWorkbook)
    Dim ListOfImports As String
    Dim Module As VBComponent:  Set Module = ModuleOfProcedure(FromWorkbook, ProcedureName)
    Dim ProcedureText As String:    ProcedureText = GetProcText(Module, ProcedureName)
    Dim Procedure As Variant
    For Each Procedure In procedures
        If UCase(CStr(Procedure)) <> UCase(CStr(ProcedureName)) Then
            Rem         If InStr(1, ProcedureText, CStr(PROCEDURE)) > 0 Then
            If RegexTest(ProcedureText, "\W" & Procedure & "[.(\W]", , True) = True Then
                If InStr(1, ProcedureText, "#INCLUDE " & Procedure) = 0 And InStr(1, ListOfImports, "#INCLUDE " & Procedure) = 0 Then
                    If ListOfImports = "" Then
                        ListOfImports = "'#INCLUDE " & Procedure
                    Else
                        ListOfImports = ListOfImports & vbNewLine & "'#INCLUDE " & Procedure
                    End If
                End If
            End If
        End If
    Next
    If ListOfImports <> "" Then Module.CodeModule.InsertLines ProcedureFirstLine(Module, ProcedureName), ListOfImports
End Sub

Public Function RegexTest( _
       ByVal string1 As String, _
       ByVal stringPattern As String, _
       Optional ByVal globalFlag As Boolean, _
       Optional ByVal ignoreCaseFlag As Boolean, _
       Optional ByVal multilineFlag As Boolean) _
        As Boolean
    Dim REGEX As Object
    Set REGEX = CreateObject("VBScript.RegExp")
    With REGEX
        .Global = globalFlag
        .IgnoreCase = ignoreCaseFlag
        .MultiLine = multilineFlag
        .Pattern = stringPattern
    End With
    RegexTest = REGEX.test(string1)
End Function

Sub ImportProcedure( _
    Optional Procedure As String, _
    Optional TargetWorkbook As Workbook, _
    Optional Module As VBComponent, _
    Optional Overwrite As Boolean)
    Rem @todo file picker?
    '#INCLUDE CodepaneSelection
    '#INCLUDE ImportImports
    '#INCLUDE UpdateProcedureCode
    '#INCLUDE ProcedureExists
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE CreateOrSetModule
    '#INCLUDE CheckPath
    '#INCLUDE TXTReadFromUrl
    '#INCLUDE TxtOverwrite
    '#INCLUDE TxtRead
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    If Procedure = "" Then Procedure = CodepaneSelection
    If Procedure = "" Or InStr(1, Procedure, " ") > 0 Then Exit Sub
    Dim ProcedurePath As String
    ProcedurePath = SNIP_FOLDER & Procedure & ".txt"
    If CheckPath(ProcedurePath) = "I" Then
        On Error Resume Next
        Dim DownloadedProcedure As String
        DownloadedProcedure = TXTReadFromUrl("https://github.com/alexofrhodes/vbArc-Snippets/Procedures/raw/main/" & Procedure & ".txt")
        On Error GoTo 0
        If Len(DownloadedProcedure) > 0 Then
            TxtOverwrite SNIP_FOLDER & Procedure & ".txt", DownloadedProcedure
        Else
            MsgBox "File not found neither localy nor online"
            Exit Sub
        End If
    End If
    If ProcedureExists(Procedure, TargetWorkbook) = True Then
        If Overwrite = True Then UpdateProcedureCode Procedure, TxtRead(ProcedurePath), TargetWorkbook
    Else
        If Module Is Nothing Then Set Module = CreateOrSetModule("vbArcImports", vbext_ct_StdModule, TargetWorkbook)
        Module.CodeModule.AddFromFile ProcedurePath
    End If
    ImportImports ProcedurePath, TargetWorkbook, Module, Overwrite
End Sub

Sub ImportImports( _
    Optional Procedure As String, _
    Optional TargetWorkbook As Workbook, _
    Optional Module As VBComponent, _
    Optional Overwrite As Boolean)
    '#INCLUDE ImportProcedure
    '#INCLUDE TxtRead
    Dim var
    Dim importfile As String
    var = Split(TxtRead(Procedure), vbLf)
    Dim TextLine As Variant
    For Each TextLine In var
        TextLine = Trim(TextLine)
        If left(TextLine, 9) = "'#INCLUDE" Then
            importfile = Split(TextLine, " ")(1)
            ImportProcedure importfile, TargetWorkbook, Module, Overwrite
        End If
    Next
End Sub

Sub UpdateAllProcedures(Optional TargetWorkbook As Workbook)
    '#INCLUDE ProceduresOfModule
    '#INCLUDE ImportProcedure
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim procedures As New Collection
    Dim Procedure
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.Type = vbext_ct_StdModule Then
            Set procedures = ProceduresOfModule(Module)
            For Each Procedure In procedures
                If UCase(CStr(Procedure)) <> UCase("UpdateAllProcedures") Then ImportProcedure CStr(Procedure), TargetWorkbook, , True
            Next
        End If
    Next
End Sub

Public Sub UpdateProcedureCode( _
       Procedure As Variant, _
       Code As String, _
       TargetWorkbook As Workbook)
    '#INCLUDE ModuleOfProcedure
    Dim StartLine As Integer
    Dim NumLines As Integer
    Dim Module As VBComponent
    Set Module = ModuleOfProcedure(TargetWorkbook, Procedure)
    With Module.CodeModule
        StartLine = .ProcStartLine(Procedure, vbext_pk_Proc)
        NumLines = .ProcCountLines(Procedure, vbext_pk_Proc)
        .DeleteLines StartLine, NumLines
        .InsertLines StartLine, Code
    End With
End Sub

Function getAllMissingDependencies(Optional TargetWorkbook As Workbook) As Boolean
    '#INCLUDE getMissingMissingDependenciesOfProcedure
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim procedures As New Collection
    Set procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Procedure As Variant
    For Each Procedure In procedures
        getMissingMissingDependenciesOfProcedure CStr(Procedure), TargetWorkbook
    Next
End Function

Function getMissingMissingDependenciesOfProcedure( _
         Optional Procedure As String, _
         Optional TargetWorkbook As Workbook)
    '#INCLUDE ImportProcedure
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveProcedure
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    '#INCLUDE CollectionContains
    If Procedure = "" Then Procedure = ActiveProcedure
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim procedures As New Collection
    Set procedures = ProceduresOfWorkbook(TargetWorkbook)
    Dim Code As String
    Code = GetProcText(ModuleOfProcedure(TargetWorkbook, Procedure), Procedure)
    Dim CodeLines As Variant
    CodeLines = Split(Code, vbNewLine)
    Dim CodeLine As Variant
    Dim RequiredProcedure As String
    Dim Log As String
    If InStr(1, Code, "'#INCLUDE", vbTextCompare) > 0 Then
        For Each CodeLine In CodeLines
            If left(CodeLine, 9) = "'#INCLUDE" Then
                RequiredProcedure = Split(CodeLine, " ")(1)
                If Not CollectionContains(procedures, , RequiredProcedure) Then
                    ImportProcedure RequiredProcedure, TargetWorkbook, , True
                End If
            End If
        Next
    End If
    ProcedureDependenciesExist = (Log = "")
End Function

Sub ArrayTrim(arr As Variant)
    Dim i As Long
    For i = LBound(arr) To UBound(arr)
        If TypeName(arr(i)) = "String" Then arr(i) = Trim(arr(i))
    Next
End Sub

Sub ExportTargetProcedure(Optional ProcedureName As String, _
                          Optional FromWorkbook As Workbook)
    '#INCLUDE LinkedProcs
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveProcedure
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    '#INCLUDE FileExists
    '#INCLUDE FileLastModified
    '#INCLUDE TxtOverwrite
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    If FromWorkbook Is Nothing Then Set FromWorkbook = ActiveCodepaneWorkbook
    Dim procedures As Collection: Set procedures = LinkedProcs(ProcedureName, FromWorkbook)
    On Error Resume Next
    procedures.Add ProcedureName, ProcedureName
    On Error GoTo 0
    Dim Procedure As Variant
    Dim FileFullName As String
    Dim lastMod As Date
    Dim timeDif As Long
    For Each Procedure In procedures
        FileFullName = SNIP_FOLDER & Procedure & ".txt"
        If FileExists(FileFullName) = False Then
            Debug.Print IIf(FileExists(FileFullName) = False, "NEW ", "OVERWROTE ") & Procedure
            TxtOverwrite FileFullName, GetProcText(ModuleOfProcedure(FromWorkbook, CStr(Procedure)), CStr(Procedure))
        Else
            On Error Resume Next
            lastMod = FileLastModified(FileFullName)
            timeDif = DateDiff("s", lastMod, Now())
            On Error GoTo 0
            If timeDif > 60 Then
                Debug.Print IIf(FileExists(FileFullName) = False, "NEW ", "OVERWROTE ") & Procedure
                TxtOverwrite FileFullName, GetProcText(ModuleOfProcedure(FromWorkbook, CStr(Procedure)), CStr(Procedure))
            End If
        End If
    Next
End Sub

Function LinkedProcs( _
         ProcedureName As Variant, _
         FromWorkbook As Workbook) As Collection
    Rem dp LinkedProcs("FindIfGetRow",thisworkbook)
    '#INCLUDE GetCallsOfProcedure
    '#INCLUDE dp
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ModuleOfProcedure
    '#INCLUDE CollectionContains
    '#INCLUDE FindIfGetRow
    Dim AllProcedures As Collection:       Set AllProcedures = ProceduresOfWorkbook(FromWorkbook)
    Dim Proccessed As Collection:          Set Proccessed = New Collection
    Dim CalledProcedures As Collection:    Set CalledProcedures = New Collection
    GetCallsOfProcedure ModuleOfProcedure(FromWorkbook, ProcedureName), ProcedureName, AllProcedures, CalledProcedures
    Dim CalledProceduresCount As Long:    CalledProceduresCount = CalledProcedures.count
    Dim Procedure As Variant
    Dim Module As VBComponent
REPEAT:
    For Each Procedure In CalledProcedures
        If Not CollectionContains(Proccessed, , CStr(Procedure)) Then
            Proccessed.Add Procedure, CStr(Procedure)
            Set Module = ModuleOfProcedure(FromWorkbook, ProcedureName)
            GetCallsOfProcedure Module, CStr(Procedure), AllProcedures, CalledProcedures
        End If
    Next
    If CalledProcedures.count > CalledProceduresCount Then
        CalledProceduresCount = CalledProcedures.count
        GoTo REPEAT
    End If
    Set LinkedProcs = CalledProcedures
End Function

Sub GetCallsOfProcedure( _
    Module As VBComponent, _
    ProcedureName As Variant, _
    AllProcedures As Collection, _
    ByRef OutputCollection As Collection)
    '#INCLUDE ArrayTrim
    '#INCLUDE InStrExact
    '#INCLUDE GetProcText
    Dim Code As String: Code = GetProcText(Module, ProcedureName)
    Dim CodeLines As Variant
    Dim Procedure As Variant
    Dim CodeLine As Variant
    For Each Procedure In AllProcedures
        If CStr(Procedure) <> ProcedureName Then
            If InStr(1, Code, CStr(Procedure)) > 0 Then
                CodeLines = Split(Code, vbNewLine)
                ArrayTrim CodeLines
                For Each CodeLine In CodeLines
                    If InStrExact(1, CStr(CodeLine), CStr(Procedure), True) > 0 Then
                        On Error Resume Next
                        OutputCollection.Add CStr(Procedure), CStr(Procedure)
                        On Error GoTo 0
                        Exit For
                    End If
                Next
            End If
        End If
    Next Procedure
End Sub

Function InStrExact(Start As Long, SourceText As String, WordToFind As String, _
                    Optional CaseSensitive As Boolean = False, _
                    Optional AllowAccentedCharacters As Boolean = False) As Long
    Dim X As Long, Str1 As String, Str2 As String, Pattern As String
    Const UpperAccentsOnly As String = "ÇÉÑ"
    Const UpperAndLowerAccents As String = "ÇÉÑçéñ"
    If CaseSensitive Then
        Str1 = SourceText
        Str2 = WordToFind
        Pattern = "[!A-Za-z0-9]"
        If AllowAccentedCharacters Then Pattern = Replace(Pattern, "!", "!" & UpperAndLowerAccents)
    Else
        Str1 = UCase(SourceText)
        Str2 = UCase(WordToFind)
        Pattern = "[!A-Z0-9]"
        If AllowAccentedCharacters Then Pattern = Replace(Pattern, "!", "!" & UpperAccentsOnly)
    End If
    For X = Start To Len(Str1) - Len(Str2) + 1
        If Mid(" " & Str1 & " ", X, Len(Str2) + 2) Like Pattern & Str2 & Pattern _
                                                   And Not Mid(Str1, X) Like Str2 & "'[" & Mid(Pattern, 3) & "*" Then
            InStrExact = X
            Exit Function
        End If
    Next
End Function

Sub IsDuplicateProceduresInWorkbook(Optional TargetWorkbook As Workbook)
    '#INCLUDE dp
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE DuplicatesInArray
    '#INCLUDE CollectionToArray
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim var
    var = Split(DuplicatesInArray(CollectionToArray(ProceduresOfWorkbook(TargetWorkbook))), ",")
    dp var
    MsgBox "Found " & UBound(var) & " duplicate procedures. Result output in immediate window."
End Sub



'M_Templates	1

Rem @Folder TEMPLATES Declarations
Rem DspErrMsg Constants and Variables
Global Const Success        As Boolean = True
Global Const Failure        As Boolean = False
Global Const NoError        As Long = 0
Global Const LogError       As Long = 997
Global Const RtnError       As Long = 998
Global Const DspError       As Long = 999
Public bLogOnly             As Boolean
Public bDebug               As Boolean
Rem timer constants
Public Const mblncTimer As Boolean = True
Public mvarTimerName
Public mvarTimerStart

Rem @Folder TEMPLATES
Rem This is the main function that basically displays a message box formatted based on what the Err object contains and if we want to put our project in debug mode. It returns the button the user clicks: vbAbort, vbCancel, vbIgnore, vbRetry
Public Function DspErrMsg(ByVal sRoutineName As String, _
                          Optional ByVal sAddText As String = "") As VbMsgBoxResult
    If bLogOnly Then
        Debug.Print Now(), ThisWorkbook.Name & "!" & sRoutineName, err.Description, sAddText
    Else
        DspErrMsg = MsgBox( _
                    Prompt:="Error#" & err.Number & vbLf & err.Description & vbLf & sAddText, _
                    BUTTONS:=IIf(bDebug, vbAbortRetryIgnore, vbCritical) + _
                    IIf(err.Number < 1, 0, vbMsgBoxHelpButton), _
                    title:=sRoutineName, _
                    HelpFile:=err.HelpFile, _
                    Context:=err.HelpContext)
    End If
End Function

Rem templates
Function ErrHandlerTemplate(ProcedureName As String) As String
    '#INCLUDE DspErrMsg
    Dim s As String
    s = "ErrHandler:  'Error Handling, Clean Up and Routine Termination"
    s = s & vbNewLine & "    Select Case err.Number"
    s = s & vbNewLine & "        Case Is = NoError:                                        'No error - do nothing"
    s = s & vbNewLine & "        Case Is = 555:                                               'Add specific error handling here"
    s = s & vbNewLine & "        Case Is = RtnError: PROCEDURENAME = CVErr(xlErrDiv0)           'Return Error code to spreadsheet"
    s = s & vbNewLine & "        Case Is = LogError: Debug.Print cRoutine, err.Description 'Log the event and go on"
    s = s & vbNewLine & "        Case Else:"
    s = s & vbNewLine & "            Select Case DspErrMsg(cModule & ""."" & cRoutine)"
    s = s & vbNewLine & "                Case Is = vbAbort:  Stop: Resume       'Debug mode"
    s = s & vbNewLine & "                Case Is = vbRetry:  Resume             'Try again"
    s = s & vbNewLine & "                Case Is = vbIgnore:                    'End routine"
    s = s & vbNewLine & "            End Select"
    s = s & vbNewLine & "     End Select"
    ErrHandlerTemplate = s
End Function

Sub InjectTemplateModule()
    '#INCLUDE Inject
    '#INCLUDE TemplateModule
    Inject TemplateModule
End Sub

Function TemplateModule(Optional Module As VBComponent) As String
    '#INCLUDE DevInfo
    '#INCLUDE compare
    Dim ModuleName As String
    If Module Is Nothing Then
        ModuleName = "MODULE_NAME"
    Else
        ModuleName = Module.Name
    End If
    Dim s As String
    s = s & DevInfo & vbNewLine & vbNewLine
    s = s & "'   Version:    <Last Update Date goes here>" & vbNewLine
    s = s & "'   Description: General purpose library included in all projects" & vbNewLine & vbNewLine
    s = s & "'   Changelog" & vbNewLine
    s = s & "'   Date" & vbTab & vbTab & "Modification" & vbNewLine
    s = s & "'   " & Format(Date, "dd/mm/yy") & vbTab & "Initial Development" & vbNewLine
    s = s & vbNewLine
    s = s & "'Options" & vbNewLine
    s = s & "    Option Explicit" & vbNewLine
    s = s & "    Option Private Module" & vbNewLine
    s = s & "    Option Compare Text" & vbNewLine & vbNewLine
    s = s & "'Private Constants" & vbNewLine
    s = s & "    Private Const cModule    As String = " & ModuleName & vbNewLine
    TemplateModule = s
End Function

Function CopyTemplateFromSheet(Template As String)
    '#INCLUDE CodepaneSelection
    '#INCLUDE CLIP
    Dim cell As Range
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("Templates")
    On Error Resume Next
    Set cell = ws.Columns(1).SpecialCells(xlCellTypeConstants).Find(Template, LookAt:=xlWhole)
    On Error GoTo 0
    If Not cell Is Nothing Then
        If Len(CodepaneSelection) = 0 Then CLIP cell.OFFSET(0, 1)
    End If
    CopyTemplateFromSheet = cell.OFFSET(0, 1)
End Function

Sub InjectTemplateFromSheet(Template As String)
    '#INCLUDE Inject
    '#INCLUDE CodepaneSelection
    Dim cell As Range
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("Templates")
    On Error Resume Next
    Set cell = ws.Columns(1).SpecialCells(xlCellTypeConstants).Find(Template, LookAt:=xlWhole)
    On Error GoTo 0
    If Not cell Is Nothing Then
        If Len(CodepaneSelection) = 0 Then Inject cell.OFFSET(0, 1)
    End If
End Sub

Sub InjectScreenUpdating()
    '#INCLUDE InjectTemplateFromSheet
    InjectTemplateFromSheet "ScreenUpdating"
End Sub

Sub InjectForCounter()
    '#INCLUDE InjectTemplateFromSheet
    InjectTemplateFromSheet "forcounter"
End Sub

Sub InjectIf()
    '#INCLUDE InjectTemplateFromSheet
    InjectTemplateFromSheet "ifelse"
End Sub

Sub InjectOnErrorResumeNext()
    '#INCLUDE InjectTemplateFromSheet
    InjectTemplateFromSheet "onerror"
End Sub

Sub InjectEnableEvents()
    '#INCLUDE InjectTemplateFromSheet
    InjectTemplateFromSheet "EnableEvents"
End Sub

Sub InjectTemplateProcedure()
    '#INCLUDE Inject
    '#INCLUDE TemplateProcedure
    Inject TemplateProcedure
End Sub

Function TemplateProcedure(Optional FunctionName As String = "PROCEDURE_NAME") As String
    '#INCLUDE DevInfo
    '#INCLUDE ErrHandlerTemplate
    '#INCLUDE StartTimer
    '#INCLUDE EndTimer
    Dim Q As String: Q = """"
    Dim s As String
    s = s & "Function " & FunctionName & "(ByVal MyParameter as String) As Variant" & vbNewLine
    s = s & DevInfo & vbNewLine
    s = s & vbNewLine
    s = s & "'   Description:Procedure Description" & vbNewLine
    s = s & "'   Inputs:     MyParameter  Describe its purpose" & vbNewLine
    s = s & "'   Outputs:    Success: <return this>" & vbNewLine
    s = s & "'               Failure: <return this>" & vbNewLine
    s = s & "'   Requisites  Routines    ModuleName.ProcedureName" & vbNewLine
    s = s & "'               Classes      Class Module Name" & vbNewLine
    s = s & "'               Forms        User Form Name" & vbNewLine
    s = s & "'               Tables       Table Name" & vbNewLine
    s = s & "'               References   Reference" & vbNewLine
    s = s & "'   Notes <add if needed>" & vbNewLine
    s = s & "'   Example: ?" & FunctionName & "(MyParameter)" & vbNewLine & vbNewLine
    s = s & "'   Changelog" & vbNewLine
    s = s & "'   Date        Modification" & vbNewLine
    s = s & "'   " & Format(Date, "DD/MM/YY") & "    Initial Release" & vbNewLine
    s = s & vbNewLine
    s = s & "'   Check Inputs and Requisites" & vbNewLine
    s = s & "    If sParameter = cvbNullString then Err.Raise DspError, , ""Parameter missing""" & vbNewLine
    s = s & vbNewLine
    s = s & "'   Declarations" & vbNewLine
    s = s & "    Const cRoutine as String = " & Q & FunctionName & Q
    s = s & "'   Error Handling Initialization" & vbNewLine
    s = s & "    On Error GoTo ErrHandler" & vbNewLine
    s = s & "    " & FunctionName & " = Failure    'Assume failure" & vbNewLine
    s = s & vbNewLine
    s = s & "'   Initialize Variables" & vbNewLine & vbNewLine
    s = s & "'   Procedure" & vbNewLine
    s = s & "    Application.screenupdating=false" & vbNewLine
    s = s & "    StartTimer " & FunctionName & vbNewLine & "    " & vbNewLine
    s = s & "    " & FunctionName & " = Success    'Successful finish" & vbNewLine
    s = s & "    EndTimer" & vbNewLine & vbNewLine
    s = s & "NormalExit:" & vbNewLine
    s = s & "    Application.screenupdating=false" & vbNewLine
    s = s & "    Exit Sub" & vbNewLine
    s = s & vbNewLine
    s = s & ErrHandlerTemplate(FunctionName) & vbNewLine
    s = s & "End Function"
    TemplateProcedure = s
End Function

Rem timer
Public Function StartTimer(TimerName)
    On Error GoTo ERR_HANDLER
    If mblncTimer Then
        mvarTimerName = TimerName
        mvarTimerStart = Timer
    End If
    On Error Resume Next
    Exit Function
ERR_HANDLER:
    MsgBox err.Number & " " & err.Description, vbCritical, "StartTimer()"
End Function

Public Function EndTimer()
    '#INCLUDE FoldersCreate
    '#INCLUDE TxtAppend
    On Error GoTo ERR_HANDLER
    Dim strFile As String
    Dim strContent As String
    If mblncTimer Then
        Dim strPath As String
        strPath = Environ("USERprofile") & "\My Documents\vbArc\Timers\"
        FoldersCreate strPath
        strFile = strPath & mvarTimerName & ".txt"
        Rem strFile = ThisWorkbook.path & "\" _
        & Left(ThisWorkbook.Name, InStr(1, ThisWorkbook.Name, ".") - 1) _
        & "TimerLog.txt"
        If Len(Dir(strFile)) = 0 Then
            strContent = _
                       "Timestamp" & vbTab & vbTab & vbTab & vbTab & _
                       "ElapsedTime" & vbTab & vbTab & _
                       "TimerName"
            TxtAppend strFile, strContent
        End If
        strContent = Now() & vbTab & vbTab & _
                           Format(Timer - mvarTimerStart, "0.000000") & vbTab & vbTab & vbTab & _
                           mvarTimerName
        TxtAppend strFile, strContent
    End If
    On Error Resume Next
    Exit Function
ERR_HANDLER:
    MsgBox err.Number & " " & err.Description, vbCritical, "EndTimer()"
End Function

Public Sub dp(var As Variant)
    '#INCLUDE printRange
    '#INCLUDE printArray
    '#INCLUDE printCollection
    '#INCLUDE printDictionary
    Dim element     As Variant
    Dim i As Long
    Select Case TypeName(var)
        Case Is = "String", "Long", "Integer", "Boolean"
            Debug.Print var
        Case Is = "Variant()", "String()", "Long()", "Integer()"
            printArray var
        Case Is = "Collection"
            printCollection var
        Case Is = "Dictionary"
            printDictionary var
        Case Is = "Range"
            printRange var
        Case Is = "Date"
            Debug.Print var
        Case Else
    End Select
End Sub

Public Sub printRange(var As Variant)
    '#INCLUDE dp
    '#INCLUDE Combine2Array
    If var.Areas.count = 1 Then
        dp var.Value
    Else
        Dim out As Variant
        Dim temp As Variant
        Dim i As Long
        For i = 1 To var.Areas.count
            temp = var.Areas(i).Value
            If IsEmpty(out) Then
                out = temp
            Else
                out = Combine2Array(out, temp)
            End If
        Next
        dp out
    End If
End Sub

Private Sub printArray(var As Variant)
    '#INCLUDE DPH
    '#INCLUDE ArrayDimensions
    If ArrayDimensions(var) = 1 Then
        Debug.Print Join(var, vbNewLine)
    ElseIf ArrayDimensions(var) > 1 Then
        DPH var
    End If
End Sub

Private Sub printCollection(var As Variant)
    '#INCLUDE dp
    Dim elem        As Variant
    For Each elem In var
        dp elem
    Next elem
End Sub

Private Sub printDictionary(var As Variant)
    '#INCLUDE dp
    Dim i As Long: Dim iCount As Long
    Dim arrKeys
    Dim sKey        As String
    Dim varItem
    With var
        iCount = .count
        arrKeys = .keys
        iCount = UBound(arrKeys, 1)
        For i = 0 To iCount
            sKey = arrKeys(i)
            If IsObject(.item(sKey)) Then
                Debug.Print sKey & " : "
                dp (.item(sKey))
            Else
                Debug.Print sKey & " : " & .item(sKey)
            End If
        Next i
    End With
End Sub

Private Sub DPH(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
    '#INCLUDE DebugPrintHairetu
    Call DebugPrintHairetu(Hairetu, HyoujiMaxNagasa, HairetuName)
End Sub

Public Function ArrayDimensions(ByVal vArray As Variant) As Long
    Dim dimnum      As Long
    Dim ErrorCheck As Long
    On Error GoTo FinalDimension
    For dimnum = 1 To 60000
        ErrorCheck = LBound(vArray, dimnum)
    Next
FinalDimension:
    ArrayDimensions = dimnum - 1
End Function

Private Sub DebugPrintHairetu(ByVal Hairetu, Optional HyoujiMaxNagasa%, Optional HairetuName$)
    '#INCLUDE ShortenToByteCharacters
    Dim i&, j&, k&, m&, n&
    Dim TateMin&, TateMax&, YokoMin&, YokoMax&
    Dim WithTableHairetu
    Dim NagasaList, MaxNagasaList
    Dim NagasaOnajiList
    Dim OutputList
    Const SikiriMoji$ = "|"
    Dim Jigen2%
    On Error Resume Next
    Jigen2 = UBound(Hairetu, 2)
    On Error GoTo 0
    If Jigen2 = 0 Then
        Hairetu = Application.Transpose(Hairetu)
    End If
    TateMin = LBound(Hairetu, 1)
    TateMax = UBound(Hairetu, 1)
    YokoMin = LBound(Hairetu, 2)
    YokoMax = UBound(Hairetu, 2)
    ReDim WithTableHairetu(1 To TateMax - TateMin + 1 + 1, 1 To YokoMax - YokoMin + 1 + 1)
    For i = 1 To TateMax - TateMin + 1
        WithTableHairetu(i + 1, 1) = TateMin + i - 1
            For j = 1 To YokoMax - YokoMin + 1
                WithTableHairetu(1, j + 1) = YokoMin + j - 1
                    WithTableHairetu(i + 1, j + 1) = Hairetu(i - 1 + TateMin, j - 1 + YokoMin)
                    Next j
                Next i
                n = UBound(WithTableHairetu, 1)
                m = UBound(WithTableHairetu, 2)
                ReDim NagasaList(1 To n, 1 To m)
                ReDim MaxNagasaList(1 To m)
                Dim TmpStr$
                For j = 1 To m
                    For i = 1 To n
                        If j > 1 And HyoujiMaxNagasa <> 0 Then
                            TmpStr = WithTableHairetu(i, j)
                            WithTableHairetu(i, j) = ShortenToByteCharacters(TmpStr, HyoujiMaxNagasa)
                            End If
                            NagasaList(i, j) = LenB(StrConv(WithTableHairetu(i, j), vbFromUnicode))
                            MaxNagasaList(j) = WorksheetFunction.Max(MaxNagasaList(j), NagasaList(i, j))
                        Next i
                    Next j
                    ReDim NagasaOnajiList(1 To n, 1 To m)
                    Dim TmpMaxNagasa&
                    For j = 1 To m
                        TmpMaxNagasa = MaxNagasaList(j)
                        For i = 1 To n
                            NagasaOnajiList(i, j) = WithTableHairetu(i, j) & WorksheetFunction.Rept(" ", TmpMaxNagasa - NagasaList(i, j))
                        Next i
                    Next j
                    ReDim OutputList(1 To n)
                    For i = 1 To n
                        For j = 1 To m
                            If j = 1 Then
                                OutputList(i) = NagasaOnajiList(i, j)
                            Else
                                OutputList(i) = OutputList(i) & SikiriMoji & NagasaOnajiList(i, j)
                            End If
                        Next j
                    Next i
                    Debug.Print HairetuName
                    For i = 1 To n
                        Debug.Print OutputList(i)
                    Next i
                End Sub

Private Function ShortenToByteCharacters(Mojiretu$, ByteNum%)
    '#INCLUDE CalculateByteCharacters
    '#INCLUDE TextDecomposition
    Dim OriginByte%
    Dim output
    OriginByte = LenB(StrConv(Mojiretu, vbFromUnicode))
    If OriginByte <= ByteNum Then
        output = Mojiretu
    Else
        Dim RuikeiByteList, BunkaiMojiretu
        RuikeiByteList = CalculateByteCharacters(Mojiretu)
        BunkaiMojiretu = TextDecomposition(Mojiretu)
        Dim AddMoji$
        AddMoji = "."
        Dim i&, n&
        n = Len(Mojiretu)
        For i = 1 To n
            If RuikeiByteList(i) < ByteNum Then
                output = output & BunkaiMojiretu(i)
            ElseIf RuikeiByteList(i) = ByteNum Then
                If LenB(StrConv(BunkaiMojiretu(i), vbFromUnicode)) = 1 Then
                    output = output & AddMoji
                Else
                    output = output & AddMoji & AddMoji
                End If
                Exit For
            ElseIf RuikeiByteList(i) > ByteNum Then
                output = output & AddMoji
                Exit For
            End If
        Next i
    End If
    ShortenToByteCharacters = output
End Function

Private Function CalculateByteCharacters(Mojiretu$)
    Dim MojiKosu%
    MojiKosu = Len(Mojiretu)
    Dim output
    ReDim output(1 To MojiKosu)
    Dim i&
    Dim TmpMoji$
    For i = 1 To MojiKosu
        TmpMoji = Mid(Mojiretu, i, 1)
        If i = 1 Then
            output(i) = LenB(StrConv(TmpMoji, vbFromUnicode))
        Else
            output(i) = LenB(StrConv(TmpMoji, vbFromUnicode)) + output(i - 1)
        End If
    Next i
    CalculateByteCharacters = output
End Function

Private Function TextDecomposition(Mojiretu$)
    Dim i&, n&
    Dim output
    n = Len(Mojiretu)
    ReDim output(1 To n)
    For i = 1 To n
        output(i) = Mid(Mojiretu, i, 1)
    Next i
    TextDecomposition = output
End Function

Function DpHeader(str As Variant, Optional lvl As Integer = 1, Optional Character As String = "'", _
                  Optional top As Boolean, Optional bottom As Boolean) As String
    '#INCLUDE LargestLength
    If lvl < 1 Then lvl = 1
    If Character = "" Then Character = "'"
    Dim Indentation As Integer
    Indentation = (lvl * 4) - 4 + 1
    Dim QUOTE As String: QUOTE = "'"
    Dim s As String
    Dim element As Variant
    If top = True Then s = vbNewLine & QUOTE & String(Indentation + LargestLength(str), Character) & vbNewLine
    If TypeName(str) <> "String" Then
        For Each element In str
            s = s & QUOTE & String(Indentation, Character) & element & vbNewLine
        Next
    Else
        s = s & QUOTE & String(Indentation, Character) & str
    End If
    If bottom = True Then s = s & QUOTE & String(Indentation + LargestLength(str), Character)
    DpHeader = s
End Function



'Sheet11	100



'uProjectExplorer	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uProjectExplorer
'* Created    : 06-10-2022 10:39
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub TreeView1_Click()
    '#INCLUDE
    TreeviewGotoProjectElement TreeView1
End Sub

Private Sub UserForm_Initialize()
    InitializeProjectExplorer
End Sub

Sub InitializeProjectExplorer()
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveModule
    '#INCLUDE ProjectExplorer
    '#INCLUDE TreeviewAllProjects
    '#INCLUDE ImageListLoadProjectIcons
    '#INCLUDE TreeviewAssignProjectImages
    '#INCLUDE TreeviewSelectNodes
    '#INCLUDE MakeUserFormChildOfVBEditor
    Application.VBE.MainWindow.visible = True
    MakeUserFormChildOfVBEditor Me.Caption
    TreeviewAllProjects TreeView1
    With TreeView1
        .Sorted = True
        .Appearance = ccFlat
        .LineStyle = tvwRootLines
        .Style = tvwTreelinesPlusMinusPictureText
        .Font.Size = 10
        .Indentation = 2
    End With
    ImageListLoadProjectIcons ImageList1, TreeView1
    TreeviewAssignProjectImages TreeView1
    If Application.VBE.MainWindow.visible = False Then
        Set TargetWorkbook = ActiveWorkbook
    Else
        Set TargetWorkbook = ActiveCodepaneWorkbook
    End If
    TreeviewSelectNodes TreeView1, True, TargetWorkbook.Name, Array(ActiveModule.Name)
End Sub


'F_Userforms	1

Rem @Folder Userforms
Option Explicit
Option Compare Text
Rem @Subfolder Userforms>Transparent Declarations
Rem Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Private Const GWL_STYLE As Long = (-16)
Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_CAPTION As Long = &HC00000
Private Const WS_EX_DLGMODALFRAME As Long = &H1
Private Const WS_EX_LAYERED = &H80000
Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2
Private m_sngDownX As Single
Private m_sngDownY As Single
Rem Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Rem Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Rem @Subfolder Userforms>Parent Declarations
Public Const FORMAT_MESSAGE_ALLOCATE_BUFFER = &H100
Public Const FORMAT_MESSAGE_ARGUMENT_ARRAY = &H2000
Public Const FORMAT_MESSAGE_FROM_HMODULE = &H800
Public Const FORMAT_MESSAGE_FROM_STRING = &H400
Public Const FORMAT_MESSAGE_FROM_SYSTEM = &H1000
Public Const FORMAT_MESSAGE_IGNORE_INSERTS = &H200
Public Const FORMAT_MESSAGE_MAX_WIDTH_MASK = &HFF
Public Const FORMAT_MESSAGE_TEXT_LEN = 160
Public Const MAX_PATH = 260
Public Const GWL_HWNDPARENT As Long = -8
Public Const GW_OWNER = 4
Public Declare PtrSafe Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Public Declare PtrSafe Function GetClassName Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long
Private Declare PtrSafe Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Public VBEditorHWnd As Long
Public ApplicationHWnd As Long
Public ExcelDeskHWnd As Long
Public ActiveWindowHWnd As Long
Public UserFormHWnd As Long
Public WindowsDesktopHWnd As Long
Public Const GA_ROOT As Long = 2
Public Const GA_ROOTOWNER As Long = 3
Public Const GA_PARENT As Long = 1
Public Declare PtrSafe Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Public Declare PtrSafe Function GetAncestor Lib "user32.dll" (ByVal hWnd As Long, ByVal gaFlags As Long) As Long
Public Declare PtrSafe Function GetDesktopWindow Lib "user32" () As Long
Public Declare PtrSafe Function GetParent Lib "user32.dll" (ByVal hWnd As Long) As Long
Private Declare PtrSafe Function GetWindow Lib "user32" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
Public Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Public Const C_EXCEL_APP_WINDOWCLASS = "XLMAIN"
Public Const C_EXCEL_DESK_WINDOWCLASS = "XLDESK"
Public Const C_EXCEL_WINDOW_WINDOWCLASS = "EXCEL7"
Public Const USERFORM_WINDOW_CLASS = "ThunderDFrame"
Public Const C_VBA_USERFORM_WINDOWCLASS = "ThunderDFrame"
Rem Form on top
Public Const SWP_NOMOVE = &H2
Public Const SWP_NOSIZE = &H1
Public Const HWND_TOP = 0
Public Const HWND_BOTTOM = 1
Public Const HWND_TOPMOST = -1
Public Const HWND_NOTOPMOST = -2
Public Declare PtrSafe Function SetWindowPos Lib "user32" (ByVal hWnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal X As LongPtr, ByVal Y As LongPtr, ByVal cx As LongPtr, ByVal cy As LongPtr, ByVal uFlags As LongPtr) As Long
Rem ---
#If VBA7 Then
    Public Declare PtrSafe Function SetParent Lib "user32" ( _
    ByVal hwndChild As LongPtr, _
    ByVal hWndNewParent As LongPtr) As LongPtr
    Public Declare PtrSafe Function SetForegroundWindow Lib "user32" ( _
    ByVal hWnd As LongPtr) As Long
    Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" ( _
    ByVal lpClassName As String, _
    ByVal lpWindowName As String) As LongPtr
    Public Declare PtrSafe Function FormatMessage Lib "kernel32" Alias "FormatMessageA" ( _
    ByVal dwFlags As Long _
    , lpSource As Any _
    , ByVal dwMessageId As Long _
    , ByVal dwLanguageId As Long _
    , ByVal lpBuffer As String _
    , ByVal nSize As Long _
    , Arguments As LongPtr) As Long
#Else
    Public Declare  Function SetParent Lib "user32" ( _
    ByVal hWndChild As Long, _
    ByVal hWndNewParent As Long) As Long
    Public Declare  Function SetForegroundWindow Lib "user32" ( _
    ByVal hwnd As Long) As Long
    Public Declare  Function FindWindow Lib "user32" Alias "FindWindowA" ( _
    ByVal lpClassName As String, _
    ByVal lpWindowName As String) As Long
    Public Declare  Function FormatMessage Lib "kernel32.dll" Alias "FormatMessageA" ( _
    ByVal dwFlags As Long, _
    ByRef lpSource As Any, _
    ByVal dwMessageId As Long, _
    ByVal dwLanguageId As Long, _
    ByVal lpBuffer As String, _
    ByVal nSize As Long, _
    ByRef Arguments As Long) As Long
#End If
Rem Closeby
Public Enum CloseBy
    user = 0
    Code = 1
    WindowsOS = 2
    TaskManager = 3
End Enum

Rem FlashControl
Public Declare PtrSafe Function getTickCount Lib "kernel32" Alias "GetTickCount" () As Long
Public Const Black As Long = &H80000012
Public Const Red As Long = &HFF&
Rem ControlID
Public Const ControlIDCheckBox = "Forms.CheckBox.1"
Public Const ControlIDComboBox = "Forms.ComboBox.1"
Public Const ControlIDCommandButton = "Forms.CommandButton.1"
Public Const ControlIDFrame = "Forms.Frame.1"
Public Const ControlIDImage = "Forms.Image.1"
Public Const ControlIDLabel = "Forms.Label.1"
Public Const ControlIDListBox = "Forms.ListBox.1"
Public Const ControlIDMultiPage = "Forms.MultiPage.1"
Public Const ControlIDOptionButton = "Forms.OptionButton.1"
Public Const ControlIDScrollBar = "Forms.ScrollBar.1"
Public Const ControlIDSpinButton = "Forms.SpinButton.1"
Public Const ControlIDTabStrip = "Forms.TabStrip.1"
Public Const ControlIDTextBox = "Forms.TextBox.1"
Public Const ControlIDToggleButton = "Forms.ToggleButton.1"
Rem other
Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function GetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function SetWindowLongA Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long

Rem @Folder Userforms
Rem @Subfolder Userforms>Transparent
Rem MakeFormTransparent me
Rem MakeFormBorderless Me
Public Sub MakeFormTransparent(frm As Object, Optional color As Variant)
    '#INCLUDE MakeFormBorderless
    Dim formhandle As Long
    Dim bytOpacity As Byte
    formhandle = CLng(FindWindow(vbNullString, frm.Caption))
    If IsMissing(color) Then color = vbWhite
    bytOpacity = 100
    SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED
    frm.BackColor = color
    SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY
End Sub

Public Sub MakeFormBorderless(frm As Object)
    Dim lngWindow As Long
    Dim lFrmHdl As Long
    lFrmHdl = CLng(FindWindow(vbNullString, frm.Caption))
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl
End Sub

Rem @Subfolder Userforms>Parent
Public Sub UserformOnTop(form As Object)
    Const C_VBA6_USERFORM_CLASSNAME = "ThunderDFrame"
    Dim ret As Long
    Dim formHWnd As Long
    formHWnd = CLng(FindWindow(C_VBA6_USERFORM_CLASSNAME, form.Caption))
    If formHWnd = 0 Then
        Debug.Print err.LastDllError
    End If
    ret = SetWindowPos(formHWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE)
    If ret = 0 Then
        Debug.Print err.LastDllError
    End If
End Sub

Public Sub MakeUserFormChildOfVBEditor(GivenFormCaption As String)
    '#INCLUDE DisplayErrorText
    #If VBA7 Then
        Dim VBEWindowPointer As LongPtr
        Dim UserFormWindowPointer As LongPtr
        Dim ReturnOfSetParentAPI As LongPtr
    #Else
        Dim VBEWindowPointer As Long
        Dim UserFormWindowPointer As Long
        Dim ReturnOfSetParentAPI As Long
    #End If
    Dim ErrorNumber As Long
    VBEWindowPointer = Application.VBE.MainWindow.hWnd
    UserFormWindowPointer = FindWindow(lpClassName:=USERFORM_WINDOW_CLASS, lpWindowName:=GivenFormCaption)
    Const ERROR_NUMBER_FOR_SETPARENT_API = 0
    ReturnOfSetParentAPI = SetParent(hwndChild:=UserFormWindowPointer, hWndNewParent:=VBEWindowPointer)
    If ReturnOfSetParentAPI = ERROR_NUMBER_FOR_SETPARENT_API Then
        ErrorNumber = err.LastDllError
        DisplayErrorText "Error With SetParent", ErrorNumber
    Else
        Debug.Print GivenFormCaption & " is child of VBE Window."
    End If
    SetForegroundWindow UserFormWindowPointer
End Sub

Sub DisplayErrorText(Context As String, ErrNum As Long)
    Rem  Displays a standard error message box. For this
    Rem  procedure, ErrNum should be the number returned
    Rem  by the GetLastError API function or the value
    Rem  of Err.LastDllError. It is NOT the number
    Rem  returned by Err.Number.
    '#INCLUDE GetSystemErrorMessageText
    Dim ErrText As String
    ErrText = GetSystemErrorMessageText(ErrNum)
    MsgBox Context & vbCrLf & _
           "Error Number: " & CStr(ErrNum) & vbCrLf & _
           "Error Text:   " & ErrText, vbOKOnly
End Sub

Function GetSystemErrorMessageText(ErrorNumber As Long) As String
    Rem  This function gets the system error message text that corresponds to the error code returned by the
    Rem  GetLastError API function or the Err.LastDllError property. It may be used ONLY for these error codes.
    Rem  These are NOT the error numbers returned by Err.Number (for these errors, use Err.Description to get
    Rem  the description of the message).
    Rem  The error number MUST be the value returned by GetLastError or Err.LastDLLError.
    Rem
    Rem  In general, you should use Err.LastDllError rather than GetLastError because under some circumstances the value of
    Rem  GetLastError will be reset to 0 before the value is returned to VB. Err.LastDllError will always reliably return
    Rem  the last error number raised in a DLL.
    '#INCLUDE TrimToNull
    Dim ErrorText As String
    Dim ErrorTextLength As Long
    Dim FormatMessageResult As Long
    Dim LanguageID As Long
    LanguageID = 0&
    ErrorText = String$(FORMAT_MESSAGE_TEXT_LEN, " ")
    ErrorTextLength = Len(ErrorText)
    FormatMessageResult = 0&
    #If VBA7 Then
        Dim FormatMessageAPILastArgument As LongPtr
        FormatMessageAPILastArgument = 0
    #Else
        Dim FormatMessageAPILastArgument As Long
        FormatMessageAPILastArgument = 0
    #End If
    FormatMessageResult = FormatMessage( _
                          dwFlags:=FORMAT_MESSAGE_FROM_SYSTEM Or FORMAT_MESSAGE_IGNORE_INSERTS, _
                          lpSource:=0&, _
                          dwMessageId:=ErrorNumber, _
                          dwLanguageId:=0&, _
                          lpBuffer:=ErrorText, _
                          nSize:=ErrorTextLength, _
                          Arguments:=FormatMessageAPILastArgument)
    If FormatMessageResult > 0 Then
        ErrorText = TrimToNull(ErrorText)
        GetSystemErrorMessageText = ErrorText
    Else
        GetSystemErrorMessageText = "NO ERROR DESCRIPTION AVAILABLE"
    End If
End Function

Function TrimToNull(TEXT As String) As String
    Rem  Returns all the text in Text to the left of the vbNullChar
    Dim NullCharIndex As Integer
    NullCharIndex = InStr(1, TEXT, vbNullChar, vbTextCompare)
    If NullCharIndex > 0 Then
        TrimToNull = left(TEXT, NullCharIndex - 1)
    Else
        TrimToNull = TEXT
    End If
End Function

Rem UserformMinimize
Sub AddMinimizeButtonToUserform(form As Object)
    Dim UserFormCaption As String
    UserFormCaption = form.Caption
    Dim hWnd            As Long
    Dim exLong          As Long
    hWnd = FindWindowA(vbNullString, UserFormCaption)
    exLong = GetWindowLongA(hWnd, -16)
    If (exLong And &H20000) = 0 Then
        SetWindowLongA hWnd, -16, exLong Or &H20000
    Else
    End If
End Sub

Sub UserformSetHandCursor(Optional form As Object)
    '#INCLUDE SetHandCursor
    '#INCLUDE ActiveModule
    If form Is Nothing Then
        Dim Module As VBComponent
        Set Module = ActiveModule
        If Module.Type = vbext_ct_MSForm Then
            Dim ctr As MSForms.control
            For Each ctr In Module.Designer.Controls
                SetHandCursor ctr
            Next
        End If
    End If
End Sub

Sub UserformSelectedControlsSetHandCursor()
    '#INCLUDE SetHandCursor
    '#INCLUDE SelectedControls
    '#INCLUDE ActiveModule
    Dim Module As VBComponent
    Set Module = ActiveModule
    If Module.Type = vbext_ct_MSForm Then
        Dim ctr As MSForms.control
        For Each ctr In SelectedControls
            SetHandCursor ctr
        Next
    End If
End Sub

Sub SetHandCursor(control As MSForms.control)
    On Error GoTo catch
    With control
        .MouseIcon = LoadPicture("C:\Users\acer\Dropbox\SOFTWARE\EXCEL\0 Alex\icons\Hand Cursor Pointer.ico")
        .MousePointer = fmMousePointerCustom
    End With
catch:
End Sub

Sub SwitchControlNames()
    '#INCLUDE SelectedControls
    Dim ctrls As Collection
    Set ctrls = SelectedControls
    If ctrls.count <> 2 Then Exit Sub
    Dim tmp1 As String
    tmp1 = ctrls(1).Name
    Dim tmp2 As String
    tmp2 = ctrls(2).Name
    ctrls(1).Name = "tmp1"
    ctrls(2).Name = "tmp2"
    ctrls(1).Name = tmp2
    ctrls(2).Name = tmp1
End Sub

Sub SwitchControlPositions()
    '#INCLUDE SelectedControls
    Dim ctrls As Collection
    Set ctrls = SelectedControls
    If ctrls.count <> 2 Then Exit Sub
    Dim left1 As Long, left2 As Long
    Dim top1 As Long, top2 As Long
    left1 = ctrls(1).left
    top1 = ctrls(1).top
    left2 = ctrls(2).left
    top2 = ctrls(2).top
    ctrls(1).left = left2
    ctrls(1).top = top2
    ctrls(2).left = left1
    ctrls(2).top = top1
End Sub

Public Sub Reframe(form As Object, control As MSForms.control)
    Dim c As MSForms.control
    For Each c In form.Controls
        If TypeName(c) = "Frame" Then
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                If c.Name <> control.parent.parent.Name Then c.visible = False
            End If
        End If
    Next
    form.Controls(control.Caption).visible = True
    For Each c In form.Controls
        If TypeName(c) = "Label" Then
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                c.BackColor = &H534848
            End If
        End If
    Next
    control.BackColor = &H80B91E
End Sub

Sub SaveUserformOptions(form As Object, _
                        Optional includeCheckbox As Boolean = True, _
                        Optional includeOptionButton As Boolean = True, _
                        Optional includeTextBox As Boolean = True, _
                        Optional includeListbox As Boolean = True, _
                        Optional includeToggleButton As Boolean = True)
    '#INCLUDE ListboxSelectedIndexes
    '#INCLUDE CreateOrSetSheet
    '#INCLUDE CollectionToArray
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet(form.Name & "_Settings", ThisWorkbook)
    ws.Cells.clear
    Dim coll As New Collection
    Dim cell As Range
    Set cell = ws.Cells(1, 1)
    Dim c As MSForms.control
    For Each c In form.Controls
        If TypeName(c) Like "CheckBox" Then
            If Not includeCheckbox Then GoTo Skip
        ElseIf TypeName(c) Like "OptionButton" Then
            If Not includeOptionButton Then GoTo Skip
        ElseIf TypeName(c) Like "TextBox" Then
            If Not includeTextBox Then GoTo Skip
        ElseIf TypeName(c) = "ListBox" Then
            If Not includeListbox Then GoTo Skip
        ElseIf TypeName(c) Like "ToggleButton" Then
            If Not includeToggleButton Then GoTo Skip
        Else
            GoTo Skip
        End If
        cell = c.Name
        Select Case TypeName(c)
            Case "TextBox", "CheckBox", "OptionButton", "ToggleButton"
                cell.OFFSET(0, 1) = c.Value
            Case "ListBox"
                Set coll = ListboxSelectedIndexes(c)
                If coll.count > 0 Then
                    cell.OFFSET(0, 1) = Join(CollectionToArray(coll), ",")
                Else
                    cell.OFFSET(0, 1) = -1
                End If
        End Select
        Set cell = cell.OFFSET(1, 0)
Skip:
    Next
End Sub

Sub ListboxToRangeSelect(lBox As MSForms.ListBox)
    '#INCLUDE ListboxSelectedValues
    '#INCLUDE GetInputRange
    '#INCLUDE CollectionsToArrayTable
    Dim rng As Range
    If GetInputRange(rng, "Range picker", "Select range to output listbox' list") = False Then Exit Sub
    rng.RESIZE(lBox.ListCount, lBox.columnCount) = CollectionsToArrayTable(ListboxSelectedValues(lBox))
End Sub

Sub LoadUserformOptions(form As Object, Optional ExcludeThese As Variant)
    '#INCLUDE SelectListboxItems
    '#INCLUDE IsInArray
    '#INCLUDE CreateOrSetSheet
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet(form.Name & "_Settings", ThisWorkbook)
    If ws.Range("A1") = "" Then Exit Sub
    Dim cell As Range
    Set cell = ws.Cells(1, 1)
    Dim c As MSForms.control
    Dim v
    On Error Resume Next
    Do While cell <> ""
        Set c = form.Controls(cell.TEXT)
        If Not TypeName(c) = "Nothing " Then
            If Not IsInArray(cell, ExcludeThese) Then
                Select Case TypeName(c)
                    Case "TextBox", "CheckBox", "OptionButton", "ToggleButton"
                        c.Value = cell.OFFSET(0, 1)
                    Case "ListBox"
                        If InStr(1, cell.OFFSET(0, 1), ",") > 0 Then
                            SelectListboxItems c, Split(cell.OFFSET(0, 1), ","), True
                        Else
                            c.SELECTED(CInt(cell.OFFSET(0, 1))) = True
                        End If
                End Select
            End If
        End If
        Set cell = cell.OFFSET(1, 0)
    Loop
End Sub

Sub AddFormControls(controlID As String, _
                    CountOrArrayOfNames As Variant, _
                    Optional Captions As Variant = 0, _
                    Optional Vertical As Boolean = True, _
                    Optional OFFSET As Long = 0, _
                    Optional form As Object)
    '#INCLUDE ActiveModule
    If IsNumeric(CountOrArrayOfNames) And IsArray(Captions) Then
        If UBound(Captions) + 1 <> CLng(CountOrArrayOfNames) Then Exit Sub
    End If
    Dim Module As VBComponent
    If form Is Nothing Then
        Set Module = ActiveModule
        If Module.Type <> vbext_ct_MSForm Then Exit Sub
    End If
    Dim c As MSForms.control
    Dim i As Long
    If IsNumeric(CountOrArrayOfNames) Then
        For i = 1 To CLng(CountOrArrayOfNames)
            If form Is Nothing Then
                Set c = Module.Designer.Controls.Add(controlID)
            Else
                Set c = form.Controls.Add(controlID)
            End If
            If Vertical Then
                c.top = i * c.Height + i * 5 - c.Height
                c.left = OFFSET
            Else
                c.top = OFFSET
                c.left = i * c.Width + i * 5 - c.Width
            End If
            If IsArray(Captions) Then
                c.Caption = Captions(i - 1)
            Else
                On Error Resume Next
                c.Caption = CountOrArrayOfNames(i - 1)
                If c.Caption = "" Then c.Caption = c.Name
                On Error GoTo 0
            End If
        Next
    Else
        For i = 1 To UBound(CountOrArrayOfNames) + 1
            If form Is Nothing Then
                Set c = Module.Designer.Controls.Add(controlID)
            Else
                Set c = form.Controls.Add(controlID)
            End If
            If Vertical Then
                c.top = i * c.Height + i * 5 - c.Height
                c.left = OFFSET
            Else
                c.top = OFFSET
                c.left = i * c.Width + i * 5 - c.Width
            End If
            c.Name = CountOrArrayOfNames(i - 1)
            If IsArray(Captions) Then
                c.Caption = Captions(i - 1)
            Else
                On Error Resume Next
                c.Caption = CountOrArrayOfNames(i - 1)
                If c.Caption = "" Then c.Caption = c.Name
                On Error GoTo 0
            End If
        Next
    End If
End Sub

Sub AddMultipleControls(ControlTypes As Variant, count As Long, Optional Vertical As Boolean = True, Optional form As Object = Nothing)
    '#INCLUDE AddFormControls
    '#INCLUDE ActiveModule
    Dim i As Long
    For i = 1 To UBound(ControlTypes) + 1
        If Vertical Then
            AddFormControls CStr(ControlTypes(i - 1)), count, , Vertical, i * 60 - 50, form
        Else
            AddFormControls CStr(ControlTypes(i - 1)), count, , Vertical, i * 20 - 20, form
        End If
    Next
    Dim c As MSForms.control
    On Error Resume Next
    If form Is Nothing Then
        For Each c In ActiveModule.Designer.Controls
            If Not TypeName(c) Like "TextBox" Then c.AutoSize = True
        Next
    Else
        For Each c In form.Controls
            If Not TypeName(c) Like "TextBox" Then c.AutoSize = True
        Next
    End If
End Sub

Sub EditObjectProperties(obj As Variant, PropertyArguement As Variant)
    Rem EditObjectProperties SelectedControl, Array("left",0,"top",0)
    Rem For Each c In SelectedControls: EditObjectProperties c, Array("left",0,"top",0): Next
Rem for i=1 to SelectedControls.count: EditObjectProperties activemodule.Designer.controls(SelectedControls(i).name),Array("left",0,"top",0): next
'#INCLUDE SelectedControl
'#INCLUDE SelectedControls
'#INCLUDE ActiveModule
Dim i As Long
Do While i < UBound(PropertyArguement)
CallByName obj, PropertyArguement(i), VbLet, _
        IIf(IsNumeric(PropertyArguement(i + 1)), _
            CLng(PropertyArguement(i + 1)), _
            PropertyArguement(i + 1))
i = i + 2
Loop
End Sub

Sub EditObjectsProperty(obj As Collection, objProperty As String, Args As Variant)
    If obj.count <> UBound(Args) + 1 Then
        MsgBox "Not selected controls count <> arguements count"
        Exit Sub
    End If
    Dim ArgItem
    Dim i As Long
    i = obj.count
    Dim element As Variant
    For Each element In obj
        CallByName element, objProperty, VbLet, _
                   IIf(IsNumeric(Args(i - 1)), _
                       CLng(Args(i - 1)), _
                       Args(i - 1))
        i = i - 1
    Next
End Sub

Sub RenameControlAndCode(Optional ctr As MSForms.control)
    '#INCLUDE InStrExact
    '#INCLUDE SelectedControl
    '#INCLUDE SelectedControls
    '#INCLUDE ActiveModule
    '#INCLUDE InputboxString
    If ctr Is Nothing Then
        If SelectedControls.count = 1 Then Set ctr = SelectedControl
        If ctr Is Nothing Then
            MsgBox "No control passed as arguement or no 1 control selected in designer"
            Exit Sub
        End If
    End If
    Dim Module As VBComponent: Set Module = ActiveModule
    If Module.Type <> vbext_ct_MSForm Then Exit Sub
    Dim OldName As String: OldName = ctr.Name
    Dim NewName As String: NewName = InputboxString
    If NewName = "" Then Exit Sub
    ctr.Name = NewName
    Dim CountOfLines As Long: CountOfLines = Module.CodeModule.CountOfLines
    If CountOfLines = 0 Then Exit Sub
    Dim strLine As String
    Dim i As Long
    Rem @TODO this part is wrong
    For i = 1 To CountOfLines
        strLine = Module.CodeModule.Lines(i, 1)
        If InStr(1, strLine, " " & OldName & "_") > 0 Then
            If InStrExact(1, strLine, OldName & "_") > 0 Then
                Module.CodeModule.ReplaceLine (i), Replace(strLine, OldName, NewName & "_")
            End If
        End If
    Next
End Sub

Sub SortControlsHorizontally()
    '#INCLUDE SortControls
    SortControls False
End Sub

Sub SortControlsVertivally()
    '#INCLUDE SortControls
    SortControls True
End Sub

Sub SortControls(Optional SortVertically As Boolean = True)
    Rem call from immediate window while looking at userform
    '#INCLUDE SelectedControls
    '#INCLUDE ActiveModule
    '#INCLUDE SortCollection
    Dim Module As VBComponent
    Set Module = ActiveModule
    If Module.Type <> vbext_ct_MSForm Then Exit Sub
    Dim ctr As MSForms.control
    Dim coll As New Collection
    Dim lastTop As Long
    Dim lastLeft As Long
    Dim element As Variant
    For Each element In SelectedControls
        coll.Add element.Name
    Next
    Set coll = SortCollection(coll)
    lastTop = 2000
    For Each element In coll
        If Module.Designer.Controls(element).top < lastTop Then lastTop = Module.Designer.Controls(element).top
        If Module.Designer.Controls(element).left < lastLeft Then lastLeft = Module.Designer.Controls(element).left
    Next
    For Each element In coll
        If SortVertically = True Then
            lastTop = lastTop + Module.Designer.Controls(element).Height + 6
        Else
            lastLeft = lastLeft + Module.Designer.Controls(element).Width + 6
        End If
        Module.Designer.Controls(element).top = lastTop
        Module.Designer.Controls(element).left = lastLeft
    Next
End Sub

Sub CopyControlProperties(Optional control As MSForms.control)
    '#INCLUDE SelectedControl
    '#INCLUDE CreateOrSetSheet
    '#INCLUDE Min
    If control Is Nothing Then Set control = SelectedControl
    Dim ws As Worksheet: Set ws = CreateOrSetSheet("CopyControlProperties", ThisWorkbook)
    Dim PropertiesArray As Variant
    PropertiesArray = Array("Accelerator", "Alignment", "AutoSize", "AutoTab", "BackColor", "BackStyle", "BorderColor", "BorderStyle", "BoundColumn", _
                            "Caption", "Children", "columnCount", "ColumnHeads", "ColumnWidths", "ControlSource", "ControlTipText", "Cycle", "DrawBuffer", "Enabled", "EnterKeyBehavior", "Expanded", _
                            "FirstSibling", "FontBold", "FontSize", "ForeColor", "FullPath", "GroupName", "Height", "HelpContextID", "KeepScrollBarsVisible", "LargeChange", "LastSibling", "LineStyle", "ListRows", "Locked", _
                            "Max", "MaxLength", "Min", "MouseIcon", "MousePointer", "MultiLine", "MultiSelect", "Next", "Nodes", "Orientation", _
                            "Parent", "PasswordChar", "PathSeparator", "Picture", "PictureAlignment", "PictureSizeMode", "PictureTiling", "Previous", "RightToLeft", "Root", "RowSource", _
                            "ScrollBars", "ScrollHeight", "ScrollLeft", "ScrollTop", "ScrollWidth", "Selected", "SelectedItem", "ShowModal", "SmallChange", "Sorted", "SpecialEffect", "StartUpPosition", _
                            "Style", "Tag", "Text", "TextColumn", "TripleState", "WhatsThisHelp", "Width", "Zoom")
    If ws.Range("A1") = "" Then ws.Range("A1").RESIZE(UBound(PropertiesArray) + 1) = WorksheetFunction.Transpose(PropertiesArray)
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.RESIZE(, 1)
    Dim property As Range
    On Error Resume Next
    For Each property In PropertiesRange
        property.OFFSET(0, 1) = CallByName(control, property.Value, VbGet)
    Next
End Sub

Sub PasteControlProperties(Optional Controls As Collection)
    '#INCLUDE CopyControlProperties
    '#INCLUDE SelectedControls
    Dim control As MSForms.control
    If Controls Is Nothing Then Set Controls = SelectedControls
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("CopyControlProperties")
    If ws.Columns(2).SpecialCells(xlCellTypeConstants).count = 0 Then
        MsgBox "You haven't saved properties before"
        Exit Sub
    End If
    Dim PropertiesRange As Range: Set PropertiesRange = ws.Range("A1").CurrentRegion.RESIZE(, 1)
    Dim property As Range
    On Error Resume Next
    For Each control In Controls
        For Each property In PropertiesRange
            CallByName control, property.Value, VbLet, property.OFFSET(0, 1).Value
        Next
    Next
End Sub

Function SelectedControl() As MSForms.control
    '#INCLUDE SelectedControls
    '#INCLUDE ActiveModule
    Dim Module As VBComponent
    Set Module = ActiveModule
    If SelectedControls.count = 1 Then
        Dim ctl    As control
        For Each ctl In ActiveModule.Designer.SELECTED
            Set SelectedControl = ctl
            Exit Function
        Next ctl
    End If
End Function

Function SelectedControls() As Collection
    '#INCLUDE ActiveModule
    Dim ctl    As control
    Dim out As New Collection
    Dim Module As VBComponent
    Set Module = ActiveModule
    For Each ctl In Module.Designer.SELECTED
        out.Add ctl
    Next ctl
    Set SelectedControls = out
    Set out = Nothing
End Function

Sub RemoveControlsCaptions()
    '#INCLUDE SelectedControls
    Dim c As MSForms.control
    For Each c In SelectedControls
        c.Caption = ""
    Next
End Sub

Function SelectedFrameControls() As Collection
    '#INCLUDE ActiveModule
    Dim ctl    As control, c As control
    Dim out As New Collection
    Dim Module As VBComponent
    Set Module = ActiveModule
    For Each ctl In Module.Designer.SELECTED
        For Each c In ctl.Controls
            out.Add c
        Next
    Next ctl
    Set SelectedFrameControls = out
    Set out = Nothing
End Function

Function SelectedFrameControl() As MSForms.control
    '#INCLUDE ActiveModule
    Dim ctl    As control, c As control
    Dim out As New Collection
    Dim Module As VBComponent
    Set Module = ActiveModule
    For Each ctl In Module.Designer.SELECTED
        For Each c In ctl.Controls
            out.Add c
        Next
    Next ctl
    If out.count = 0 Then Exit Function
    Set SelectedFrameControl = out(1)
End Function

Sub SelectListboxItems(lBox As MSForms.ListBox, FindMe As Variant, Optional ByIndex As Boolean)
    Dim i As Long
    Select Case TypeName(FindMe)
        Case Is = "String", "Long", "Integer"
            For i = 0 To lBox.ListCount - 1
                If lBox.list(i) = CStr(FindMe) Then
                    lBox.SELECTED(i) = True
                    DoEvents
                    If lBox.multiSelect = fmMultiSelectSingle Then Exit Sub
                End If
            Next
        Case Else
            Dim el As Variant
            If ByIndex Then
                For Each el In FindMe
                    lBox.SELECTED(el) = True
                Next
            Else
                For Each el In FindMe
                    For i = 0 To lBox.ListCount - 1
                        If lBox.list(i) = el Then
                            lBox.SELECTED(i) = True
                            DoEvents
                        End If
                    Next
                Next
            End If
    End Select
End Sub

Sub CreateListboxHeader(body As MSForms.ListBox, header As MSForms.ListBox, arrHeaders)
    '#INCLUDE ArrayDimensions
    header.Width = body.Width
    Dim i As Long
    header.columnCount = body.columnCount
    header.ColumnWidths = body.ColumnWidths
    header.clear
    header.AddItem
    If ArrayDimensions(arrHeaders) = 1 Then
        For i = 0 To UBound(arrHeaders)
            header.list(0, i) = arrHeaders(i)
        Next i
    Else
        For i = 1 To UBound(arrHeaders, 2)
            header.list(0, i - 1) = arrHeaders(1, i)
        Next i
    End If
    body.ZOrder (1)
    header.ZOrder (0)
    header.SpecialEffect = fmSpecialEffectFlat
    header.BackColor = RGB(200, 200, 200)
    header.Height = 15
    header.Width = body.Width
    header.left = body.left
    header.top = body.top - header.Height - 1
    header.Font.Bold = True
    header.Font.Name = "Comic Sans MS"
    header.Font.Size = 9
End Sub

Sub SavePosition(form As Object)
    SaveSetting "My Settings Folder", form.Name, "Left Position", form.left
    SaveSetting "My Settings Folder", form.Name, "Top Position", form.top
End Sub

Sub LoadPosition(form As Object)
    If GetSetting("My Settings Folder", form.Name, "Left Position") = "" _
                                                                      And GetSetting("My Settings Folder", form.Name, "Top Position") = "" Then
        form.StartUpPosition = 1
    Else
        form.left = GetSetting("My Settings Folder", form.Name, "Left Position")
        form.top = GetSetting("My Settings Folder", form.Name, "Top Position")
    End If
End Sub

Rem
Sub ResizeUserformToFitControls(form As Object)
    form.Width = 0
    form.Height = 0
    Dim ctr As MSForms.control
    Dim myWidth
    myWidth = form.InsideWidth
    Dim myHeight
    myHeight = form.InsideHeight
    For Each ctr In form.Controls
        If ctr.visible = True Then
            If ctr.left + ctr.Width > myWidth Then myWidth = ctr.left + ctr.Width
            If ctr.top + ctr.Height > myHeight Then myHeight = ctr.top + ctr.Height
        End If
    Next
    form.Width = myWidth + form.Width - form.InsideWidth + 10
    form.Height = myHeight + form.Height - form.InsideHeight + 10
End Sub

Function whichOption(Frame As Variant, controlType As String) As Variant
    Dim subControl As MSForms.control
    Dim out As New Collection
    Dim control As MSForms.control
    For Each control In Frame.Controls
        If UCase(TypeName(control)) = UCase("Frame") Then
            If UCase(TypeName(control)) = UCase(controlType) Then
                If control.Value = True Then
                    out.Add control
                End If
            End If
        End If
    Next
    If out.count = 1 Then
        whichOption = out(1)
    ElseIf out.count > 1 Then
        Set whichOption = out
    End If
End Function

Rem Control
Public Sub flashControl(ctr As MSForms.control, blinkCount As Integer)
    Rem if blinkCount = odd then the control will become hidden
    Dim lngTime As Long
    Dim i As Integer
    If blinkCount Mod 2 <> 0 Then blinkCount = blinkCount + 1
    For i = 1 To blinkCount * 2
        lngTime = getTickCount
        If ctr.visible = True Then
            ctr.visible = False
        Else
            ctr.visible = True
        End If
        DoEvents
        Do While getTickCount - lngTime < 200
        Loop
    Next
End Sub

Public Function TextOfControl(c As control) As Variant
    Rem Text of Textbox, Selection of Combobox, Selected items (2d) of Listbox
    '#INCLUDE ListboxSelectedValues
    '#INCLUDE CollectionToArray
    Dim out As New Collection
    If TypeName(c) = "TextBox" Then
        If c.SelLength = 0 Then
            TextOfControl = c.TEXT
        Else
            TextOfControl = c.SelText
        End If
    ElseIf TypeName(c) = "ComboBox" Then
        If c.Style < 2 Then
            TextOfControl = c.TEXT
        Else
            TextOfControl = ""
        End If
    ElseIf TypeName(c) = "ListBox" Then
        Set out = ListboxSelectedValues(c)
        If out.count > 0 Then
            TextOfControl = CollectionToArray(out)
        Else
            TextOfControl = ""
        End If
    End If
End Function

Rem Listbox
Public Function ListboxContains(lBox As MSForms.ListBox, str As String, _
                                Optional ColumnIndexZeroBased As Long = -1, _
                                Optional CaseSensitive As Boolean = False) As Boolean
    Dim i      As Long
    Dim n      As Long
    Dim sTemp  As String
    If ColumnIndexZeroBased > lBox.columnCount - 1 Or ColumnIndexZeroBased < 0 Then
        ColumnIndexZeroBased = -1
    End If
    n = lBox.ListCount
    If ColumnIndexZeroBased <> -1 Then
        For i = n - 1 To 0 Step -1
            If CaseSensitive = True Then
                sTemp = lBox.list(i, ColumnIndexZeroBased)
            Else
                str = LCase(str)
                sTemp = LCase(lBox.list(i, ColumnIndexZeroBased))
            End If
            If InStr(1, sTemp, str) > 0 Then
                ListboxContains = True
                Exit Function
            End If
        Next i
    Else
        Dim columnCount As Long
        n = lBox.ListCount
        For i = n - 1 To 0 Step -1
            For columnCount = 0 To lBox.columnCount - 1
                If CaseSensitive = True Then
                    sTemp = lBox.list(i, columnCount)
                Else
                    str = LCase(str)
                    sTemp = LCase(lBox.list(i, columnCount))
                End If
                If InStr(1, sTemp, str) > 0 Then
                    ListboxContains = True
                    Exit Function
                End If
            Next columnCount
        Next i
    End If
End Function

Public Sub FilterListboxByColumn(lBox As MSForms.ListBox, str As String, _
                                 Optional ColumnIndexZeroBased As Long = -1, Optional CaseSensitive As Boolean = False)
    Dim i               As Long
    Dim n               As Long
    Dim sTemp           As String
    If ColumnIndexZeroBased > lBox.columnCount - 1 Or ColumnIndexZeroBased < 0 Then
        ColumnIndexZeroBased = -1
    End If
    n = lBox.ListCount
    If ColumnIndexZeroBased <> -1 Then
        For i = n - 1 To 0 Step -1
            If CaseSensitive = True Then
                sTemp = lBox.list(i, ColumnIndexZeroBased)
            Else
                str = LCase(str)
                sTemp = LCase(lBox.list(i, ColumnIndexZeroBased))
            End If
            If InStr(1, sTemp, str) = 0 Then
                lBox.RemoveItem (i)
            End If
        Next i
    Else
        Dim columnCount As Long
        n = lBox.ListCount
        For i = n - 1 To 0 Step -1
            For columnCount = 0 To lBox.columnCount - 1
                If CaseSensitive = True Then
                    sTemp = lBox.list(i, columnCount)
                Else
                    str = LCase(str)
                    sTemp = LCase(lBox.list(i, columnCount))
                End If
                If InStr(1, sTemp, str) > 0 Then
                Else
                    If columnCount = lBox.columnCount - 1 Then
                        lBox.RemoveItem (i)
                    End If
                End If
            Next columnCount
        Next i
    End If
End Sub

Public Sub SortListboxOnColumn(lBox As MSForms.ListBox, OnColumn As Long)
    Dim vntData As Variant
    Dim vntTempItem As Variant
    Dim lngOuterIndex As Long
    Dim lngInnerIndex As Long
    Dim lngSubItemIndex As Long
    vntData = lBox.list
    For lngOuterIndex = LBound(vntData, 1) To UBound(vntData, 1) - 1
        For lngInnerIndex = lngOuterIndex + 1 To UBound(vntData, 1)
            If vntData(lngOuterIndex, OnColumn) > vntData(lngInnerIndex, OnColumn) Then
                For lngSubItemIndex = 0 To lBox.columnCount - 1
                    vntTempItem = vntData(lngOuterIndex, lngSubItemIndex)
                    vntData(lngOuterIndex, lngSubItemIndex) = vntData(lngInnerIndex, lngSubItemIndex)
                    vntData(lngInnerIndex, lngSubItemIndex) = vntTempItem
                Next
            End If
        Next lngInnerIndex
    Next lngOuterIndex
    lBox.clear
    lBox.list = vntData
End Sub

Function ListboxSelectedIndexes(lBox As MSForms.ListBox) As Collection
    Dim i As Long
    Dim SelectedIndexes As Collection
    Set SelectedIndexes = New Collection
    If lBox.ListCount > 0 Then
        For i = 0 To lBox.ListCount - 1
            If lBox.SELECTED(i) Then SelectedIndexes.Add i
        Next i
    End If
    Set ListboxSelectedIndexes = SelectedIndexes
End Function

Function ListboxSelectedValues(listboxCollection As Variant) As Collection
    Dim i As Long
    Dim listItem As Long
    Dim selectedCollection As Collection
    Set selectedCollection = New Collection
    Dim listboxCount As Long
    If TypeName(listboxCollection) = "Collection" Then
        For listboxCount = 1 To listboxCollection.count
            If listboxCollection(listboxCount).ListCount > 0 Then
                For listItem = 0 To listboxCollection(listboxCount).ListCount - 1
                    If listboxCollection(listboxCount).SELECTED(listItem) Then
                        selectedCollection.Add CStr(listboxCollection(listboxCount).list(listItem, listboxCollection(listboxCount).BoundColumn - 1))
                    End If
                Next listItem
            End If
        Next listboxCount
    Else
        If listboxCollection.ListCount > 0 Then
            For i = 0 To listboxCollection.ListCount - 1
                If listboxCollection.SELECTED(i) Then
                    selectedCollection.Add listboxCollection.list(i, listboxCollection.BoundColumn - 1)
                End If
            Next i
        End If
    End If
    Set ListboxSelectedValues = selectedCollection
End Function

Function ListboxSelectedCount(listboxCollection As Variant) As Long
    Dim i As Long
    Dim listItem As Long
    Dim selectedCollection As Collection
    Set selectedCollection = New Collection
    Dim listboxCount As Long
    Dim SelectedCount As Long
    If TypeName(listboxCollection) = "Collection" Then
        For listboxCount = 1 To listboxCollection.count
            If listboxCollection(listboxCount).ListCount > 0 Then
                For listItem = 0 To listboxCollection(listboxCount).ListCount - 1
                    If listboxCollection(listboxCount).SELECTED(listItem) = True Then
                        SelectedCount = SelectedCount + 1
                    End If
                Next listItem
            End If
        Next listboxCount
    Else
        If listboxCollection.ListCount > 0 Then
            For i = 0 To listboxCollection.ListCount - 1
                If listboxCollection.SELECTED(i) = True Then
                    SelectedCount = SelectedCount + 1
                End If
            Next i
        End If
    End If
    ListboxSelectedCount = SelectedCount
End Function

Rem var
Public Sub ShowUserform(FormName As String)
    '#INCLUDE IsLoaded
    Dim frm As Object
    If IsLoaded(FormName) = True Then
        For Each frm In VBA.UserForms
            If frm.Name = FormName Then
                frm.Show
                Exit Sub
            End If
        Next frm
    Else
        Dim oUserForm As Object
        On Error GoTo err
        Set oUserForm = UserForms.Add(FormName)
        oUserForm.Show (vbModeless)
        Exit Sub
    End If
err:
    Select Case err.Number
        Case 424:
            MsgBox "The Userform with the name " & FormName & " was not found.", vbExclamation, "Load userforn by name"
        Case Else:
            MsgBox err.Number & ": " & err.Description, vbCritical, "Load userforn by name"
    End Select
End Sub

Sub ResizeControlColumns(ListboxOrCombobox As MSForms.control, Optional ResizeControl As Boolean, Optional ResizeListbox As Boolean)
    '#INCLUDE CreateOrSetSheet
    If ListboxOrCombobox.ListCount = 0 Then Exit Sub
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("ListboxColumnwidth", ThisWorkbook)
    Dim rng As Range
    Set rng = ws.Range("A1")
    Set rng = rng.RESIZE(UBound(ListboxOrCombobox.list) + 1, ListboxOrCombobox.columnCount)
    rng = ListboxOrCombobox.list
    rng.Font.Name = ListboxOrCombobox.Font.Name
    rng.Font.Size = ListboxOrCombobox.Font.Size + 2
    rng.Columns.AutoFit
    Dim sWidth As String
    Dim vR() As Variant
    Dim n As Integer
    Dim cell As Range
    For Each cell In rng.RESIZE(1)
        n = n + 1
        ReDim Preserve vR(1 To n)
        vR(n) = cell.EntireColumn.Width
    Next cell
    sWidth = Join(vR, ";")
    With ListboxOrCombobox
        .ColumnWidths = sWidth
        .BorderStyle = fmBorderStyleSingle
    End With
    Application.DisplayAlerts = False
    ws.Delete
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    If ResizeListbox = False Then Exit Sub
    Dim w As Long
    Dim i As Long
    For i = LBound(vR) To UBound(vR)
        w = w + vR(i)
    Next
    DoEvents
    ListboxOrCombobox.Width = w + 10
End Sub

Sub DeselectListbox(lBox As MSForms.ListBox)
    If lBox.ListCount <> 0 Then
        Dim i As Long
        For i = 0 To lBox.ListCount - 1
            lBox.SELECTED(i) = False
        Next i
    End If
End Sub

Public Sub SelectDeselectAll(lBox As MSForms.ListBox, Optional toSelect As Boolean)
    If lBox.ListCount = 0 Then Exit Sub
    Dim i As Long
    For i = 0 To lBox.ListCount - 1
        lBox.SELECTED(i) = toSelect
    Next
End Sub

Sub SelectControItemsByFilter(lBox As MSForms.ListBox, criteria As String)
    '#INCLUDE SelectDeselectAll
    SelectDeselectAll lBox
    If criteria = "" Then Exit Sub
    Dim i As Long
    For i = 0 To lBox.ListCount - 1
        If UCase(lBox.list(i, 1)) Like "*" & UCase(criteria) & "*" Then
            lBox.SELECTED(i) = True
        End If
    Next i
End Sub



'F_VBE	1

Rem @Folder VBE
Function HasProject(wb As Workbook) As Boolean
    Dim WbProjComp As Object
    On Error Resume Next
    Set WbProjComp = wb.VBProject.VBComponents
    If Not WbProjComp Is Nothing Then HasProject = True
End Function

Public Function ActiveProjName() As String
    ActiveProjName = Mid(Application.VBE.ActiveVBProject.fileName, InStrRev(Application.VBE.ActiveVBProject.fileName, "\") + 1)
End Function

Function ConfirmInstallAddin() As Boolean
    Dim eai As Excel.AddIn
    Dim fso As Object
    Dim oXL As Object
    Dim response As Integer
    Dim thisAddInDate As Date
    Dim thisFileLen As Long
    Dim existingAddInName As String
    Dim existingAddinDate As Date
    Dim existingFileLen As Long
    Dim ai As AddIn
    Dim msg As String
    Dim toInstall As Integer
    Dim copiedWbName As String
    Dim desiredAddInName As String: desiredAddInName = PROJECT_NAME & ".xlam"
    Dim deleteOld As Boolean: deleteOld = True
    On Error GoTo ErrorHandler
    thisAddInDate = FileDateTime(ThisWorkbook.FullName)
    thisFileLen = FileLen(ThisWorkbook.FullName)
    existingAddInName = ""
    For Each ai In Application.AddIns
        If ai.title = PROJECT_NAME Then
            existingAddInName = ai.FullName
            Exit For
        End If
    Next ai
    If existingAddInName <> "" Then
        existingAddinDate = FileDateTime(existingAddInName)
        existingFileLen = FileLen(existingAddInName)
        If thisAddInDate > existingAddinDate And thisFileLen <> existingFileLen Then
            msg = "Do you want to update " & desiredAddInName & " ?"
        ElseIf thisAddInDate <= existingAddinDate And thisFileLen <> existingFileLen Then
            msg = "Do you want to update " & desiredAddInName & " ?" & vbNewLine & _
                  "The file you opened is not newer than the installed file."
        Else
            Exit Function
        End If
    Else
        msg = "Do you want to install " & desiredAddInName & " ?"
        existingAddInName = Application.UserLibraryPath & desiredAddInName
    End If
    toInstall = MsgBox(msg, vbYesNo)
    If toInstall = vbYes Then ConfirmInstallAddin = True
ErrorHandler:
    MsgBox "Error #" & _
           err.Number & _
           vbCrLf & _
           "Please, let the Author know.", vbInformation
End Function

Public Sub AddinCreate()
    '#INCLUDE ConfirmInstallAddin
    If Not ConfirmInstallAddin Then Exit Sub
    Dim AddFolder As String
    On Error GoTo InstallationAdd_Err
    AddFolder = Replace(Application.UserLibraryPath & "\", "\\", "\")
    If Dir(AddFolder, vbDirectory) = vbNullString Then
        Call MsgBox("Unfortunately, the program cannot install the add-in on this computer.")
        Exit Sub
    End If
    Dim addinsPath As String
    addinsPath = AddFolder
    Dim partName As String
    partName = Right(ThisWorkbook.FullName, Len(ThisWorkbook.FullName) - InStrRev(ThisWorkbook.FullName, "\"))
    partName = left(partName, InStr(1, partName, ".") - 1)
    If Dir(addinsPath & partName & ".xlam") <> "" Then AddIns(partName).Installed = False
    Application.EnableEvents = False
    Application.DisplayAlerts = False
    If Workbooks.count = 1 Then Workbooks.Add
    ThisWorkbook.SaveAs addinsPath & partName & ".xlam", FileFormat:=xlOpenXMLAddIn
    AddIns.Add fileName:=addinsPath & partName & ".xlam"
    AddIns(partName).Installed = True
NormalExit:
    Application.EnableEvents = True
    Application.DisplayAlerts = True
    Call MsgBox("The program is installed successfully!", vbInformation, _
                "Installing the add-in:" & partName)
    ThisWorkbook.Close False
    Exit Sub
InstallationAdd_Err:
    Application.EnableEvents = True
    Application.DisplayAlerts = True
    If err.Number = 1004 Then
        MsgBox "To install the add-in, please close this file and run it again.", _
               64, "Installation"
    Else
        MsgBox err.Description & vbCrLf & " Addin installation failed "
    End If
End Sub

Function IsMissingEndIf(TargetWorkbook As Workbook) As Boolean
    '#INCLUDE dp
    Dim s As String
    s = "  If something then" & vbNewLine
    s = s & "  End If 'comm" & vbNewLine
    Dim var, countIf, coundEndIf
    var = Filter(Split(s, vbNewLine), "If")
    countIf = Filter(var, "End If", False)
    countIf = Filter(countIf, "ElseIf", False)
    dp "countif " & UBound(countIf)
    dp countIf
    countEndIf = Filter(var, "End If")
    dp "countendif " & UBound(countEndIf)
    dp countEndIf
    IsMissingEndIf = (UBound(countIf) = UBound(countEndIf))
End Function

Public Function RegexCountMatches(TEXT As String, Pattern As String) As Long
    Dim RE As New RegExp
    RE.Pattern = Pattern
    RE.Global = True
    RE.IgnoreCase = True
    RE.MultiLine = False
    Dim Matches As matchCollection
    Set Matches = RE.Execute(TEXT)
    RegexCountMatches = Matches.count
End Function

Sub VbeSetFont()
    Application.SendKeys "%TO+{TAB}{RIGHT}{TAB}{TAB}{TAB}{TAB}{TAB}{TAB}"
    Application.SendKeys "Consolas {(}Greek{)}"
    Application.SendKeys "{ENTER}"
End Sub

Sub ClearComponent(vbComp As VBComponent)
    vbComp.CodeModule.DeleteLines 1, vbComp.CodeModule.CountOfLines
End Sub

Function GetCompText(vbComp As VBComponent) As String
    Dim CodeMod As CodeModule
    Set CodeMod = vbComp.CodeModule
    If CodeMod.CountOfLines = 0 Then GetCompText = "": Exit Function
    GetCompText = CodeMod.Lines(1, CodeMod.CountOfLines)
End Function

Function getModuleName(Module As VBComponent) As String
    '#INCLUDE GetSheetByCodeName
    '#INCLUDE WorkbookOfModule
    If Module.Type = vbext_ct_Document Then
        If Module.Name = "ThisWorkbook" Then
            getModuleName = Module.Name
        Else
            getModuleName = GetSheetByCodeName(WorkbookOfModule(Module), Module.Name).Name
        End If
    Else
        getModuleName = Module.Name
    End If
End Function

Sub GoToModule(Module As VBComponent)
    Application.VBE.MainWindow.visible = True
    Module.CodeModule.CodePane.Window.SetFocus
    Module.CodeModule.CodePane.SetSelection 1, 1, 1, 1
End Sub

Sub EnumToCase()
    Rem point inside enum before calling this from immediate window or vbe menu button
    '#INCLUDE ActiveEnumName
    '#INCLUDE ActiveEnumStartLine
    '#INCLUDE ActiveEnumEndLine
    '#INCLUDE ActiveModule
    '#INCLUDE CLIP
    Dim enumName As String
    enumName = ActiveEnumName
    Dim arr
    arr = Split(ActiveModule.CodeModule.Lines(ActiveEnumStartLine + 1, ActiveEnumEndLine - ActiveEnumStartLine - 1), vbNewLine)
    Dim out As String
    out = "Select case Variable "
    Dim Code As String
    Code = out
    Dim i As Long
    For i = 0 To UBound(arr)
        If InStr(1, arr(i), "=") > 0 Then arr(i) = Split(arr(i), "=")(0)
        arr(i) = Trim(arr(i))
    Next
    For i = 0 To UBound(arr)
        If arr(i) <> "" Then
            out = "    Case is = " & enumName & "." & arr(i) & vbNewLine
            Code = IIf(Code = "", out, Code & vbNewLine & out)
        End If
    Next
    Code = Code & vbNewLine & "End Select"
    Debug.Print Code
    CLIP Code
End Sub

Function ActiveEnumName() As String
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE ActiveModule
    Dim i As Long
    Dim enumName As String
    Dim line As String
    Dim cp As CodeModule
    Set cp = ActiveModule.CodeModule
    For i = CodePaneSelectionStartLine To 1 Step -1
        line = cp.Lines(i, 1)
        If InStr(1, line, "Enum ") > 0 Then
            enumName = Trim(Split(line, " ")(1))
            ActiveEnumName = enumName
            Exit Function
        End If
    Next
End Function

Function ActiveEnumStartLine() As Long
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE ActiveModule
    Dim i As Long
    Dim enumName As String
    Dim line As String
    Dim cp As CodeModule
    Set cp = ActiveModule.CodeModule
    For i = CodePaneSelectionStartLine To 1 Step -1
        line = cp.Lines(i, 1)
        If InStr(1, line, "Enum ") > 0 Then
            ActiveEnumStartLine = i
            Exit Function
        End If
    Next
End Function

Function ActiveEnumEndLine() As Long
    '#INCLUDE CodePaneSelectionStartLine
    '#INCLUDE ActiveModule
    Dim i As Long
    Dim enumName As String
    Dim line As String
    Dim cp As CodeModule
    Set cp = ActiveModule.CodeModule
    For i = CodePaneSelectionStartLine To cp.CountOfLines
        line = cp.Lines(i, 1)
        If InStr(1, line, "End Enum") > 0 Then
            ActiveEnumEndLine = i
            Exit Function
        End If
    Next
End Function

Sub SideBySide(Optional Module1 As VBComponent, _
               Optional Module2 As VBComponent)
    '#INCLUDE ActiveModule
    If Module1 Is Nothing Then Set Module1 = ActiveModule
    With Module1.CodeModule.CodePane.Window
        .Width = 800
        .left = 1
        .top = 1
        .Height = 1000
        .visible = True
        .WindowState = vbext_ws_Normal
        .SetFocus
    End With
    If Module1.Type = vbext_ct_MSForm Then
        With Module1.DesignerWindow
            .Width = 800
            .left = 800
            .top = 1
            .Height = 1000
            .visible = True
            .WindowState = vbext_ws_Normal
            Module1.DesignerWindow.SetFocus
        End With
    ElseIf Not Module2 Is Nothing Then
        With Module2.CodeModule.CodePane.Window
            .Width = 800
            .left = 800
            .top = 1
            .Height = 1000
            .visible = True
            .WindowState = vbext_ws_Normal
            .SetFocus
        End With
    End If
End Sub

Rem  Procedure : DuplicateUserForm
Rem  Author    : Daniel Pineault, CARDA Consultants Inc.
Rem  Website   : http://www.cardaconsultants.com
Rem  Purpose   : Duplicate an existing Userform
Rem  Copyright : The following is release as Attribution-ShareAlike 4.0 International
Rem              (CC BY-SA 4.0) - https://creativecommons.org/licenses/by-sa/4.0/
Rem  Reqrem d Refs: None required
Rem
Rem  Input Variables:
Rem  ~~~~~~~~~~~~~~~~
Rem  sUsrFrmName           : (string) Name of the Userform to create a copy of
Rem  sNewUsrFrmName        : (string) Name to be given to the new copy
Rem  bActivateNewUserFrm   : (boolean) True => Activate/Set the focus of the VBE on the
Rem                                            New Userformonce created
Rem                                    False => Leave the VBE display unchanged
Rem
Rem  Usage:
Rem  ~~~~~~
Rem  Call DuplicateUserForm "UserForm1", "ChartOptions"
Rem    Returns -> True/False; True = Successfully duplication, False = Something went wrong
Rem
Rem  Revision History:
Rem  Rev       Date(yyyy-mm-dd)        Description
Rem  **************************************************************************************
Rem  1         2021-09-25              Initial Public Release
Public Function DuplicateUserForm(Optional sUsrFrmName As String, _
                                  Optional sNewUsrFrmName As String, _
                                  Optional bActivateNewUserFrm As Boolean = True) As Boolean
    '#INCLUDE ActiveModule
    If sUsrFrmName = "" Then
        If ActiveModule.Type <> vbext_ct_MSForm Then
            MsgBox "No Form name passed and active module not userform"
            Exit Function
        Else
            sUsrFrmName = ActiveModule.Name
        End If
    End If
    If sNewUsrFrmName = "" Then sNewUsrFrmName = sUsrFrmName & "_Copy"
    On Error GoTo Error_Handler
    Dim sNewUsrFrmFileName    As String
    sNewUsrFrmFileName = Environ("Temp") & "\" & sNewUsrFrmName & ".frm"
    ThisWorkbook.VBProject.VBComponents(sUsrFrmName).Name = sNewUsrFrmName
    ThisWorkbook.VBProject.VBComponents(sNewUsrFrmName).Export sNewUsrFrmFileName
    ThisWorkbook.VBProject.VBComponents(sNewUsrFrmName).Name = sUsrFrmName
    ThisWorkbook.VBProject.VBComponents.Import sNewUsrFrmFileName
    If Len(Dir(sNewUsrFrmFileName)) > 0 Then Kill Replace(sNewUsrFrmFileName, ".frm", ".*")
    If bActivateNewUserFrm = True Then ThisWorkbook.VBProject.VBComponents(sNewUsrFrmName).Activate
    DuplicateUserForm = True
Error_Handler_Exit:
    On Error Resume Next
    Exit Function
Error_Handler:
    MsgBox "The following error has occured" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: DuplicateUserForm" & vbCrLf & _
           "Error Description: " & err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occured!"
    Resume Error_Handler_Exit
End Function

Public Sub CopyProcedureFromThisWorkbook(Optional ProcedureName As String, Optional TargetWorkbook As Workbook)
    Rem for each element in Array("ActiveModule","ProcListArray","GetProcText"):CopyProcedureFromThisWorkbook cstr(element):next
    '#INCLUDE ProcListArray
    '#INCLUDE ActiveModule
    '#INCLUDE ActiveProcedure
    '#INCLUDE CreateOrSetModule
    '#INCLUDE GetModuleText
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveWorkbook
    If TargetWorkbook.Name = ThisWorkbook.Name Then Exit Sub
    Dim Module As VBComponent:         Set Module = CreateOrSetModule("vbArc", vbext_ct_StdModule, ActiveWorkbook)
    Dim ProcedureText As String:       ProcedureText = GetProcText(ModuleOfProcedure(ThisWorkbook, ProcedureName), ProcedureName)
    ProcedureName = IIf(InStr(1, ProcedureText, "Function " & ProcedureName) > 0, "Function ", "Sub ") & ProcedureName
    If InStr(1, GetModuleText(Module), ProcedureName, vbTextCompare) = 0 Then Module.CodeModule.AddFromString (ProcedureText)
End Sub

Public Sub CopyProcedures(ProcedureName As Variant, FromWorkbook As Workbook, TargetWorkbook As Workbook, Optional Overwrite As Boolean)
    '#INCLUDE UpdateProcedureCode
    '#INCLUDE LinkedProcs
    '#INCLUDE ProcedureExists
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE ActiveProcedure
    '#INCLUDE CreateOrSetModule
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    Dim Module As VBComponent
    Dim Code As String
    If ProcedureName = "" Then ProcedureName = ActiveProcedure
    If FromWorkbook Is Nothing Then Set FromWorkbook = ActiveCodepaneWorkbook
    Dim procedures As Collection: Set procedures = LinkedProcs(ProcedureName, FromWorkbook)
    On Error Resume Next
    procedures.Add ProcedureName, ProcedureName
    On Error GoTo 0
    Dim Procedure As Variant
    Dim FileFullName As String
    For Each Procedure In procedures
        Code = GetProcText(ModuleOfProcedure(FromWorkbook, CStr(Procedure)), CStr(Procedure))
        If ProcedureExists(CStr(Procedure), TargetWorkbook) = False Then
            Set Module = CreateOrSetModule("vbArcImports", vbext_ct_StdModule, TargetWorkbook)
            Module.CodeModule.AddFromString (Code)
        Else
            If Overwrite = True Then UpdateProcedureCode Procedure, Code, TargetWorkbook
        End If
    Next
End Sub

Function ProceduresOfWorkbook( _
         TargetWorkbook As Workbook, _
         Optional ExcludeDocument As Boolean = True, _
         Optional ExcludeClass As Boolean = True, _
         Optional ExcludeForm As Boolean = True) As Collection
    Dim Module As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim LineNum As Long
    Dim coll As New Collection
    Dim ProcedureName As String
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If ExcludeClass = True Then
            If Module.Type = vbext_ct_ClassModule Then GoTo Skip
        End If
        If ExcludeDocument = True Then
            If Module.Type = vbext_ct_Document Then GoTo Skip
        End If
        If ExcludeForm = True Then
            If Module.Type = vbext_ct_MSForm Then GoTo Skip
        End If
        With Module.CodeModule
            LineNum = .CountOfDeclarationLines + 1
            Do Until LineNum >= .CountOfLines
                ProcedureName = .ProcOfLine(LineNum, ProcKind)
                coll.Add ProcedureName
                LineNum = .ProcStartLine(ProcedureName, ProcKind) + .ProcCountLines(ProcedureName, ProcKind) + 1
            Loop
        End With
Skip:
    Next Module
    Set ProceduresOfWorkbook = coll
End Function

Function ProcedureExists( _
         ProcedureName As Variant, _
         FromWorkbook As Workbook) _
        As Boolean
    '#INCLUDE ProceduresOfWorkbook
    Dim AllProcedures As Collection: Set AllProcedures = ProceduresOfWorkbook(FromWorkbook)
    Dim Procedure As Variant
    For Each Procedure In AllProcedures
        If UCase(CStr(Procedure)) = UCase(ProcedureName) Then
            ProcedureExists = True
            Exit Function
        End If
    Next
End Function

Function ProcedureFirstLine(Module As VBComponent, procName As String) As Long
    '#INCLUDE InStrExact
    Dim n As Long
    Dim s As String
    Dim ProcKind As VBIDE.vbext_ProcKind
    For n = Module.CodeModule.ProcBodyLine(procName, ProcKind) + IIf(n = 0, 1, 0) To Module.CodeModule.CountOfLines
        s = Trim(Module.CodeModule.Lines(n, 1))
        If s = vbNullString Then
            Exit For
        ElseIf left(s, 1) = "'" Then
        ElseIf left(s, 3) = "Rem" Then
        ElseIf Right(Trim(Module.CodeModule.Lines(n - 1, 1)), 1) = "_" Then
        ElseIf Right(s, 1) = "_" Then
        ElseIf InStrExact(1, s, "Sub ") Then
        ElseIf InStrExact(1, s, "Function ") Then
        Else
            Exit For
        End If
    Next n
    ProcedureFirstLine = n
End Function

Public Function IsEditorInSync() As Boolean
    With Application.VBE
        IsEditorInSync = .ActiveVBProject Is _
                         .ActiveCodePane.CodeModule.parent.Collection.parent
    End With
End Function

Sub SyncVBAEditor()
    With Application.VBE
        If Not .ActiveCodePane Is Nothing Then
            Set .ActiveVBProject = .ActiveCodePane.CodeModule.parent.Collection.parent
        End If
    End With
End Sub

Public Function vbModule(ModuleName As String, Optional TargetWorkbook As Workbook) As VBComponent
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    On Error Resume Next
    Set vbModule = TargetWorkbook.VBProject.VBComponents(ModuleName)
End Function

Function ProcListArray(Module As VBComponent) As Variant
    Dim out As String
    Dim LineNum As Long
    Dim NumLines As Long
    Dim procName As String
    Dim ProcKind As VBIDE.vbext_ProcKind
    LineNum = Module.CodeModule.CountOfDeclarationLines + 1
    Do Until LineNum >= Module.CodeModule.CountOfLines
        procName = Module.CodeModule.ProcOfLine(LineNum, ProcKind)
        If out = vbNullString Then
            out = procName
        Else
            out = out & "," & procName
        End If
        LineNum = Module.CodeModule.ProcStartLine(procName, ProcKind) + Module.CodeModule.ProcCountLines(procName, ProcKind) + 1
    Loop
    ProcListArray = Split(out, ",")
End Function

Function ProcListCollection(Module As VBComponent) As Collection
    Dim coll As Collection: Set coll = New Collection
    Dim LineNum As Long, NumLines As Long
    Dim procName As String
    Dim ProcKind As VBIDE.vbext_ProcKind
    LineNum = Module.CodeModule.CountOfDeclarationLines + 1
    Do Until LineNum >= Module.CodeModule.CountOfLines
        procName = Module.CodeModule.ProcOfLine(LineNum, ProcKind)
        If InStr(1, procName, "_") = 0 Then coll.Add procName
        LineNum = Module.CodeModule.ProcStartLine(procName, ProcKind) + Module.CodeModule.ProcCountLines(procName, ProcKind) + 1
    Loop
    Set ProcListCollection = coll
End Function

Public Function ProcedureEndLine(Module As VBComponent, procName As String) As Long
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim startAt As Long
    Dim EndAt As Long
    Dim CountOf As Long
    startAt = Module.CodeModule.ProcStartLine(procName, ProcKind)
    EndAt = Module.CodeModule.ProcStartLine(procName, ProcKind) + Module.CodeModule.ProcCountLines(procName, ProcKind) - 1
    CountOf = Module.CodeModule.ProcCountLines(procName, ProcKind)
    ProcedureEndLine = EndAt
End Function

Public Function ProcedureStartLine(Module As VBComponent, ProcedureName As String) As Long
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim startAt As Long
    Dim EndAt As Long
    Dim CountOf As Long
    startAt = Module.CodeModule.ProcStartLine(ProcedureName, ProcKind)
    EndAt = Module.CodeModule.ProcStartLine(ProcedureName, ProcKind) + Module.CodeModule.ProcCountLines(ProcedureName, ProcKind) - 1
    CountOf = Module.CodeModule.ProcCountLines(ProcedureName, ProcKind)
    ProcedureStartLine = startAt
End Function

Sub DebugPrintVbeWindows()
    Dim wd As Window
    Dim i As Long
    For i = 1 To Application.VBE.Windows.count
        With Application.VBE.Windows(i)
            Debug.Print .Type & vbTab & .Caption
        End With
    Next
End Sub

Function vbeWindowProjectExplorer() As VBIDE.Window
    Dim i As Long
    For i = 1 To Application.VBE.Windows.count
        If Application.VBE.Windows(i).Caption Like "Project - *" Then
            Set vbeWindowProjectExplorer = Application.VBE.Windows(i)
        End If
    Next
End Function

Function vbeWindowProperties() As VBIDE.Window
    Dim i As Long
    For i = 1 To Application.VBE.Windows.count
        If Application.VBE.Windows(i).Caption Like "Properties - *" Then
            Set vbeWindowProperties = Application.VBE.Windows(i)
        End If
    Next
End Function

Function vbeWindowImmediate() As VBIDE.Window
    Set vbeWindowImmediate = Application.VBE.Windows("Immediate")
End Function

Function vbeWindowLocals() As VBIDE.Window
    Set vbeWindowLocals = Application.VBE.Windows("Locals")
End Function

Function vbeWindowWatches() As VBIDE.Window
    Set vbeWindowWatches = Application.VBE.Windows("Watches")
End Function

Function vbeWindowObjectBrowser() As VBIDE.Window
    Set vbeWindowObjectBrowser = Application.VBE.Windows("Object Browser")
End Function

Sub CloseVBEwindows()
    Dim i As Long
    For i = 1 To Application.VBE.Windows.count
        Select Case Application.VBE.Windows(i).Type
            Case 2 To 8
                Application.VBE.Windows(i).Close
        End Select
    Next
End Sub

Sub OpenVBEwindows()
    Dim i As Long
    For i = 1 To Application.VBE.Windows.count
        Select Case Application.VBE.Windows(i).Type
            Case 5 To 7
                Application.VBE.Windows(i).visible = True
        End Select
    Next
End Sub

Function ProcedureLines(Procedure As String, Module As VBComponent) As Collection
    Dim i As Long
    Dim out As New Collection
    For i = 1 To Module.CodeModule.CountOfLines
        If out.count = 0 Then
            If InStr(1, Module.CodeModule.Lines(i, 1), "Sub " & Procedure) > 0 Then out.Add i
            If InStr(1, Module.CodeModule.Lines(i, 1), "Function " & Procedure) > 0 Then out.Add i
        Else
            If InStr(1, Module.CodeModule.Lines(i, 1), "End Sub") > 0 Then
                out.Add i
                Exit For
            End If
            If InStr(1, Module.CodeModule.Lines(i, 1), "End Function") > 0 Then
                out.Add i
                Exit For
            End If
        End If
    Next
    out.Add out(2) - out(1) + 1
    Set ProcedureLines = out
    Debug.Print Procedure
    Debug.Print "Start line = " & out(1)
    Debug.Print "End line = " & out(2)
    Debug.Print "Count of lines = " & out(3)
    Set out = Nothing
End Function

Function ProtectedVBProject(ByVal wb As Workbook) As Boolean
    If wb.VBProject.Protection = 1 Then
        ProtectedVBProject = True
    Else
        ProtectedVBProject = False
    End If
End Function

Sub AddExtensibility(Optional TargetWorkbook As Workbook)
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    On Error Resume Next
    TargetWorkbook.VBProject.REFERENCES.AddFromGuid _
        GUID:="{0002E157-0000-0000-C000-000000000046}", _
        Major:=5, Minor:=3
    On Error GoTo 0
End Sub

Function ProcedureType(TargetWorkbook As Workbook, ProcedureName As String) As String
    '#INCLUDE GetProcText
    '#INCLUDE ModuleOfProcedure
    Dim ProcedureText As String:            ProcedureText = GetProcText(ModuleOfProcedure(TargetWorkbook, ProcedureName), ProcedureName)
    ProcedureType = "Null"
    If InStr(1, ProcedureText, "Sub " & ProcedureName) > 0 Then
        ProcedureType = "Sub"
    ElseIf InStr(1, ProcedureText, "Function " & ProcedureName) > 0 Then
        ProcedureType = "Function"
    End If
End Function

Public Function ActiveCodepaneWorkbook() As Workbook
    Dim TmpStr As String
    TmpStr = Application.VBE.SelectedVBComponent.Collection.parent.fileName
    TmpStr = Right(TmpStr, Len(TmpStr) - InStrRev(TmpStr, "\"))
    Set ActiveCodepaneWorkbook = Workbooks(TmpStr)
End Function

Public Function ActiveModule() As VBComponent
    Set ActiveModule = Application.VBE.SelectedVBComponent
End Function

Public Function ActiveProcedure() As String
    Application.VBE.ActiveCodePane.GetSelection L1&, C1&, L2&, C2&
    ActiveProcedure = Application.VBE.ActiveCodePane _
                      .CodeModule.ProcOfLine(L1&, vbext_pk_Proc)
End Function

Sub RemoveAllCodeFromModule(Module As VBComponent)
    On Error Resume Next
    Module.CodeModule.DeleteLines 1, Module.CodeModule.CountOfLines + 1
End Sub

Function CreateOrSetModule(compName As String, compType As VBIDE.vbext_ComponentType, Optional TargetWorkbook As Workbook) As VBComponent
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    On Error Resume Next
    Set vbComp = TargetWorkbook.VBProject.VBComponents(compName)
    On Error GoTo 0
    If vbComp Is Nothing Then
        Set vbComp = TargetWorkbook.VBProject.VBComponents.Add(compType)
        vbComp.Name = compName
    End If
    Set CreateOrSetModule = vbComp
End Function

Function ComponentTypeToString(componentType As VBIDE.vbext_ComponentType) As String
    Select Case componentType
        Case vbext_ct_ActiveXDesigner
            ComponentTypeToString = "ActiveX Designer"
        Case vbext_ct_ClassModule
            ComponentTypeToString = "Class Module"
        Case vbext_ct_Document
            ComponentTypeToString = "Document Module"
        Case vbext_ct_MSForm
            ComponentTypeToString = "UserForm"
        Case vbext_ct_StdModule
            ComponentTypeToString = "Code Module"
        Case Else
            ComponentTypeToString = "Unknown Type: " & CStr(componentType)
    End Select
End Function

Function ModuleOfWorksheet(TargetSheet As Worksheet) As VBComponent
    Set ModuleOfWorksheet = TargetSheet.parent.VBProject.VBComponents(TargetSheet.CodeName)
End Function

Sub CopyModulelToAllMyProjects(ModuleName As String, Overwrite As Boolean)
    '#INCLUDE dp
    '#INCLUDE ProtectedVBProject
    '#INCLUDE CopyModule
    Dim X, Y As Variant
    On Error Resume Next
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not ProtectedVBProject(Workbooks(Y.Name)) Then
                If err.Number = 0 Then
                    If InStr(1, Y.VBProject.Name, "vbArc", vbTextCompare) > 0 Then
                        If Y.Name <> ThisWorkbook.Name Then
                            dp Y.Name
                            CopyModule ModuleName, ThisWorkbook, Workbooks(Y.Name), Overwrite
                        End If
                    End If
                End If
            End If
            err.clear
        Next
    Next
End Sub

Function CopyModule(ModuleName As String, _
                    FromWorkbook As Workbook, _
                    toWorkbook As Workbook, _
                    OverwriteExisting As Boolean) As Boolean
    Dim FromVBProject As VBIDE.VBProject
    Set FromVBProject = FromWorkbook.VBProject
    Dim ToVBProject As VBIDE.VBProject
    Set ToVBProject = toWorkbook.VBProject
    If ToVBProject.Name = FromVBProject.Name Then Exit Function
    Dim vbComp As VBIDE.VBComponent
    Dim FName As String
    Dim TempVBComp As VBIDE.VBComponent
    On Error Resume Next
    Set vbComp = FromVBProject.VBComponents(ModuleName)
    If vbComp Is Nothing Then
        err.Raise 438, , "No Component by this name"
    End If
    Dim EXT As String
    FName = Environ("Temp") & "\" & ModuleName
    Dim vbcomp2 As VBComponent
    Set vbcomp2 = ToVBProject.VBComponents(ModuleName)
    If OverwriteExisting = True Then
        If Dir(FName, vbNormal + vbHidden + vbSystem) <> vbNullString Then
            err.clear
            Kill FName
            If err.Number <> 0 Then
                CopyModule = False
                Exit Function
            End If
        End If
        If Not vbcomp2 Is Nothing Then
            ToVBProject.VBComponents.Remove vbcomp2
        End If
    Else
        If vbcomp2 Is Nothing Then
        Else
            CopyModule = False
            Exit Function
        End If
    End If
    vbComp.Export fileName:=FName
    If vbComp.Type = vbext_ct_Document Then
        Set TempVBComp = ToVBProject.VBComponents.Import(FName)
        With vbComp.CodeModule
            .DeleteLines 1, .CountOfLines
            s = TempVBComp.CodeModule.Lines(1, TempVBComp.CodeModule.CountOfLines)
            .InsertLines 1, s
        End With
        On Error GoTo 0
        ToVBProject.VBComponents.Remove TempVBComp
    Else
        ToVBProject.VBComponents.Import fileName:=FName
    End If
    Kill FName
    CopyModule = True
End Function

Sub DeleteComponent(vbComp As VBComponent)
    '#INCLUDE GetSheetByCodeName
    '#INCLUDE WorkbookOfModule
    Application.DisplayAlerts = False
    If vbComp.Type = vbext_ct_Document Then
        If vbComp.Name = "ThisWorkbook" Then
            vbComp.CodeModule.DeleteLines 1, vbComp.CodeModule.CountOfLines
        Else
            If WorkbookOfModule(vbComp).SHEETS.count > 1 Then
                GetSheetByCodeName(WorkbookOfModule(vbComp), vbComp.Name).Delete
            Else
                Dim ws As Worksheet
                Set ws = WorkbookOfModule(vbComp).SHEETS.Add
                ws.Name = "All other sheets were deleted"
                GetSheetByCodeName(WorkbookOfModule(vbComp), vbComp.Name).Delete
            End If
        End If
    Else
        WorkbookOfModule(vbComp).VBProject.VBComponents.Remove vbComp
    End If
    Application.DisplayAlerts = True
End Sub

Function GetModuleText(vbComp As VBComponent) As String
    Dim CodeMod As CodeModule
    Set CodeMod = vbComp.CodeModule
    If CodeMod.CountOfLines = 0 Then GetModuleText = "": Exit Function
    GetModuleText = CodeMod.Lines(1, CodeMod.CountOfLines)
End Function

Function GetProjectText(TargetWorkbook As Workbook) As String
    '#INCLUDE getModuleName
    '#INCLUDE GetModuleText
    Dim Module As VBComponent
    Dim txt
    Dim div As String
    div = vbNewLine & "'=============================================" & vbNewLine
    For Each Module In TargetWorkbook.VBProject.VBComponents
        If Module.CodeModule.CountOfLines > 0 Then
            txt = txt & div & _
                  "'    " & getModuleName(Module) & "    " & Module.Type & _
                  div & _
                  GetModuleText(Module)
        End If
    Next
    GetProjectText = txt
End Function

Public Function getProcKind(vbComp As VBComponent, ByVal sProcName As String) As Long
    '#INCLUDE GetProcedureDeclaration
    Dim codeMode As CodeModule
    Set codeMode = vbComp.CodeModule
    Const vbext_pk_Proc As Long = 0
    Const vbext_pk_Let As Long = 1
    Const vbext_pk_Set As Long = 2
    Const vbext_pk_Get As Long = 3
    Dim txt As String
    txt = GetProcedureDeclaration(vbComp, sProcName, 0)
    If InStr(1, txt, "Get " & sProcName) > 0 Then
        getProcKind = 3
    ElseIf InStr(1, txt, "Let " & sProcName) > 0 Then
        getProcKind = 1
    ElseIf InStr(1, txt, "Set " & sProcName) > 0 And Not (InStr(1, txt, "Sub " & sProcName) > 0 Or InStr(1, txt, "Function " & sProcName) > 0) Then
        getProcKind = 2
    Else
        getProcKind = 0
    End If
End Function

Public Function GetProcText(vbComp As VBComponent, _
                            sProcName As Variant, _
                            Optional bInclHeader As Boolean = True) As String
    If vbComp Is Nothing Then
        Stop
    End If
    Dim CodeMod As CodeModule
    Set CodeMod = vbComp.CodeModule
    Dim lProcStart            As Long
    Dim lProcBodyStart        As Long
    Dim lProcNoLines          As Long
    Const vbext_pk_Proc = 0
    On Error GoTo Error_Handler
    lProcStart = CodeMod.ProcStartLine(sProcName, vbext_pk_Proc)
    lProcBodyStart = CodeMod.ProcBodyLine(sProcName, vbext_pk_Proc)
    lProcNoLines = CodeMod.ProcCountLines(sProcName, vbext_pk_Proc)
    If bInclHeader = True Then
        GetProcText = CodeMod.Lines(lProcStart, lProcNoLines)
    Else
        lProcNoLines = lProcNoLines - (lProcBodyStart - lProcStart)
        GetProcText = CodeMod.Lines(lProcBodyStart, lProcNoLines)
    End If
Error_Handler_Exit:
    On Error Resume Next
    Exit Function
Error_Handler:
    Rem debug.Print _
    "Error Source: GetProcText" & vbCrLf & _
    "Error Description: " & err.Description & _
    Switch(Erl = 0, vbNullString, Erl <> 0, vbCrLf & "Line No: " & Erl)
    Resume Error_Handler_Exit
End Function

Public Function GetSheetByCodeName(wb As Workbook, CodeName As String) As Worksheet
    Dim sh As Worksheet
    For Each sh In wb.Worksheets
        If UCase(sh.CodeName) = UCase(CodeName) Then Set GetSheetByCodeName = sh: Exit For
    Next sh
End Function

Public Sub GotoFirstModule()
    Dim wb As Workbook
    Set wb = ThisWorkbook
    Application.VBE.MainWindow.visible = True
    Application.VBE.MainWindow.WindowState = vbext_ws_Maximize
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        If vbComp.Type = vbext_ct_StdModule Then
            vbComp.Activate
            vbComp.CodeModule.CodePane.SetSelection 1, 1, 1, 1
            Exit Sub
        End If
    Next vbComp
End Sub

Public Function IsBlockEnd(strLine As String) As Boolean
    Dim bOK As Boolean
    Dim nPos As Integer
    Dim strTemp As String
    nPos = InStr(1, strLine, " ") - 1
    If nPos < 0 Then nPos = Len(strLine)
    strTemp = left$(strLine, nPos)
    Select Case strTemp
        Case "Next", "Loop", "Wend", "End Select", "Case", "Else", "#Else", "Else:", "#Else:", "ElseIf", "#ElseIf", "End If", "#End If"
            bOK = True
        Case "End"
            bOK = (Len(strLine) > 3)
    End Select
    IsBlockEnd = bOK
End Function

Public Function IsBlockStart(strLine As String) As Boolean
    Dim bOK As Boolean
    Dim nPos As Integer
    Dim strTemp As String
    nPos = InStr(1, strLine, " ") - 1
    If nPos < 0 Then nPos = Len(strLine)
    strTemp = left$(strLine, nPos)
    Select Case strTemp
        Case "With", "For", "Do", "While", "Select", "Case", "Else", "Else:", "#Else", "#Else:", "Sub", "Function", "Property", "Enum", "Type"
            bOK = True
        Case "If", "#If", "ElseIf", "#ElseIf"
            bOK = (Len(strLine) = (InStr(1, strLine, " Then") + 4))
        Case "public", "Public", "Friend"
            nPos = InStr(1, strLine, " Static ")
            If nPos Then
                nPos = InStr(nPos + 7, strLine, " ")
            Else
                nPos = InStr(Len(strTemp) + 1, strLine, " ")
            End If
            Select Case Mid$(strLine, nPos + 1, InStr(nPos + 1, strLine, " ") - nPos - 1)
                Case "Sub", "Function", "Property", "Enum", "Type"
                    bOK = True
            End Select
    End Select
    IsBlockStart = bOK
End Function

Sub ListProceduresSeparate(Optional wb As Workbook)
    '#INCLUDE ProcListArray
    '#INCLUDE CreateOrSetSheet
    If wb Is Nothing Then Set wb = ActiveWorkbook
    Dim vbComp As VBComponent
    Dim procArray As Variant
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("ListOfProcedures", wb)
    ws.Cells.clear
    Dim cell As Range
    Set cell = ws.Range("B1")
    For Each vbComp In wb.VBProject.VBComponents
        cell = vbComp.Name
        procArray = ProcListArray(vbComp)
        If UBound(procArray) <> -1 Then
            cell.OFFSET(1).RESIZE(UBound(procArray) + 1) = WorksheetFunction.Transpose(procArray)
        End If
        Set cell = cell.OFFSET(0, 1)
    Next
    ws.Cells.Columns.AutoFit
End Sub

Sub ListProceduresUnified(Optional wb As Workbook)
    '#INCLUDE ProcListArray
    '#INCLUDE CreateOrSetSheet
    If wb Is Nothing Then Set wb = ActiveWorkbook
    Dim vbComp As VBComponent
    Dim procArray As Variant
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("ListOfProcedures", ThisWorkbook)
    ws.Cells.clear
    Dim cell As Range
    Set cell = ws.Range("B1")
    For Each vbComp In wb.VBProject.VBComponents
        procArray = ProcListArray(vbComp)
        If UBound(procArray) <> -1 Then
            cell.RESIZE(UBound(procArray) + 1) = WorksheetFunction.Transpose(procArray)
            Set cell = ws.Range("B" & rows.count).End(xlUp).OFFSET(1)
        End If
    Next
    ws.Cells.Columns.AutoFit
    ws.Columns(2).SpecialCells(xlCellTypeConstants).Sort Key1:=Range("B1"), order1:=xlAscending, header:=xlNo
End Sub

Sub getAllWorkbooksLinks()
    '#INCLUDE dp
    '#INCLUDE ProtectedVBProject
    '#INCLUDE WorkbookLinks
    Dim X, Y As Variant
    On Error Resume Next
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not ProtectedVBProject(Workbooks(Y.Name)) Then
                If err.Number = 0 Then
                    dp Y.Name
                    dp "---------------"
                    dp WorkbookLinks(Workbooks(Y.Name))
                End If
            End If
            err.clear
        Next
    Next
End Sub

Function WorkbookLinks(TargetWorkbook As Workbook) As Collection
    Dim coll As New Collection
    Dim aLinks As Variant
    Dim el
    For Each el In Array(xlExcelLinks, xlOLELinks)
        aLinks = TargetWorkbook.LinkSources(el)
        If Not IsEmpty(aLinks) Then
            For i = 1 To UBound(aLinks)
                coll.Add aLinks(i)
            Next i
        End If
    Next
    Set WorkbookLinks = coll
End Function

Sub MacroLinkRemoverActiveWorkbook()
    '#INCLUDE MacroLinkRemover
    MacroLinkRemover ActiveWorkbook
End Sub

Sub MacroLinkRemoverActiveCodepaneWorkbook()
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE MacroLinkRemover
    MacroLinkRemover ActiveCodepaneWorkbook
End Sub

Sub MacroLinkRemover(TargetWorkbook As Workbook)
    '#INCLUDE FixExternalShapes
    '#INCLUDE FixExternalNames
    FixExternalShapes TargetWorkbook
    FixExternalNames TargetWorkbook
End Sub

Sub FixExternalShapes(Optional TargetWorkbook As Workbook)
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim shp As Shape
    Dim MacroLink, NewLink As String
    Dim SplitLink As Variant
    Dim ws As Worksheet
    For Each ws In TargetWorkbook.SHEETS
        For Each shp In ws.Shapes
            On Error GoTo NextShp
            MacroLink = shp.OnAction
            If MacroLink <> "" And InStr(MacroLink, "!") <> 0 Then
                SplitLink = Split(MacroLink, "!")
                NewLink = SplitLink(1)
                If Right(NewLink, 1) = "'" Then
                    NewLink = left(NewLink, Len(NewLink) - 1)
                End If
                shp.OnAction = NewLink
            End If
NextShp:
        Next shp
    Next
End Sub

Sub testFixNames()
    '#INCLUDE ProtectedVBProject
    '#INCLUDE FixExternalNames
    Dim X, Y As Variant
    On Error Resume Next
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not ProtectedVBProject(Workbooks(Y.Name)) Then
                If err.Number = 0 Then
                    FixExternalNames Workbooks(Y.Name)
                End If
            End If
            err.clear
        Next
    Next
End Sub

Sub FixExternalNames(Optional TargetWorkbook As Workbook)
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim objDefinedName As Name
    For Each objDefinedName In TargetWorkbook.Names
        If InStr(objDefinedName.RefersTo, "[") > 0 Then
            With objDefinedName
                .RefersTo = IIf(InStr(1, .RefersTo, "'") > 0, "'", "") & Replace(Mid(.RefersTo, InStrRev(.RefersTo, "]") + 1), """", "")
            End With
        End If
    Next objDefinedName
End Sub

Sub BreakAllLinks(ByVal wb As Object)
    Dim link As Variant, LinkType As Variant
    For Each LinkType In Array(xlLinkTypeExcelLinks, xlOLELinks, xlPublishers, xlSubscribers)
        If Not IsEmpty(wb.LinkSources(Type:=LinkType)) Then
            For Each link In wb.LinkSources(Type:=LinkType)
                wb.BreakLink Name:=link, Type:=LinkType
            Next link
        End If
    Next LinkType
    wb.UpdateLinks = xlUpdateLinksNever
End Sub

Public Function ModuleExists(Name As String, Optional ByVal ExistsInWorkbook As Workbook) As Boolean
    Dim j As Long
    Dim vbComp As VBComponent
    Dim modules As Collection
    Set modules = New Collection
    ModuleExists = False
    If ExistsInWorkbook Is Nothing Then
        Set ExistsInWorkbook = ThisWorkbook
    End If
    If (Name = vbNullString) Then
        GoTo errorname
    End If
    For Each vbComp In ExistsInWorkbook.VBProject.VBComponents
        If ((vbComp.Type = vbext_ct_StdModule) Or (vbComp.Type = vbext_ct_ClassModule)) Then
            modules.Add vbComp.Name
        End If
    Next vbComp
    For j = 1 To modules.count
        If (Name = modules.item(j)) Then
            ModuleExists = True
        End If
    Next j
    j = 0
    If (ModuleExists = False) Then
        GoTo NotFound
    End If
    If (0 <> 0) Then
errorname:
        MsgBox ("Function BootStrap.Is_Module_Loaded Was not passed a Name of Module")
        Exit Function
    End If
    If (0 <> 0) Then
NotFound:
        Exit Function
    End If
End Function

Function ModuleOfProcedure(wb As Workbook, ProcedureName As Variant) As VBComponent
    Dim ProcKind As VBIDE.vbext_ProcKind
    Dim LineNum As Long, NumProc As Long
    Dim procName As String
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        With vbComp.CodeModule
            LineNum = .CountOfDeclarationLines + 1
            Do Until LineNum >= .CountOfLines
                procName = .ProcOfLine(LineNum, ProcKind)
                LineNum = .ProcStartLine(procName, ProcKind) + .ProcCountLines(procName, ProcKind) + 1
                If UCase(procName) = UCase(ProcedureName) Then
                    Set ModuleOfProcedure = vbComp
                    Exit Function
                End If
            Loop
        End With
    Next vbComp
End Function

Function WorkbookOfProject(vbProj As VBProject) As Workbook
    TmpStr = vbProj.fileName
    TmpStr = Right(TmpStr, Len(TmpStr) - InStrRev(TmpStr, "\"))
    Set WorkbookOfProject = Workbooks(TmpStr)
End Function

Function WorkbookOfModule(vbComp As VBComponent) As Workbook
    '#INCLUDE WorkbookOfProject
    Set WorkbookOfModule = WorkbookOfProject(vbComp.Collection.parent)
End Function



'Sheet1	100



'vbArcImports	1

Rem @Folder vbArcImports
Sub ImportSelectedProcedure()
    '#INCLUDE CodepaneSelection
    '#INCLUDE CopyProcedures
    CopyProcedures CodepaneSelection, Workbooks("projectstart.xlam"), ThisWorkbook, False
End Sub

Function CheckPath(Path) As String
    '#INCLUDE HttpExists
    '#INCLUDE FileExists
    '#INCLUDE FolderExists
    Dim retval
    retval = "I"
    If (retval = "I") And FileExists(Path) Then retval = "F"
    If (retval = "I") And FolderExists(Path) Then retval = "D"
    If (retval = "I") And HttpExists(Path) Then retval = "U"
    CheckPath = retval
End Function

Function HttpExists(ByVal sURL As String) As Boolean
    Dim oXHTTP As Object
    Set oXHTTP = CreateObject("MSXML2.XMLHTTP")
    If Not UCase(sURL) Like "HTTP:*" Then
        sURL = "http://" & sURL
    End If
    On Error GoTo haveError
    oXHTTP.Open "HEAD", sURL, False
    oXHTTP.send
    HttpExists = IIf(oXHTTP.Status = 200, True, False)
    Exit Function
haveError:
    Rem Debug.Print err.Description
    HttpExists = False
End Function

Function TXTReadFromUrl(URL As String) As String
    On Error GoTo Err_GetFromWebpage
    Dim objWeb As Object
    Dim strXML As String
    Set objWeb = CreateObject("Msxml2.ServerXMLHTTP")
    objWeb.Open "GET", URL, False
    objWeb.setRequestHeader "Content-Type", "text/xml"
    objWeb.setRequestHeader "Cache-Control", "no-cache"
    objWeb.setRequestHeader "Pragma", "no-cache"
    objWeb.send
    strXML = objWeb.responseText
    TXTReadFromUrl = strXML
End_GetFromWebpage:
    Set objWeb = Nothing
    Exit Function
Err_GetFromWebpage:
    MsgBox err.Description & " (" & err.Number & ")"
    Resume End_GetFromWebpage
End Function


'Sheet22	100



'Sheet35	100

Public Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    If Selection.Cells.count > 1 Then Exit Sub
    If BarExists("testtag") Then
        CommandBars("testtag").ShowPopup
        Cancel = True
    End If
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
    On Error GoTo HELL
    Application.EnableEvents = False

    If Replace(Target.Address, "$", "") = rMENU_TYPE Then
        Range(rBAR_LOCATION).ClearContents
        Range(rTARGET_CONTROL).ClearContents
    ElseIf Replace(Target.Address, "$", "") = rBAR_LOCATION Then
        Range(rTARGET_CONTROL).ClearContents
    End If
    Application.EnableEvents = True
HELL:
End Sub

Public Sub Worksheet_SelectionChange(ByVal Target As Range)
    Calculate
    If Selection.Cells.count > 1 And Cells(Selection.row, 1) <> "" Then Exit Sub
    Dim dvtype As Integer
    dvtype = -1
    On Error Resume Next
    dvtype = Target.Validation.Type
    On Error GoTo 0
    If dvtype > -1 Then openUValiationDropdown
End Sub


'Sheet2	100



'Sheet37	100

Public Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    If Selection.Cells.count > 1 Then Exit Sub
    If BarExists("testtag") Then
        CommandBars("testtag").ShowPopup
        Cancel = True
    End If
End Sub

Private Sub Worksheet_Change(ByVal Target As Range)
    Application.EnableEvents = False

    If Replace(Target.Address, "$", "") = rMENU_TYPE Then
        Range(rBAR_LOCATION).ClearContents
        Range(rTARGET_CONTROL).ClearContents
    ElseIf Replace(Target.Address, "$", "") = rBAR_LOCATION Then
        Range(rTARGET_CONTROL).ClearContents
    End If
    Application.EnableEvents = True
End Sub

Public Sub Worksheet_SelectionChange(ByVal Target As Range)
    Calculate
    If Selection.Cells.count > 1 And Cells(Selection.row, 1) <> "" Then Exit Sub
    Dim dvtype As Integer
    dvtype = -1
    On Error Resume Next
    dvtype = Target.Validation.Type
    On Error GoTo 0
    If dvtype > -1 Then openUValiationDropdown
End Sub


'uDEV	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uDEV
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Rem MakeFormTransparent me
Rem MakeFormBorderless Me
Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Private Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
Private Const GWL_STYLE As Long = (-16)
Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_CAPTION As Long = &HC00000
Private Const WS_EX_DLGMODALFRAME As Long = &H1
Private Const WS_EX_LAYERED = &H80000
Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2
Private m_sngDownX As Single
Private m_sngDownY As Single

Private Sub MakeFormTransparent(frm As Object, Optional color As Variant)
    Dim formhandle As Long
    Dim bytOpacity As Byte
    formhandle = CLng(FindWindow(vbNullString, frm.Caption))
    If IsMissing(color) Then color = vbWhite
    bytOpacity = 100
    SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED
    frm.BackColor = color
    SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY
End Sub

Private Sub MakeFormBorderless(frm As Object)
    Dim lngWindow As Long
    Dim lFrmHdl As Long
    lFrmHdl = CLng(FindWindow(vbNullString, frm.Caption))
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl
End Sub

Private Sub LVK_Click()
    FollowLink ("https://vk.com/vbarc_hive")
End Sub

Private Sub Label2_Click()
    Unload Me
End Sub

Private Sub LFaceBook_Click()
    FollowLink ("https://www.facebook.com/VBA-Code-Archive-110295994460212")
End Sub

Private Sub LGitHub_Click()
    FollowLink ("https://github.com/alexofrhodes")
End Sub

Private Sub LYouTube_Click()
    FollowLink ("https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg")
End Sub

Private Sub LBuyMeACoffee_Click()
    FollowLink ("http://paypal.me/alexofrhodes")
End Sub

Private Function CLIP(Optional StoreText As String) As String
    Dim X As Variant
    X = StoreText
    With CreateObject("htmlfile")
        With .parentWindow.clipboardData
            Select Case True
                Case Len(StoreText)
                    .SetData "text", X
                Case Else
                    CLIP = .GetData("text")
            End Select
        End With
    End With
End Function

Private Sub LEmail_Click()
    If GetInternetConnectedState = False Then
        MsgBox "Seems Internet is not available"
        Exit Sub
    End If
    If OutlookCheck = True Then
        MailDev
    Else
        Dim out As String
        out = AUTHOR_EMAIL
        CLIP out
        MsgBox ("Seems Outlook is not available" & Chr(10) & _
                "DEV's email address " & vbNewLine & out & vbNewLine & "copied to clipboard")
    End If
End Sub

Sub MailDev()
    Dim OutApp As Object
    Dim OutMail As Object
    Dim strBody As String
    Set OutApp = CreateObject("Outlook.Application")
    Set OutMail = OutApp.CreateItem(0)
    On Error Resume Next
    With OutMail
        .To = AUTHOR_EMAIL
        .CC = vbNullString
        .BCC = vbNullString
        .Subject = "DEV REQUEST OR FEEDBACK FOR -CODE ARCHIVE-"
        .body = strBody
        .Display
    End With
    On Error GoTo 0
    Set OutMail = Nothing
    Set OutApp = Nothing
End Sub

Private Sub FollowLink(FolderPath As String)
    If Right(FolderPath, 1) = "\" Then FolderPath = left(FolderPath, Len(FolderPath) - 1)
    On Error Resume Next
    Dim oShell As Object
    Dim Wnd As Object
    Set oShell = CreateObject("Shell.Application")
    For Each Wnd In oShell.Windows
        If Wnd.Name = "File Explorer" Then
            If Wnd.document.Folder.Self.Path = FolderPath Then Exit Sub
        End If
    Next Wnd
    Application.ThisWorkbook.FollowHyperlink Address:=FolderPath, NewWindow:=True
End Sub

Private Sub UserForm_Initialize()
    MakeFormBorderless Me
    MakeFormTransparent Me, vbBlack
End Sub



'uProjectManager	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uProjectManager
'* Created    : 06-10-2022 10:39
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub goToFolder_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    FollowLink Environ("USERprofile") & "\Documents\vbArc\"
End Sub

Private Sub iAdd_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    oAdd.Value = True
    optionsBlank
    iAdd.BorderStyle = fmBorderStyleSingle
    ExportOptionsHide
End Sub

Private Sub iExport_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    oExport.Value = True
    optionsBlank
    iExport.BorderStyle = fmBorderStyleSingle
    ExportOptionsShow
End Sub

Private Sub iImport_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    oImport.Value = True
    optionsBlank
    iImport.BorderStyle = fmBorderStyleSingle
    ExportOptionsHide
End Sub

Private Sub iRename_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    oRename.Value = True
    optionsBlank
    iRename.BorderStyle = fmBorderStyleSingle
    ExportOptionsHide
End Sub

Private Sub iRemove_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    oDelete.Value = True
    optionsBlank
    iRemove.BorderStyle = fmBorderStyleSingle
End Sub

Private Sub iRefresh_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    oRefresh.Value = True
    optionsBlank
    iRefresh.BorderStyle = fmBorderStyleSingle
    ExportOptionsHide
End Sub

Sub optionsBlank()
    iAdd.BorderStyle = fmBorderStyleNone
    iExport.BorderStyle = fmBorderStyleNone
    iImport.BorderStyle = fmBorderStyleNone
    iRename.BorderStyle = fmBorderStyleNone
    iRefresh.BorderStyle = fmBorderStyleNone
    iRemove.BorderStyle = fmBorderStyleNone
End Sub

Sub ExportOptionsHide()
    ExportOptions.visible = False
    ImageExport.visible = False
    '    FrameBottom.Top = 36
    '    Me.Height = 198
End Sub

Sub ExportOptionsShow()
    '    FrameBottom.top = 132
    ExportOptions.visible = True
    ImageExport.visible = True
    '    Me.Height = 295
End Sub

Private Sub SelectFromList_Click()
    If listOpenBooks.ListIndex = -1 Then
        MsgBox "No book selected"
        Exit Sub
    End If
    Set pmWorkbook = Workbooks(listOpenBooks.list(listOpenBooks.ListIndex))
    SelectAction
End Sub

Private Sub UserForm_Initialize()
    LoadBooksAndAddins
    SortListboxOnColumn Me.listOpenBooks, 0
    LoadUserformOptions Me
    FormatColourFormatters
End Sub

Sub LoadBooksAndAddins()
    Rem list workbooks
    '#INCLUDE ListboxContains
    '#INCLUDE ProtectedVBProject
    Dim wb As Workbook
    For Each wb In Workbooks
        If Len(wb.Path) > 0 Then
            If ProtectedVBProject(wb) = False Then listOpenBooks.AddItem wb.Name
        End If
    Next
    Rem list addins
    Dim vbProj As VBProject
    Dim wbPath As String
    For Each vbProj In Application.VBE.VBProjects
        On Error GoTo ErrorHandler
        wbPath = vbProj.fileName
        If Right(wbPath, 4) = "xlam" Or Right(wbPath, 3) = "xla" Then
            Dim wbName As String
            wbName = Mid(wbPath, InStrRev(wbPath, "\") + 1)
            If ProtectedVBProject(Workbooks(wbName)) = False Then
                If ListboxContains(listOpenBooks, wbName) = False Then listOpenBooks.AddItem wbName
            End If
        End If
Skip:
    Next vbProj
    Exit Sub
ErrorHandler:
    If err.Number = 76 Then GoTo Skip
End Sub

Private Sub ActiveFile_Click()
    Set pmWorkbook = ActiveWorkbook
    SelectAction
End Sub

Sub SelectAction()
    '#INCLUDE ImportComponents
    '#INCLUDE ExportProject
    '#INCLUDE RefreshComponents
    '#INCLUDE ProtectedVBProject
    '#INCLUDE ListAllProcedureImports
    
    If ProtectedVBProject(pmWorkbook) = True Then
        MsgBox "Project of " & pmWorkbook.Name & " is protected."
        Exit Sub
    End If
    
    '    ListAllProcedureImports pmWorkbook
    
    Select Case True
        Case oExport.Value = True
            Me.Hide
            ExportProject wb:=pmWorkbook _
                               , bExportComponents:=chExportComponents.Value _
                                                     , bSeparateProcedures:=chExportProcedures.Value _
                                                                             , PrintCode:=chPrintCode.Value _
                                                                                           , ExportSheets:=chExportSheets.Value _
                                                                                                            , ExportForms:=chExportForms.Value _
                                                                                                                            , bExportXML:=chExportXML.Value _
                                                                                                                                           , bExportReferences:=chExportReferences.Value _
                                                                                                                                                                 , bExportDeclarations:=chExportDeclarations.Value _
                                                                                                                                                                                         , bExportUnified:=chExportUnified.Value _
                                                                                                                                                                                                            , bWorkbookBackup:=chWorkbookBackup.Value
                        
            Me.Show
        Case oImport.Value = True
            ImportComponents pmWorkbook
        Case oRefresh.Value = True
            RefreshComponents pmWorkbook
        Case oDelete.Value = True
            RemoveComps.Show
        Case oRename.Value = True
            RenameComps.Show
        Case oAdd.Value = True
            AddComps.Show
        Case Else
    End Select
End Sub

Private Sub cInfo_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub Image1_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    ExportSettings.Show
End Sub

Private Sub SelectFile_Click()
    Dim fPath As String
    fPath = PickExcelFile
    If fPath = "" Then Exit Sub
    Set pmWorkbook = Workbooks.Open(fileName:=fPath, UpdateLinks:=0, ReadOnly:=False)
    SelectAction
    Set pmWorkbook = Nothing
End Sub

Private Sub LBLcolourCode_Click()
    ColorPaletteDialog ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("J1"), LBLcolourCode
End Sub

Private Sub LBLcolourComment_Click()
    ColorPaletteDialog ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("J4"), LBLcolourComment
End Sub

Private Sub LBLcolourKey_Click()
    ColorPaletteDialog ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("J3"), LBLcolourKey
End Sub

Private Sub LBLcolourOdd_Click()
    ColorPaletteDialog ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("J2"), LBLcolourOdd
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    SaveUserformOptions Me, , False
End Sub



'RenameComps	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : RenameComps
'* Created    : 06-10-2022 10:33
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub cInfo_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub RenameComponents_Click()
    If pmWorkbook Is Nothing Then Set pmWorkbook = ActiveWorkbook
    Dim NewNames As Variant
    Dim i As Long
    NewNames = Split(textboxNewName, vbNewLine)
    For i = 0 To UBound(NewNames)
        If NewNames(i) = vbNullString Then
            NewNames(i) = LRenameListbox.list(i)
        End If
    Next i
    For i = 0 To UBound(NewNames)
continue:
        On Error GoTo eh
        Select Case LRenameListbox.list(i, 0)
            Case Is = "Module", "Class", "UserForm"
                If LRenameListbox.list(i, 1) <> NewNames(i) Then
                    pmWorkbook.VBProject.VBComponents(LRenameListbox.list(i, 1)).Name = NewNames(i)
                End If
            Case Is = "Document"
                If LRenameListbox.list(i, 1) <> NewNames(i) Then
                    pmWorkbook.SHEETS(LRenameListbox.list(i, 1)).Name = NewNames(i)
                End If
        End Select
    Next
    For i = 0 To LRenameListbox.ListCount - 1
        LRenameListbox.list(i, 1) = NewNames(i)
    Next i
    textboxNewName.TEXT = vbNullString
    Dim str As String
    str = Join(NewNames, vbNewLine)
    textboxNewName.TEXT = str
    MsgBox "Components renamed"
    Exit Sub
eh:
    NewNames(i) = NewNames(i) & i + 1
    Resume continue
End Sub

Private Sub UserForm_Initialize()
    If pmWorkbook Is Nothing Then Set pmWorkbook = ActiveWorkbook
    Dim vbComp As VBComponent
    For Each vbComp In pmWorkbook.VBProject.VBComponents
        If vbComp.Name <> "ThisWorkbook" Then
            LRenameListbox.AddItem
            LRenameListbox.list(LRenameListbox.ListCount - 1, 0) = ComponentTypeToString(vbComp.Type)
            If vbComp.Type <> vbext_ct_Document Then
                LRenameListbox.list(LRenameListbox.ListCount - 1, 1) = vbComp.Name
            Else
                LRenameListbox.list(LRenameListbox.ListCount - 1, 1) = GetSheetByCodeName(pmWorkbook, vbComp.Name).Name
            End If
        End If
    Next
    SortListboxOnColumn LRenameListbox, 0
    Dim str As String
    str = LRenameListbox.list(0, 1)
    For i = 1 To LRenameListbox.ListCount - 1
        str = str & vbNewLine & LRenameListbox.list(i, 1)
    Next
    textboxNewName.TEXT = str
End Sub


'RemoveComps	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : RemoveComps
'* Created    : 06-10-2022 10:33
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub cInfo_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub Remover_Click()
    If LComponents.ListCount = 0 Then Exit Sub
    If pmWorkbook Is Nothing Then Set pmWorkbook = ActiveWorkbook
    Dim i As Long
    For i = 0 To LComponents.ListCount - 1
        If LComponents.SELECTED(i) Then
            If oCode.Value = True Then
                ClearComponent pmWorkbook.VBProject.VBComponents(LComponents.list(i, 1))
            ElseIf oComps.Value = True Then
                DeleteComponent pmWorkbook.VBProject.VBComponents(LComponents.list(i, 1))
            End If
        End If
    Next i
    addCompsList
End Sub

Private Sub UserForm_Initialize()
    If pmWorkbook Is Nothing Then Set pmWorkbook = ActiveWorkbook
    addCompsList
    Me.Caption = "Comps of " & pmWorkbook.Name
End Sub

Sub addCompsList()
    '#INCLUDE SortListboxOnColumn
    '#INCLUDE ComponentTypeToString
    '#INCLUDE GetSheetByCodeName
    '#INCLUDE ResizeUserformToFitControls
    '#INCLUDE ResizeControlColumns
    LComponents.clear
    Dim vbComp As VBComponent
    For Each vbComp In pmWorkbook.VBProject.VBComponents
        If vbComp.Name <> "ThisWorkbook" Then
            LComponents.AddItem
            LComponents.list(LComponents.ListCount - 1, 0) = ComponentTypeToString(vbComp.Type)
            LComponents.list(LComponents.ListCount - 1, 1) = vbComp.Name
            If vbComp.Type = vbext_ct_Document Then
                LComponents.list(LComponents.ListCount - 1, 2) = GetSheetByCodeName(pmWorkbook, vbComp.Name).Name
            End If
        End If
    Next
    SortListboxOnColumn LComponents, 0
    ResizeControlColumns LComponents
    ResizeUserformToFitControls Me
    Me.Repaint
End Sub


'AddComps	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : AddComps
'* Created    : 06-10-2022 10:33
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub cInfo_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub CommandButton1_Click()
    If pmWorkbook Is Nothing Then Set pmWorkbook = ActiveWorkbook
    Dim coll As Collection
    Set coll = New Collection
    Dim element As Variant
    coll.Add Split(Me.tModule.TEXT, vbNewLine)
    coll.Add Split(Me.tClass.TEXT, vbNewLine)
    coll.Add Split(Me.tUserform.TEXT, vbNewLine)
    coll.Add Split(Me.tDocument.TEXT, vbNewLine)
    Dim typeCounter As Long
    For Each element In coll
        If UBound(element) <> -1 Then
            typeCounter = typeCounter + 1
            AddComponent pmWorkbook, typeCounter, element
        End If
    Next element
    MsgBox typeCounter & " components added to " & pmWorkbook.Name
End Sub

Sub AddComponent(wb As Workbook, Module_Class_Form_Sheet As Long, componentArray As Variant)
    '#INCLUDE ModuleExists
    Dim compType As Long
    compType = Module_Class_Form_Sheet
    Dim vbProj As VBProject
    Set vbProj = wb.VBProject
    Dim vbComp As VBComponent
    Dim NewSheet As Worksheet
    Dim i As Long
    Dim counter As Long
    On Error GoTo ErrorHandler
    For i = LBound(componentArray) To UBound(componentArray)
        If componentArray(i) <> vbNullString Then
            Select Case compType
                Case Is = 1, 2, 3
                    If ModuleExists(CStr(componentArray(i))) = False Then
                        If compType = 1 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_StdModule)
                        If compType = 2 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_ClassModule)
                        If compType = 3 Then Set vbComp = vbProj.VBComponents.Add(vbext_ct_MSForm)
                    End If
                    vbComp.Name = componentArray(i)
                Case Is = 4
                    If compType = 4 Then
                        Set NewSheet = CreateOrSetSheet(CStr(componentArray(i)), wb)
                        NewSheet.Name = componentArray(i)
                    End If
            End Select
        End If
loop1:
    Next i
    On Error GoTo 0
    Exit Sub
ErrorHandler:
    counter = counter + 1
    componentArray(i) = componentArray(i) & counter
    GoTo loop1
End Sub


'U_ProjectManager	1


Rem @Folder ProjectManager Declarations
Public pmWorkbook As Workbook
#If VBA7 Then
    Declare PtrSafe Sub keybd_event Lib "user32" (ByVal bVk As Byte, ByVal bScan As Byte, ByVal dwFlags As Long, ByVal dwExtraInfo As LongPtr)
#Else
    Declare Sub keybd_event Lib "user32" (ByVal bVk As Byte,  ByVal bScan As Byte, ByVal dwFlags As Long, ByVal dwExtraInfo As Long)
#End If
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Rem @Folder WindowToPDF Declarations
Private Const VK_SNAPSHOT = 44
Private Const VK_LMENU = 164
Private Const KEYEVENTF_KEYUP = 2
Private Const KEYEVENTF_EXTENDEDKEY = 1
Rem @Folder CodePrinter Declarations
Public PrintFileName As String
Public Found1 As String
Public Found2 As String
Dim rng As Range
Public cell As Range
Public s As Shape
Public counter As Long

Rem @Folder ProjectManager
Rem @Subfolder CodePrinter
Public Function PrintProject(TargetWorkbook As Workbook)
    '#INCLUDE HasProject
    '#INCLUDE ProtectedVBProject
    '#INCLUDE PrinterTocAndCode
    '#INCLUDE PutCodeInPrinter
    '#INCLUDE LinkCodeBlocksWithShape
    '#INCLUDE AddPageBreaksToPrinter
    '#INCLUDE MergePrinterCells
    '#INCLUDE NumberLinesPrinter
    '#INCLUDE FormatPrinterTitles
    '#INCLUDE AddLogoToFirstPage
    '#INCLUDE SetupPrinterPage
    '#INCLUDE ColorizeBlockLinksByLevel
    '#INCLUDE FormatTextColors
    '#INCLUDE ResetPrinter
    '#INCLUDE PrintPDF
    '#INCLUDE AutofitMergedCells
    '#INCLUDE StartOptimizeCodeRun
    '#INCLUDE StopOptimizeCodeRun
    '#INCLUDE getLastRow
    Set pmWorkbook = TargetWorkbook
    If ProtectedVBProject(TargetWorkbook) = True Or HasProject(TargetWorkbook) = False Then
        MsgBox "Project Empty or Protected"
        Exit Function
    End If
    StartOptimizeCodeRun
    ResetPrinter
    PutCodeInPrinter PrinterTocAndCode
    NumberLinesPrinter
    FormatTextColors
    FormatPrinterTitles
    SetupPrinterPage
    AddLogoToFirstPage
    LinkCodeBlocksWithShape
    ColorizeBlockLinksByLevel
    MergePrinterCells
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    Dim TargetRange As Range
    Set TargetRange = ws.Range("P2:P" & getLastRow(ws))
    AutofitMergedCells TargetRange
    AddPageBreaksToPrinter
    PrintPDF
    StopOptimizeCodeRun
End Function

Function PrinterTocAndCode()
    '#INCLUDE GetCompText
    '#INCLUDE ComponentTypeToString
    '#INCLUDE CollectionToArray
    Dim workbookName As String
    workbookName = TargetWorkbook.Name
    Dim TargetWorkSheet As Worksheet
    Dim TargetWorkSheetName As String
    Dim Module As VBComponent
    Dim procedures As Collection
    Set procedures = New Collection
    Dim Procedure As String
    Dim tmpString As Variant
    Dim i As Long
    procedures.Add "Table of Contents:"
    Dim ModuleTypes
    ModuleTypes = Array(vbext_ct_Document, vbext_ct_ClassModule, vbext_ct_StdModule, vbext_ct_MSForm)
    Dim ModuleType
    For Each ModuleType In ModuleTypes
        For Each Module In TargetWorkbook.VBProject.VBComponents
            If Module.Type = ModuleType Then
                If ModuleType = vbext_ct_Document And Module.Name <> "ThisWorkbook" Then
                    For Each TargetWorkSheet In TargetWorkbook.Worksheets
                        If TargetWorkSheet.CodeName = Module.Name Then TargetWorkSheetName = TargetWorkSheet.Name
                    Next TargetWorkSheet
                    procedures.Add "(" & ComponentTypeToString(Module.Type) & ")" & " " & TargetWorkSheetName & " - " & Module.Name
                    TargetWorkSheetName = ""
                Else
                    procedures.Add "(" & ComponentTypeToString(Module.Type) & ")" & " " & Module.Name
                End If
            End If
        Next Module
    Next ModuleType
    Rem document
    For Each ModuleType In ModuleTypes
        For Each Module In TargetWorkbook.VBProject.VBComponents
            If Module.Type = ModuleType Then
                If ModuleType = vbext_ct_Document And Module.Name <> "ThisWorkbook" Then
                    For Each TargetWorkSheet In TargetWorkbook.Worksheets
                        If TargetWorkSheet.CodeName = Module.Name Then TargetWorkSheetName = TargetWorkSheet.Name
                    Next TargetWorkSheet
                    procedures.Add "--- " & TargetWorkSheetName & " - " & Module.Name & " ---"
                    TargetWorkSheetName = ""
                Else
                    procedures.Add "--- " & Module.Name & " ---"
                End If
                If Module.CodeModule.CountOfLines > 0 Then
                    tmpString = Split(GetCompText(Module), vbNewLine)
                    For i = LBound(tmpString) To UBound(tmpString)
                        procedures.Add tmpString(i)
                    Next i
                End If
            End If
        Next Module
    Next ModuleType
    ThisWorkbook.SHEETS("ProjectManagerPrinter").Cells.WrapText = False
    PrinterTocAndCode = CollectionToArray(procedures)
End Function

Sub PutCodeInPrinter(SourceCode As Variant)
    '#INCLUDE getLastRow
    Dim TargetSheet As Worksheet
    Set TargetSheet = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    Dim i As Long
    Dim off As Long
    Dim rowNo As Long
    rowNo = getLastRow(TargetSheet) + 1
    With TargetSheet
        For i = LBound(SourceCode) To UBound(SourceCode)
            If left(Trim(SourceCode(i)), 1) = "'" Then
                .Cells(rowNo, 2).Value = "'"
            ElseIf Len(SourceCode(i)) - Len(LTrim(SourceCode(i))) = 0 Then
                .Cells(rowNo, 2).Value = Trim(SourceCode(i))
            Else
                off = Len(SourceCode(i)) - Len(LTrim(SourceCode(i)))
                .Cells(rowNo, 2).OFFSET(0, off / 4).Value = Trim(SourceCode(i))
            End If
            rowNo = rowNo + 1
        Next
    End With
End Sub

Function LinkCodeBlocksWithShape() As Boolean
    '#INCLUDE IsBlockStart
    '#INCLUDE openPair
    '#INCLUDE closePair
    '#INCLUDE getLastColumn
    '#INCLUDE AddShape
    Dim ShapeTypeNumber As Long
    Rem msoShapeLeftBrace   31  Left brace
    Rem msoShapeLeftBracket 29  Left bracket
    ShapeTypeNumber = 29
    Rem activesheet.shapes("bracket").adjustments.item(1)=10
    Dim CloseTXT As String
    Dim X As Variant
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    Dim trimCell As String
    Dim counter As Long
    Dim colNo As Long
    For colNo = 1 To getLastColumn(ws)
        If WorksheetFunction.CountA(ws.Columns(colNo)) > 0 Then
            For Each cell In ws.Columns(colNo).SpecialCells(xlCellTypeConstants)
                trimCell = Trim(cell.TEXT)
                If IsBlockStart(trimCell) Then
                    Select Case openPair(trimCell)
                        Case Is = "Case", "Else"
                        Case Is = "If"
                            If Right(trimCell, 4) <> "Then" Then GoTo Skip
                        Case Is = "#If"
                        Case Is = "skip"
                            GoTo Skip
                        Case Else
                    End Select
                    CloseTXT = closePair(trimCell)
                    counter = Len(cell) - Len(trimCell)
                    Found1 = cell.Address
                    On Error Resume Next
                    Dim foundMatch As Range
                    Set foundMatch = ws.Columns(colNo).Find(CloseTXT & "*", After:=cell, LookAt:=xlWhole)
                    On Error GoTo 0
                    If foundMatch Is Nothing Then GoTo Skip
                    Found2 = foundMatch.Address
                    ws.Shapes.AddShape ShapeTypeNumber, _
                                       ws.Range(Found1).left - 5, _
                                       ws.Range(Found1).top + (cell.Height / 2), _
                                       5, _
                                       ws.Range(Found1, Found2).Height - cell.Height
                End If
Skip:
            Next cell
        End If
    Next colNo
    LinkCodeBlocksWithShape = True
End Function

Function openPair(strLine As String) As String
    Dim nPos As Integer
    Dim strTemp As String
    strTemp = Trim(strLine)
    nPos = InStr(1, strTemp, " ") - 1
    If nPos < 0 Then nPos = Len(strLine)
    strTemp = left$(strLine, nPos)
    Select Case strTemp
        Case Is = "Private", "Public"
            strTemp = Trim(strLine)
            strTemp = Replace(strTemp, "Private ", "")
            strTemp = Replace(strTemp, "Public ", "")
            nPos = InStr(1, strTemp, " ") - 1
            If nPos < 0 Then nPos = Len(strTemp)
            strTemp = left$(strTemp, nPos)
            If strTemp = "Function" Then
                openPair = "Function"
            ElseIf strTemp = "Sub" Then
                openPair = "Sub"
            Else
                GoTo Skip
            End If
        Case Is = "With"
            openPair = "With"
        Case Is = "For"
            openPair = "For"
        Case Is = "Do"
            openPair = "Do"
        Case Is = "While"
            openPair = "While"
        Case Is = "Select"
            openPair = "Select"
        Case Is = "Case"
            openPair = "Case"
        Case Is = "Sub"
            openPair = "Sub"
        Case Is = "Function"
            openPair = "Function"
        Case Is = "Property"
            openPair = "Property"
        Case Is = "Enum"
            openPair = "Enum"
        Case Is = "Type"
            openPair = "Type"
        Case "If"
            openPair = "If"
        Case "ElseIf", "Else", "Else:"
            openPair = "Else"
        Case "#If"
            openPair = "#If"
        Case "#ElseIf", "#Else", "#Else:"
            openPair = "#Else"
        Case Else
Skip:
            openPair = "skip"
    End Select
End Function

Function closePair(strLine As String) As String
    Dim nPos As Integer
    Dim strTemp As String
    nPos = InStr(1, strLine, " ") - 1
    If nPos < 0 Then nPos = Len(strLine)
    strTemp = left$(strLine, nPos)
    Select Case strTemp
        Case Is = "Private", "Public"
            strTemp = Trim(strLine)
            strTemp = Replace(strTemp, "Private ", "")
            strTemp = Replace(strTemp, "Public ", "")
            nPos = InStr(1, strTemp, " ") - 1
            If nPos < 0 Then nPos = Len(strTemp)
            strTemp = left$(strTemp, nPos)
            If strTemp = "Function" Then
                closePair = "End Function"
            ElseIf strTemp = "Sub" Then
                closePair = "End Sub"
            Else
            End If
        Case Is = "With"
            closePair = "End With"
        Case Is = "For"
            closePair = "Next"
        Case Is = "Do", "While"
            closePair = "Loop"
        Case Is = "Select", "Case"
            closePair = "End Select"
        Case Is = "Sub"
            closePair = "End Sub"
        Case Is = "Function"
            closePair = "End Function"
        Case Is = "Property"
            closePair = "End Property"
        Case Is = "Enum"
            closePair = "End Enum"
        Case Is = "Type"
            closePair = "End Type"
        Case "If", "ElseIf", "Else", "Else:"
            closePair = "End If"
        Case "#If", "#ElseIf", "#Else", "#Else:"
            closePair = "#End If"
        Case Else
    End Select
End Function

Sub AddPageBreaksToPrinter()
    ThisWorkbook.SHEETS("ProjectManagerPrinter").ResetAllPageBreaks
    Dim rng As Range
    Set rng = Nothing
    Dim cell As Range
    With ThisWorkbook.SHEETS("ProjectManagerPrinter")
        For Each cell In .Range("B1:B" & .Range("B" & .rows.count).End(xlUp).row)
            If left(Trim(cell.Value), 3) = "---" Then
                If rng Is Nothing Then
                    Set rng = cell
                Else
                    Set rng = Union(rng, cell)
                End If
            End If
        Next
        For Each cell In rng
            .HPageBreaks.Add Before:=.rows(cell.row)
            .rows(cell.row).PageBreak = xlPageBreakManual
        Next
    End With
End Sub

Sub MergePrinterCells()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    Dim cell As Range
    For Each cell In ws.Cells.SpecialCells(xlCellTypeConstants)
        ws.Range(cell, ws.Cells(cell.row, "P")).MERGE
    Next
    ws.Cells.WrapText = True
End Sub

Sub FormatColourFormatters()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("ProjectManagerTXTColour")
    uProjectManager.LBLcolourCode.ForeColor = ws.Range("J1").Value
    uProjectManager.LBLcolourKey.ForeColor = ws.Range("J3").Value
    uProjectManager.LBLcolourOdd.BackColor = ws.Range("J2").Value
    uProjectManager.LBLcolourComment.ForeColor = ws.Range("J4").Value
End Sub

Sub ColorPaletteDialog(rng As Range, Lbl As MSForms.label)
    If Application.Dialogs(xlDialogEditColor).Show(10, 0, 125, 125) = True Then
        lcolor = ActiveWorkbook.Colors(10)
        rng.Value = lcolor
        rng.OFFSET(0, 1).Interior.color = lcolor
        Lbl.ForeColor = lcolor
    End If
    ActiveWorkbook.ResetColors
End Sub

Sub NumberLinesPrinter()
    '#INCLUDE getLastRow
    Dim TargetWorkSheet As Worksheet
    Set TargetWorkSheet = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    Dim cell As Range
    Dim lRow As Long
    lRow = getLastRow(TargetWorkSheet)
    Rem     Dim arr
    Rem     ReDim arr(1 To lRow)
    Rem     Dim i As Long
    Rem     For i = 1 To lRow
    Rem         arr(i) = i
    Rem     Next
    Rem     TargetWorkSheet.Range("a1").Value = WorksheetFunction.Transpose(arr)
    With TargetWorkSheet
        For Each cell In .Range("A1:A" & lRow)
            If cell.row Mod 2 = 0 Then
                If rng Is Nothing Then
                    Set rng = cell
                Else
                    Set rng = Union(rng, cell)
                End If
            End If
        Next cell
    End With
    rng.EntireRow.Interior.color = _
                                 ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("J2").Value
End Sub

Sub FormatPrinterTitles()
    Dim rng As Range
    Set rng = Nothing
    Dim cell As Range
    With ThisWorkbook.SHEETS("ProjectManagerPrinter")
        For Each cell In .Range("B1:B" & .Range("B" & .rows.count).End(xlUp).row)
            If left(Trim(cell.Value), 3) = "---" Then
                If rng Is Nothing Then
                    Set rng = cell
                Else
                    Set rng = Union(rng, cell)
                End If
            End If
        Next
    End With
    If rng Is Nothing Then Exit Sub
    rng.Font.Size = 18
    rng.Font.Bold = True
    rng.Font.color = vbBlack
End Sub

Sub AddLogoToFirstPage()
    Dim PrinterSheet As Worksheet
    Set PrinterSheet = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    PrinterSheet.rows(1).EntireRow.Insert
    PrinterSheet.Range("A2:C2").Interior.ColorIndex = 0
    Dim TargetCell As Range
    Set TargetCell = PrinterSheet.Range("B1")
    With TargetCell
        Rem       .HorizontalAlignment = xlCenter
        .HorizontalAlignment = xlLeft
        .VerticalAlignment = xlVAlignBottom
        .Value = AUTHOR_GITHUB & Space(16) & pmWorkbook.Name
        .Characters.Font.Size = 12
        .Characters.Font.Bold = True
        .Characters.Font.Underline = False
        .Characters.Font.ColorIndex = 10
        .Characters.Font.Name = "Comic Sans MS"
        .RowHeight = 330
    End With
    ThisWorkbook.SHEETS("README").Shapes("LOGO").Copy
    PrinterSheet.Paste TargetCell
    Dim shp As Shape
    Set shp = PrinterSheet.Shapes("LOGO")
    shp.left = TargetCell.left
    shp.top = TargetCell.top
    shp.Height = TargetCell.EntireRow.Height
End Sub

Sub SetupPrinterPage()
    Dim PrinterSheet As Worksheet
    Set PrinterSheet = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    With PrinterSheet.PageSetup
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.25)
        .BottomMargin = Application.InchesToPoints(0.75)
        Dim fileName As String
        fileName = PrintFileName
        .LeftFooter = fileName
        .CenterFooter = "Page &P of &N"
        .RightFooter = "&D"
        .FitToPagesWide = 1
        .FitToPagesTall = False
    End With
End Sub

Sub ColorizeBlockLinksByLevel()
    '#INCLUDE RandomRGB
    Dim rnd As Long
    Dim n As Variant
    Dim i As Long
    Dim s As Shape
    Dim sNames
    Set sNames = CreateObject("System.Collections.ArrayList")
    For Each s In ThisWorkbook.SHEETS("ProjectManagerPrinter").Shapes
        If UCase(s.Name) <> "LOGO" Then
            s.Name = s.left
            If Not sNames.CONTAINS(s.Name) Then
                sNames.Add s.Name
            End If
        End If
    Next s
    For Each n In sNames
        rnd = RandomRGB
        For Each s In ThisWorkbook.SHEETS("ProjectManagerPrinter").Shapes
            If UCase(s.Name) <> "LOGO" Then
                If s.Name = n Then
                    With s.line
                        .ForeColor.RGB = rnd
                        .Weight = 1.5
                    End With
                End If
            End If
        Next s
    Next n
    Set sNames = Nothing
End Sub

Function RandomRGB()
    RandomRGB = RGB(Int(rnd() * 255), Int(rnd() * 255), Int(rnd() * 255))
End Function

Public Sub FormatTextColors()
    '#INCLUDE InStrExact
    Dim PrinterSheet As Worksheet
    Set PrinterSheet = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    With PrinterSheet.Cells.Font
        .color = ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("J1").Value
        .FontStyle = "Normal"
    End With
    Dim rng As Range
    Set rng = PrinterSheet.UsedRange.SpecialCells(xlCellTypeConstants)
    Dim cell As Range
    Dim NumChars As Long
    Dim StartChar As Long
    Dim cellChar As Long
    Dim EndWords As Long
    Dim keywords As Range
    On Error Resume Next
    For Each cell In rng
        If left(Trim(cell.Value), 1) = "'" Or left(Trim(cell.Value), 3) = "Rem" Then
            cell.Font.color = ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("J4").Value
        Else
            cellChar = Len(cell)
            For Each keywords In ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("A1").CurrentRegion.OFFSET(1).RESIZE(, 1).SpecialCells(xlCellTypeConstants)
                If InStr(1, cell.TEXT, keywords) > 0 Then
                    StartChar = InStrExact(1, cell.TEXT, keywords.TEXT)
                    Do Until StartChar >= cellChar Or StartChar = 0
                        NumChars = Len(keywords.TEXT)
                        EndWords = StartChar + NumChars
                        If Mid(cell.TEXT, StartChar - 1, 1) = " " Or StartChar = 1 Then
                            If Mid(cell.TEXT, EndWords, 1) = " " Or EndWords >= cellChar Then
                                With cell.Characters(Start:=StartChar, Length:=NumChars).Font
                                    .FontStyle = "Bold"
                                    .color = ThisWorkbook.SHEETS("ProjectManagerTXTColour").Range("J3").Value
                                End With
                            End If
                        End If
                        StartChar = InStr(EndWords, cell.TEXT, keywords.TEXT)
                    Loop
                End If
            Next
        End If
    Next
End Sub

Sub ResetPrinter(Optional keepText As Boolean = False)
    Dim PrinterSheet As Worksheet
    Set PrinterSheet = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    With PrinterSheet
        .ResetAllPageBreaks
        .rows.VerticalAlignment = xlVAlignTop
        With .Cells
            If keepText = False Then
                .clear
            Else
                .ClearFormats
                .Font.ColorIndex = vbBlack
                .Font.Bold = False
            End If
            .Font.Name = "Consolas"
            .WrapText = False
            .UseStandardHeight = True
        End With
    End With
    For Each s In PrinterSheet.Shapes
        s.Delete
    Next
    Rem     If .PageSetup.Orientation = xlPortrait Then
    Rem         .Columns("B:B").ColumnWidth = 90
    Rem     Else
    Rem         .Columns("B:B").ColumnWidth = 120
    Rem     End If
End Sub

Sub PrintPDF()
    '#INCLUDE FoldersCreate
    Dim FilePath As String
    FilePath = Environ("USERprofile") & "\Documents\" & "vbArc\CodePrinter\"
    Dim fileName As String
    fileName = left(pmWorkbook.Name, InStr(1, pmWorkbook.Name, ".") - 1)
    Dim saveLocation As String
    saveLocation = FilePath
    If Dir(saveLocation, vbDirectory) = "" Then
        FoldersCreate saveLocation
    End If
    FilePath = saveLocation & fileName
    ThisWorkbook.Worksheets("ProjectManagerPrinter").visible = xlSheetVisible
    Dim TargetSheet As Worksheet
    Set TargetSheet = ThisWorkbook.SHEETS("ProjectManagerPrinter")
    TargetSheet.ExportAsFixedFormat xlTypePDF, FilePath
End Sub

Public Sub delay(seconds As Long)
    Dim endTime As Date
    endTime = DateAdd("s", seconds, Now())
    Do While Now() < endTime
        DoEvents
    Loop
End Sub

Sub UserformToPDF(wb As Workbook, Path As String)
    '#INCLUDE WindowToPDF
    '#INCLUDE PathMaker
    Application.VBE.MainWindow.visible = True
    Do While Application.VBE.MainWindow.visible = False
        Sleep 1000
    Loop
    Application.VBE.MainWindow.WindowState = vbext_ws_Maximize
    DoEvents
    Sleep 1000
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        If vbComp.Type = vbext_ct_MSForm Then
            vbComp.Activate
            DoEvents
            Sleep 3000
            Call WindowToPDF(PathMaker(Path, vbComp.Name, "pdf"))
        End If
    Next
End Sub

Sub ExportWorksheetsToPDF(wb As Workbook, expPath As String)
    '#INCLUDE PathMaker
    wb.Activate
    Dim ws As Worksheet
    For Each ws In wb.Worksheets
        Application.PrintCommunication = False
        With ws.PageSetup
            .FitToPagesWide = 1
            .FitToPagesTall = False
        End With
        Application.PrintCommunication = True
        If ws.UsedRange.count > 0 Then
            ws.ExportAsFixedFormat xlTypePDF, PathMaker(expPath, ws.Name, "pdf"), , True
        End If
    Next ws
End Sub

Rem @Folder WindowToPDF
Function WindowToPDF(pdf$, Optional Orientation As Integer = xlLandscape, _
                     Optional FitToPagesWide As Integer = 1) As Boolean
    Dim calc As Integer, ws As Worksheet
    With Application
        .ScreenUpdating = False
        .EnableEvents = False
        calc = .Calculation
        .Calculation = xlCalculationManual
    End With
    keybd_event VK_LMENU, 0, KEYEVENTF_EXTENDEDKEY, 0
    keybd_event VK_SNAPSHOT, 0, KEYEVENTF_EXTENDEDKEY, 0
    keybd_event VK_SNAPSHOT, 0, KEYEVENTF_EXTENDEDKEY + KEYEVENTF_KEYUP, 0
    keybd_event VK_LMENU, 0, KEYEVENTF_EXTENDEDKEY + KEYEVENTF_KEYUP, 0
    Set ws = Workbooks.Add(xlWBATWorksheet).Worksheets(1)
    Application.Wait (Now + TimeValue("0:00:2"))
    With ws
        .PasteSpecial Format:="Bitmap", link:=False, DisplayAsIcon:=False
        .Range("A1").Select
        .PageSetup.Orientation = Orientation
        .PageSetup.FitToPagesWide = FitToPagesWide
        .PageSetup.Zoom = False
        .ExportAsFixedFormat Type:=xlTypePDF, fileName:=pdf, _
                             quality:=xlQualityStandard, IncludeDocProperties:=True, _
                             IgnorePrintAreas:=False, OpenAfterPublish:=False
        .parent.Close False
    End With
    With Application
        .ScreenUpdating = True
        .EnableEvents = True
        .Calculation = calc
        .CutCopyMode = False
    End With
    WindowToPDF = Dir(pdf) <> ""
End Function

Function PathMaker(wbPath As String, fileName As String, fileExtention As String) As String
    If Right(wbPath, 1) <> "\" Then wbPath = wbPath & "\"
    PathMaker = wbPath & fileName & "." & fileExtention
    Do While InStr(1, PathMaker, "..") > 0
        PathMaker = Replace(PathMaker, "..", ".")
    Loop
End Function

Rem imports
Sub ImportComponents(wb As Workbook)
    '#INCLUDE ModuleExists
    '#INCLUDE IsArrayAllocated
    '#INCLUDE WorkbookIsOpen
    '#INCLUDE GetFilePartPath
    '#INCLUDE getFilePartName
    '#INCLUDE GetFilePath
    Dim varr
    Dim element
    Dim Proceed As Boolean, hasWorksheets As Boolean
    Proceed = True
    Dim compName As String
    varr = GetFilePath(Array("bas", "frm", "cls"), True)
    If Not IsArrayAllocated(varr) Then Exit Sub
    Dim vbProj As VBProject
    Set vbProj = wb.VBProject
    Dim coll As Collection
    Set coll = New Collection
    For Each element In varr
        compName = getFilePartName(CStr(element), False)
        Debug.Print compName
        If compName Like "DocClass*" Then
            compName = Right(compName, Len(compName) - 6)
            hasWorksheets = True
        End If
        If ModuleExists(compName, wb) = True Then
            Proceed = False
            coll.Add compName
        End If
    Next element
    If Proceed = False Then GoTo ErrorHandler
    Dim WasOpen As Boolean
    Dim wbSource As Workbook
    Dim wbSourceName As String
    Dim basePath As String
    basePath = GetFilePartPath(varr(1), True)
    If hasWorksheets = True Then
        wbSourceName = Dir(basePath & "*.xl*")
        If wbSourceName <> "" Then
            WasOpen = WorkbookIsOpen(wbSourceName)
            If WasOpen = False Then
                Set wbSource = Workbooks.Open(basePath & wbSourceName)
            Else
                Set wbSource = Workbooks(wbSourceName)
            End If
        End If
    End If
    For Each element In varr
        compName = getFilePartName(CStr(element), False)
        If Not compName Like "DocClass*" Then
            vbProj.VBComponents.Import element
        Else
            compName = Right(compName, Len(compName) - 9)
            If compName <> "ThisWorkbook" Then
                wbSource.SHEETS(compName).Copy Before:=wb.SHEETS(1)
            End If
        End If
    Next element
    GoTo ExitHandler
ErrorHandler:
    Dim str As String
    str = "The following components already exist. All import canceled."
    For Each element In coll
        str = str & vbNewLine & element
    Next element
    MsgBox str
    Exit Sub
ExitHandler:
    If WasOpen = False And WorkbookIsOpen(wbSourceName) Then wbSource.Close False
    Set vbProj = Nothing
    Set coll = Nothing
    Set wbSource = Nothing
    MsgBox "Import successful"
End Sub

Rem exports
Sub ExportProject( _
    wb As Workbook, _
    Optional ExportSheets As Boolean, _
    Optional ExportForms As Boolean, _
    Optional PrintCode As Boolean, _
    Optional bSeparateProcedures As Boolean, _
    Optional bExportComponents As Boolean, _
    Optional bWorkbookBackup As Boolean, _
    Optional bExportUnified As Boolean, _
    Optional bExportDeclarations As Boolean, _
    Optional bExportReferences As Boolean, _
    Optional bExportXML As Boolean)
    '#INCLUDE GetCompText
    '#INCLUDE ProcListCollection
    '#INCLUDE GetProcText
    '#INCLUDE GetSheetByCodeName
    '#INCLUDE PrintProject
    '#INCLUDE UserformToPDF
    '#INCLUDE ExportWorksheetsToPDF
    '#INCLUDE ExportReferencesToConfigFile
    '#INCLUDE ArrayToString
    '#INCLUDE FollowLink
    '#INCLUDE FoldersCreate
    '#INCLUDE TxtAppend
    '#INCLUDE CollectionsToArrayTable
    '#INCLUDE compare
    '#INCLUDE getDeclarations
    Dim workbookCleanName    As String: workbookCleanName = left(wb.Name, InStrRev(wb.Name, ".") - 1)
    Dim workbookExtension    As String: workbookExtension = Right(wb.Name, Len(wb.Name) - InStr(1, wb.Name, "."))
    Dim MainPath             As String: MainPath = Environ("USERprofile") & "\Documents\" & "vbArc\Code Library\"
    Dim exportPath           As String: exportPath = MainPath & workbookCleanName & "\"
    exportPath = exportPath & Format(Now, "YY-MM-DD HHNN") & "\"
    Rem create folders
    FoldersCreate exportPath
    Dim procColl As Collection, Procedure As Variant, vbComp As VBComponent, Extension As String
    If bExportComponents = True Then
        Rem Export Components
        For Each vbComp In wb.VBProject.VBComponents
            Select Case vbComp.Type
                Case vbext_ct_ClassModule, vbext_ct_Document: Extension = ".cls"
                Case vbext_ct_MSForm:       Extension = ".frm"
                Case vbext_ct_StdModule:    Extension = ".bas"
                Case Else:                  Extension = ".txt"
            End Select
            Rem if you import a docclass by this project,
            Rem it will open the original exported file and copy the sheet
            If vbComp.Type = vbext_ct_Document Then
                If vbComp.Name = "ThisWorkbook" Then
                    vbComp.Export exportPath & "DocClass " & vbComp.Name & Extension
                Else
                    vbComp.Export exportPath & "DocClass " & GetSheetByCodeName(wb, vbComp.Name).Name & Extension
                End If
            Else
                Rem export component
                vbComp.Export exportPath & vbComp.Name & Extension
            End If
        Next
    End If
    Rem export workbook backup
    If bWorkbookBackup = True Then
        wb.SaveCopyAs exportPath & wb.Name
    End If
    Rem export references
    If bExportReferences = True Then
        ExportReferencesToConfigFile pmWorkbook, exportPath
    End If
    Rem export declarations
    If bExportDeclarations = True Then
        Dim DeclarationArray As Variant
        DeclarationArray = CollectionsToArrayTable(getDeclarations(pmWorkbook))
        If TypeName(DeclarationArray) <> "Empty" Then
            TxtAppend exportPath & "Declarations.txt", ArrayToString(DeclarationArray)
        End If
    End If
    Rem export unified code to easily compare changes
    If bExportUnified Then
        Dim Code As String, tmp As String
        For Each vbComp In wb.VBProject.VBComponents
            tmp = "'" & vbComp.Name & vbTab & vbComp.Type & vbNewLine & vbNewLine & GetCompText(vbComp)
            Code = IIf(Code = "", tmp, Code & vbNewLine & vbNewLine & tmp)
        Next
        TxtAppend exportPath & "#UnifiedProject.txt", Code
    End If
    If bExportXML = True Then
        Rem Export ribbon xml (by JKP)
        Rem         Dim FullPath As String
        Rem         FullPath = wb.FullName
        Rem         wb.Close True
        Dim tmpFile As String
        tmpFile = ThisWorkbook.Path & "\temp_workbook_file" & Mid(wb.Name, InStr(1, wb.Name, "."))
        wb.SaveCopyAs tmpFile
        Dim c As New clsEditOpenXML
        Rem c.ExtractRibbonX FullPath, exportPath & "customUI.xml"
        c.ExtractRibbonX tmpFile, exportPath & "customUI.xml"
        Kill tmpFile
        Set c = Nothing
        Rem Workbooks.Open FullPath
    End If
    Rem Export procedures separately
    If bSeparateProcedures = True Then
        Dim ProcedurePath As String
        Dim ans As Long
        ans = MsgBox("If there are too many procedures the proccess will be slow. Proceed?", vbYesNo)
        If ans = vbYes Then
            For Each vbComp In wb.VBProject.VBComponents
                ProcedurePath = exportPath & vbComp.Name & " Procedures\"
                FoldersCreate ProcedurePath
                Set procColl = ProcListCollection(vbComp)
                Rem export component
                For Each Procedure In procColl
                    TxtAppend ProcedurePath & Procedure & ".txt", GetProcText(vbComp, CStr(Procedure))
                Next Procedure
            Next
        End If
    End If
    Rem Print to PDF, original feature (codeblocks linked, choose colour scheme)
    If PrintCode = True Then
        PrintFileName = wb.Name
        PrintProject wb
    End If
    Rem export Userform To PDF
    If ExportForms = True Then
        If wb.Name <> ThisWorkbook.Name Then UserformToPDF wb, exportPath
    End If
    Rem Export Worksheets To Image
    If ExportSheets = True Then
        Dim EXT As String: EXT = Right(wb.Name, Len(wb.Name) - InStr(1, wb.Name, "."))
        If EXT = "xlam" Or EXT = "xla" Then wb.IsAddin = False
        ExportWorksheetsToPDF wb, exportPath
        Sleep 1000
        If EXT = "xlam" Or EXT = "xla" Then wb.IsAddin = True
    End If
    Sleep 1000
    MsgBox "Export complete"
    Rem open export folder
    Rem FollowLink exportPath
End Sub

Rem by Todar
Public Sub ExportReferencesToConfigFile(TargetWorkbook As Workbook, RefPath As String)
    '#INCLUDE OpenTextFile
    Dim myProject As VBProject
    Set myProject = TargetWorkbook.VBProject
    Dim fso As New Scripting.FileSystemObject
    With fso.OpenTextFile(RefPath & "References.Txt", ForWriting, True)
        Dim library As Reference
        For Each library In myProject.REFERENCES
            .WriteLine library.Name & vbTab & library.GUID & vbTab & library.Major & vbTab & library.Minor
        Next
    End With
End Sub

Rem @TODO
Public Sub ImportReferencesFromConfigFile()
    '#INCLUDE OpenTextFile
    Dim fso As New Scripting.FileSystemObject
    With fso.OpenTextFile(exportPath & "References.Txt", ForReading, True)
        Dim line As Long
        Do While Not .AtEndOfStream
            Dim values As Variant
            values = Split(.ReadLine, vbTab)
            On Error Resume Next
            ThisWorkbook.VBProject.REFERENCES.AddFromGuid values(1), values(2), values(3)
        Loop
    End With
End Sub

Sub RefreshComponents(wkbSource As Workbook)
    '#INCLUDE ExportModules
    '#INCLUDE ImportModules
    If wkbSource.Name <> ThisWorkbook.Name Then
        ExportModules wkbSource
        ImportModules wkbSource
    Else
        MsgBox "Can't run this procedure on myself"
    End If
End Sub

Public Sub ExportModules(wkbSource As Workbook)
    '#INCLUDE FolderWithVBAProjectFiles
    Dim bExport As Boolean
    Dim szExportPath As String
    Dim szFileName As String
    Dim cmpComponent As VBIDE.VBComponent
    If FolderWithVBAProjectFiles = "Error" Then
        MsgBox "Export Folder not exist"
        Exit Sub
    End If
    On Error Resume Next
    Kill FolderWithVBAProjectFiles & "\*.*"
    On Error GoTo 0
    szExportPath = FolderWithVBAProjectFiles & "\"
    For Each cmpComponent In wkbSource.VBProject.VBComponents
        bExport = True
        szFileName = cmpComponent.Name
        Select Case cmpComponent.Type
            Case vbext_ct_ClassModule
                szFileName = szFileName & ".cls"
            Case vbext_ct_MSForm
                szFileName = szFileName & ".frm"
            Case vbext_ct_StdModule
                szFileName = szFileName & ".bas"
            Case vbext_ct_Document
                bExport = False
        End Select
        If bExport Then
            cmpComponent.Export szExportPath & szFileName
        End If
    Next cmpComponent
End Sub

Public Sub ImportModules(wkbTarget As Workbook)
    '#INCLUDE FolderWithVBAProjectFiles
    '#INCLUDE DeleteVBAModulesAndUserForms
    '#INCLUDE getFolder
    Dim objFSO As Scripting.FileSystemObject
    Dim objFile As Scripting.file
    Dim szImportPath As String
    Dim szFileName As String
    Dim cmpComponents As VBIDE.VBComponents
    If wkbTarget.Name = ThisWorkbook.Name Then
        MsgBox "Select another destination workbook" & _
               "Not possible to import in this workbook "
        Exit Sub
    End If
    If FolderWithVBAProjectFiles = "Error" Then
        MsgBox "Import Folder not exist"
        Exit Sub
    End If
    szImportPath = FolderWithVBAProjectFiles & "\"
    Set objFSO = New Scripting.FileSystemObject
    If objFSO.getFolder(szImportPath).Files.count = 0 Then
        MsgBox "There are no files to import"
        Exit Sub
    End If
    Call DeleteVBAModulesAndUserForms(wkbTarget)
    Set cmpComponents = wkbTarget.VBProject.VBComponents
    For Each objFile In objFSO.getFolder(szImportPath).Files
        If (objFSO.GetExtensionName(objFile.Name) = "cls") Or _
                                                           (objFSO.GetExtensionName(objFile.Name) = "frm") Or _
                                                           (objFSO.GetExtensionName(objFile.Name) = "bas") Then
            cmpComponents.Import objFile.Path
        End If
    Next objFile
End Sub

Function FolderWithVBAProjectFiles() As String
    '#INCLUDE FolderExists
    Dim WshShell As Object
    Dim fso As Object
    Dim SpecialPath As String
    Set WshShell = CreateObject("WScript.Shell")
    Set fso = CreateObject("scripting.filesystemobject")
    SpecialPath = WshShell.SpecialFolders("MyDocuments")
    If Right(SpecialPath, 1) <> "\" Then
        SpecialPath = SpecialPath & "\"
    End If
    If fso.FolderExists(SpecialPath & "VBAProjectFiles") = False Then
        On Error Resume Next
        MkDir SpecialPath & "VBAProjectFiles"
        On Error GoTo 0
    End If
    If fso.FolderExists(SpecialPath & "VBAProjectFiles") = True Then
        FolderWithVBAProjectFiles = SpecialPath & "VBAProjectFiles"
    Else
        FolderWithVBAProjectFiles = "Error"
    End If
End Function

Sub DeleteVBAModulesAndUserForms(wkbSource As Workbook)
    Dim vbProj As VBIDE.VBProject
    Dim vbComp As VBIDE.VBComponent
    Set vbProj = wkbSource.VBProject
    For Each vbComp In vbProj.VBComponents
        If vbComp.Type = vbext_ct_Document Then
        Else
            vbProj.VBComponents.Remove vbComp
        End If
    Next vbComp
End Sub

Sub AutofitMergedCells(TargetRange As Range)
    '#INCLUDE StartOptimizeCodeRun
    '#INCLUDE StopOptimizeCodeRun
    Dim mw As Single
    Dim cM As Range
    Dim rng As Range
    Dim cw As Double
    Dim rwht As Double
    Dim ar As Variant
    Dim i As Integer
    StartOptimizeCodeRun
    Dim cell As Range
    Dim TimeStarted
    TimeStarted = Now()
    For Each cell In TargetRange
        If cell.MergeCells = True Then
            Set rng = Range(cell.MergeArea.Address)
            rng.MergeCells = False
            cw = rng.Cells(1).ColumnWidth
            mw = 0
            For Each cM In rng
                cM.WrapText = True
                mw = cM.ColumnWidth + mw
            Next
            mw = mw + rng.Cells.count * 0.66
            rng.Cells(1).ColumnWidth = mw
            rng.EntireRow.AutoFit
            rwht = rng.RowHeight
            rng.Cells(1).ColumnWidth = cw
            rng.MergeCells = True
            rng.RowHeight = rwht
        End If
        If Now > TimeStarted + TimeSerial(0, 1, 0) Then Stop
    Next
    StopOptimizeCodeRun
End Sub



'clsEditOpenXML	2

Option Explicit
Private mbCreateBackup As Boolean
Private mvSourceFile As Variant
Private msSheet2Change As String
Private msSheetId As String
Private msSheetFileName As String
Private mbAddedZip As Boolean
Private mvXMLFolderRoot As Variant
Private mvxmlfolder As Variant
Public Enum XMLFolder
    XMLFolder_root = 1
    XMLFolder_rels = 2
    XMLFolder_xl = 3
    XMLFolder_customUI = 4
    XMLFolder_docProps = 5
End Enum

Public Sub ExtractRibbonX(sFullFile As String, sSaveFile As String)
    Dim cEditOpenXML As clsEditOpenXML
    Dim sXML As String
    Dim oXMLDoc As MSXML2.DOMDocument
    Set cEditOpenXML = New clsEditOpenXML
    With cEditOpenXML
        .CreateBackup = False
        .SourceFile = sFullFile
        .UnzipFile
        sXML = .GetXMLFromFile("customUI.xml", XMLFolder_customUI)
        If Len(sXML) > 0 Then
            Set oXMLDoc = New DOMDocument
            oXMLDoc.loadXML sXML
            oXMLDoc.Save sSaveFile
        End If
        sXML = .GetXMLFromFile("customUI14.xml", XMLFolder_customUI)
        If Len(sXML) > 0 Then
            Set oXMLDoc = New DOMDocument
            oXMLDoc.loadXML sXML
            oXMLDoc.Save Replace(sSaveFile, ".xml", "14.xml")
        End If
    End With
    Set cEditOpenXML = Nothing
End Sub

Public Sub WriteRibbonXML2File(sFile As String, sXML As String)
    Dim cEditOpenXML As clsEditOpenXML
   
    Set cEditOpenXML = New clsEditOpenXML
   
    With cEditOpenXML
        .SourceFile = sFile
       
        .UnzipFile
       
        .WriteXML2File sXML, "customUI.xml", XMLFolder_customUI
       
        .ZipAllFilesInFolder
    End With
   
    Set cEditOpenXML = Nothing
End Sub

Public Function GetXMLFromFile(sFilename As String, sXMLFolder As XMLFolder) As String
    Dim oXMLDoc As MSXML2.DOMDocument
    If Len(XMLFolder(sXMLFolder)) = 0 Then
        GetXMLFromFile = ""
    Else
        Set oXMLDoc = New MSXML2.DOMDocument
        oXMLDoc.Load XMLFolder(sXMLFolder) & sFilename
        GetXMLFromFile = oXMLDoc.xml
        Set oXMLDoc = Nothing
    End If
End Function

Public Sub WriteXML2File(sXML As String, sFilename As String, sXMLFolder As XMLFolder)
    Dim oXMLDoc As MSXML2.DOMDocument
    Set oXMLDoc = New MSXML2.DOMDocument
    If sXMLFolder = XMLFolder_customUI Then
        If Not FolderExists(XMLFolder(XMLFolder_customUI)) Then
            MkDir XMLFolder(XMLFolder_customUI)
            oXMLDoc.loadXML sXML
            oXMLDoc.Save XMLFolder(sXMLFolder) & sFilename
            AddCustomUIToRels
        End If
    End If
    oXMLDoc.loadXML sXML
    oXMLDoc.Save XMLFolder(sXMLFolder) & sFilename
End Sub

Public Sub AddCustomUIToRels()
    Dim oXMLDoc As MSXML2.DOMDocument
    Dim oXMLElement As MSXML2.IXMLDOMNode
    Dim oXMLAttrib As MSXML2.IXMLDOMAttribute
    Dim oNamedNodeMap As MSXML2.IXMLDOMNamedNodeMap
    Dim oXMLRelsList As MSXML2.IXMLDOMNodeList
    Set oXMLDoc = New MSXML2.DOMDocument
    oXMLDoc.Load XMLFolder(XMLFolder_rels) & ".rels"
    Set oXMLElement = oXMLDoc.createNode(1, "Relationship", "http://schemas.openxmlformats.org/package/2006/relationships")
    Set oNamedNodeMap = oXMLElement.Attributes
    Set oXMLAttrib = oXMLDoc.createAttribute("Id")
    oXMLAttrib.nodeValue = "cuID"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLAttrib = oXMLDoc.createAttribute("Type")
    oXMLAttrib.nodeValue = "http://schemas.microsoft.com/office/2006/relationships/ui/extensibility"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLAttrib = oXMLDoc.createAttribute("Target")
    oXMLAttrib.nodeValue = "customUI/customUI.xml"
    oNamedNodeMap.setNamedItem oXMLAttrib
    Set oXMLRelsList = oXMLDoc.selectNodes("/Relationships")
    oXMLRelsList.item(0).appendChild oXMLElement
    oXMLDoc.Save XMLFolder(XMLFolder_rels) & ".rels"
    Set oXMLAttrib = Nothing
    Set oXMLElement = Nothing
    Set oXMLDoc = Nothing
End Sub

Private Function GetSheetIdFromSheetName(sSheetName) As String
    Dim oXMLDoc As MSXML2.DOMDocument
    Dim oxmlNode As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    Dim oXMLTemp As MSXML2.IXMLDOMNode
    If XMLFolder(XMLFolder_xl) <> "" And Sheet2Change <> "" Then
        Set oXMLDoc = New MSXML2.DOMDocument
        oXMLDoc.Load XMLFolder(XMLFolder_xl) & "workbook.xml"
        For Each oxmlNode In oXMLDoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.baseName = "sheets" Then
                    For Each oXMLTemp In oXMLChildNode.ChildNodes
                        If oXMLTemp.Attributes.getNamedItem("name").nodeValue = sSheetName Then
                            GetSheetIdFromSheetName = oXMLTemp.Attributes.getNamedItem("r:id").nodeValue
                            Exit Function
                        End If
                    Next
                End If
            Next
        Next
    End If
End Function

Public Function GetSheetFileNameFromId(sSheetId As String) As String
    Dim oXMLDoc As MSXML2.DOMDocument
    Dim oxmlNode As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    If XMLFolder(XMLFolder_xl) <> "" And Sheet2Change <> "" Then
        Set oXMLDoc = New MSXML2.DOMDocument
        oXMLDoc.Load XMLFolder(XMLFolder_xl) & "_rels\workbook.xml.rels"
        For Each oxmlNode In oXMLDoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.Attributes.getNamedItem("Id").nodeValue = sSheetId Then
                    GetSheetFileNameFromId = oXMLChildNode.Attributes.getNamedItem("Target").nodeValue
                    Exit Function
                End If
            Next
        Next
    End If
End Function

Private Function GetSheetNameFromId(sId As String) As String
    Dim oXMLDoc As MSXML2.DOMDocument
    Dim oxmlNode As MSXML2.IXMLDOMNode
    Dim oXMLChildNode As MSXML2.IXMLDOMNode
    Dim oXMLChildChildNode As MSXML2.IXMLDOMNode
    If mvxmlfolder(XMLFolder_xl) <> "" Then
        Set oXMLDoc = New MSXML2.DOMDocument
        oXMLDoc.Load XMLFolder(XMLFolder_xl) & "workbook.xml"
        For Each oxmlNode In oXMLDoc.ChildNodes
            For Each oXMLChildNode In oxmlNode.ChildNodes
                If oXMLChildNode.nodeName = "sheets" Then
                    For Each oXMLChildChildNode In oXMLChildNode.ChildNodes
                        If oXMLChildChildNode.Attributes.getNamedItem("r:id").nodeValue = "rId" & val(sId) + 1 Then
                            GetSheetNameFromId = oXMLChildChildNode.Attributes.getNamedItem("name").nodeValue
                            Exit Function
                        End If
                    Next
                    Exit Function
                End If
            Next
        Next
    End If
End Function

Public Sub ZipAllFilesInFolder()
    Dim oShellApp As Object
    Dim sDate As String
    Dim sDefPath As String
    Dim vFileNameZip As Variant
    Dim fso As Object
    Dim lFileCt As Long
    Set fso = CreateObject("scripting.filesystemobject")
    sDate = Format(Now, " dd-mmm-yy h-mm-ss")
    vFileNameZip = SourceFile & sDate & ".zip"
    NewZip vFileNameZip
    Set oShellApp = CreateObject("Shell.Application")
    lFileCt = oShellApp.Namespace(FolderName & "Unzipped " & fileName & Application.PathSeparator).items.count
    oShellApp.Namespace(vFileNameZip).CopyHere oShellApp.Namespace(FolderName & "Unzipped " & fileName & Application.PathSeparator).items
    On Error Resume Next
    Do Until oShellApp.Namespace(vFileNameZip).items.count = lFileCt
        Application.Wait (Now + TimeValue("0:00:01"))
    Loop
    DoEvents
    Kill SourceFile
    Name vFileNameZip As SourceFile
    On Error Resume Next
    fso.DeleteFolder FolderName & "Unzipped " & fileName, True
    On Error GoTo 0
    Set oShellApp = Nothing
End Sub

Public Sub UnzipFile()
    Dim fso As Object
    Dim oShellApp As Object
    Set fso = CreateObject("scripting.filesystemobject")
    XMLFolderRoot = FolderName
    If Right(XMLFolderRoot, 1) <> Application.PathSeparator Then
        XMLFolderRoot = XMLFolderRoot & "\UnZipped " & fileName & Application.PathSeparator
    Else
        XMLFolderRoot = XMLFolderRoot & "UnZipped " & fileName & Application.PathSeparator
    End If
    On Error Resume Next
    fso.DeleteFolder XMLFolderRoot & "*", True
    Kill XMLFolderRoot & "*.*"
    If FolderExists(XMLFolderRoot) = False Then
        MkDir XMLFolderRoot
    End If
    Set oShellApp = CreateObject("Shell.Application")
    oShellApp.Namespace(XMLFolderRoot).CopyHere oShellApp.Namespace(SourceFile).items
    On Error Resume Next
    fso.DeleteFolder Environ("Temp") & "\Temporary Directory*", True
    Set oShellApp = Nothing
    Set fso = Nothing
    Exit Sub
End Sub

Sub NewZip(sPath)
    If Len(Dir(sPath)) > 0 Then Kill sPath
    Open sPath For Output As #1
    Print #1, Chr$(80) & Chr$(75) & Chr$(5) & Chr$(6) & String(18, 0)
    Close #1
End Sub

Public Property Get CreateBackup() As Boolean
    CreateBackup = mbCreateBackup
End Property

Public Property Let CreateBackup(ByVal bCreateBackup As Boolean)
    mbCreateBackup = bCreateBackup
End Property

Private Sub Class_Initialize()
    CreateBackup = True
End Sub

Public Property Get SourceFile() As Variant
    SourceFile = mvSourceFile
End Property

Public Property Let SourceFile(ByVal vSourceFile As Variant)
    mvSourceFile = vSourceFile
    If CreateBackup Then
        If Len(Dir(vSourceFile & "(backup)")) > 0 Then
            Kill vSourceFile & "(backup)"
        End If
        FileCopy vSourceFile, vSourceFile & "(backup)"
    End If
    If Not vSourceFile Like "*.zip" Then
        Name vSourceFile As vSourceFile & ".zip"
        mvSourceFile = mvSourceFile & ".zip"
        AddedZip = True
    End If
End Property

Public Property Get FolderName() As Variant
    FolderName = Mid(SourceFile, 1, InStrRev(SourceFile, Application.PathSeparator))
End Property

Public Property Get fileName() As Variant
    If SourceFile <> "" Then
        fileName = Mid(SourceFile, InStrRev(SourceFile, Application.PathSeparator) + 1, Len(SourceFile))
    End If
End Property

Public Property Get XMLFolder(sXMLFolder As XMLFolder) As String
    Select Case sXMLFolder
        Case Is = XMLFolder_root
            XMLFolder = mvXMLFolderRoot
        Case Is = XMLFolder_customUI
            XMLFolder = mvXMLFolderRoot & "customUI" & Application.PathSeparator
        Case Is = XMLFolder_docProps
            XMLFolder = mvXMLFolderRoot & "docProps" & Application.PathSeparator
        Case Is = XMLFolder_rels
            XMLFolder = mvXMLFolderRoot & "_rels" & Application.PathSeparator
        Case Is = XMLFolder_xl
            XMLFolder = mvXMLFolderRoot & "xl" & Application.PathSeparator
    End Select
End Property

Public Property Get Sheet2Change() As String
    Sheet2Change = msSheet2Change
End Property

Public Property Let Sheet2Change(ByVal sSheet2Change As String)
    msSheet2Change = sSheet2Change
    SheetId = GetSheetIdFromSheetName(sSheet2Change)
    If SheetId <> "" Then
        SheetFileName = GetSheetFileNameFromId(SheetId)
    End If
End Property

Public Property Get SheetId() As String
    SheetId = msSheetId
End Property

Public Property Let SheetId(ByVal sSheetId As String)
    msSheetId = sSheetId
End Property

Public Property Get SheetFileName() As String
    SheetFileName = msSheetFileName
End Property

Public Property Let SheetFileName(ByVal sSheetFileName As String)
    msSheetFileName = sSheetFileName
End Property

Private Property Get AddedZip() As Boolean
    AddedZip = mbAddedZip
End Property

Private Property Let AddedZip(ByVal bAddedZip As Boolean)
    mbAddedZip = bAddedZip
End Property

Private Sub Class_Terminate()
    Dim fso As Object
    If AddedZip Then
        Name SourceFile As left(SourceFile, Len(SourceFile) - 4)
    End If
    On Error Resume Next
    fso.DeleteFolder XMLFolderRoot, True
End Sub

Private Property Get XMLFolderRoot() As Variant
    XMLFolderRoot = mvXMLFolderRoot
End Property

Private Property Let XMLFolderRoot(ByVal vXMLFolderRoot As Variant)
    mvXMLFolderRoot = vXMLFolderRoot
End Property


'uSnippets	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uSnippets
'* Created    : 06-10-2022 10:41
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private SnippetsFolder As String
Dim moResizer As New CFormResizer

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    uSnipIndex = -1
    uSnipFilter = ""
    ThisWorkbook.SHEETS("uSnippets").Range("B1") = uSnipFilter
    ThisWorkbook.SHEETS("uSnippets").Range("B2") = uSnipIndex
    Unload Me
End Sub

Private Sub UserForm_Resize()
    moResizer.FormResize
End Sub

Private Sub UserForm_Initialize()
    If ShowInVBE = True Then
        Application.VBE.MainWindow.visible = True
        MakeUserFormChildOfVBEditor Me.Caption
    End If
    Set moResizer.form = Me
    SnippetsFolder = Environ("USERprofile") & "\My Documents\vbArc\Snippets\"
    If FolderExists(SnippetsFolder) = False Then FoldersCreate (SnippetsFolder)

    '@here
    If Right(SnippetsFolder, 1) <> "\" Then SnippetsFolder = SnippetsFolder & "\"
    GetFilesUSnippets
    
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("uSnippets")
    uSnipFilter = ws.Range("B1")
    tFilterSnippets.TEXT = uSnipFilter
    Dim uSnipIndex As String
    uSnipIndex = ws.Range("B2").TEXT
    If uSnipIndex <> "" Then SelectListboxItems Me.LSnippets, uSnipIndex
End Sub

Sub SwitchParent()
    'Debug.Print Application.r
    Stop
End Sub

Sub GetFilesUSnippets()
    LSnippets.clear
    Dim Files As Collection: Set Files = LoopThroughFiles(SnippetsFolder, "*.txt")
    Dim file
    For Each file In Files
        LSnippets.AddItem file
    Next
End Sub

Private Sub CommandButton1_Click()
    tFilterSnippets.TEXT = ""
    LSnippets.ListIndex = -1
End Sub

Private Sub cResize_Click()
    If Me.Height < 429 Then
        Me.Height = 429
    Else
        Me.Height = 60
        Me.Width = 100
    End If

    Me.Show
End Sub

Private Sub cSnippetFolder_Click()
    FollowLink SnippetsFolder
End Sub

Private Sub Image2_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub LSnippets_Click()
    Dim sPath As String
    sPath = SnippetsFolder & LSnippets.list(LSnippets.ListIndex)
    LSnippetsPreview.TEXT = TxtRead(sPath)
End Sub

Private Sub cCopySnippet_Click()
    If Len(LSnippetsPreview.TEXT) = 0 Then Exit Sub
    Dim s As String
    If LSnippetsPreview.SelLength = 0 Then
        s = LSnippetsPreview.TEXT
    Else
        s = LSnippetsPreview.SelText
    End If
    CLIP s
    cResize_Click
    MsgBox "Snipet copied"
End Sub

Private Sub cOverwriteSnippet_Click()
    Dim sPath As String
    Dim isNew As Boolean
    Dim wasResized As Boolean
    If LSnippets.ListIndex = -1 Then
        Dim ans As String
        cResize_Click
        ans = InputboxString(, "Select name for new file")
        If Len(ans) = 0 Then GoTo ExitHandler
        sPath = SnippetsFolder & ans & ".txt"
        isNew = True
        wasResized = True
    Else
        sPath = SnippetsFolder & LSnippets.list(LSnippets.ListIndex)
    End If
    TxtOverwrite sPath, LSnippetsPreview.TEXT
    If isNew = True Then
        LSnippets.AddItem ans & ".txt"
        LSnippets.ListIndex = LSnippets.ListCount - 1
    End If
ExitHandler:
    If wasResized = True Then cResize_Click
End Sub

Private Sub cSnippetDelete_Click()
    cResize_Click
    Dim Proceed As Long
    Proceed = MsgBox("Delete " & LSnippets.list(LSnippets.ListIndex) & "?", vbYesNo)
    If Proceed = vbNo Then Exit Sub
    Dim sPath As String
    sPath = SnippetsFolder & LSnippets.list(LSnippets.ListIndex)
    Dim fso As Scripting.FileSystemObject
    Set fso = New Scripting.FileSystemObject
    fso.DeleteFile sPath
    LSnippets.RemoveItem LSnippets.ListIndex
    LSnippetsPreview.TEXT = ""
    LSnippets.ListIndex = -1
    cResize_Click
End Sub

Private Sub cSnippetStartNew_Click()
    Dim NewName As String
    cResize_Click
    NewName = InputBox("New Snippet Name")
    If NewName = "" Then GoTo ExitHandler
    Dim sPath As String
    sPath = SnippetsFolder & NewName & ".txt"
    If FileExists(sPath) Then Exit Sub
    LSnippets.ListIndex = -1
    LSnippetsPreview.TEXT = ""
    TxtOverwrite sPath, ""
    LSnippets.AddItem NewName & ".txt"
    LSnippets.ListIndex = LSnippets.ListCount - 1
    LSnippetsPreview.SetFocus
ExitHandler:
    cResize_Click
End Sub

Private Sub LSnippetsPreview_Enter()
    LSnippetsPreview.SelStart = 0
End Sub

Private Sub tFilterSnippets_Change()
    GetFilesUSnippets
    FilterListboxByColumn LSnippets, tFilterSnippets.TEXT
End Sub


'CFormResizer	2

Rem ***************************************************************************
Rem *
Rem * MODULE NAME:     USERFORM RESIZER CLASS
Rem * AUTHOR & DATE:   STEPHEN BULLEN, Office Automation Ltd
Rem *
Rem * CONTACT:         Stephen@oaltd.co.uk
Rem * WEB SITE:        http://www.oaltd.co.uk
Rem *
Rem * DESCRIPTION:     Handles the resizing and repositioning of controls on a userform
Rem *
Rem ***************************************************************************
Rem IN USERFORM
Rem
Rem Dim moResizer As New CFormResizer
Rem Private Sub UserForm_Activate()
Rem     Set moResizer.Form = Me
Rem End Sub
Rem Private Sub UserForm_Resize()
Rem     moResizer.FormResize
Rem End Sub
Rem This class makes a userform resizable and handles the resizing of all the controls on the userform,
Rem such that their physical dimensions (e.g. size and position) change as the form is resized.
Rem To specify which control(s) to resize (and how), you set the control's .Tag property at design time to
Rem indicate that the control's top, left, width and height should be adjusted as the form's size changes.
Rem
Rem Use the letters t, l, w and h in any order (or not at all) to state that the property should change as the form
Rem is resized.  Follow the property by a decimal to indicate that the control should change by a percentage of the
Rem form's change.
Rem
Rem For example:
Rem   hw           Sets the control's height and width to change with the form (e.g. if there's a single list box on the form)
Rem   tl           Sets the contol's top and left to change in line with the form (e.g. to keep it in the bottom-right corner)
Rem   w0.5         Sets the control's width to change by 0.5 that of the form's width change
Rem   w0.5l0.5     Sets the control's width and position to change by 0.5 that of the form's width change
Rem Windows API calls to do all the dirty work!

Option Explicit
Private Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Private Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Private Declare PtrSafe Function ShowWindow Lib "user32" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long
Private Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
Private Declare PtrSafe Function SetFocus Lib "user32" (ByVal hWnd As Long) As Long
Private Const GWL_STYLE As Long = (-16)
Private Const WS_THICKFRAME As Long = &H40000
Private Const SW_SHOW As Long = 5
Dim moForm As Object
Dim mdWidth As Double
Dim mdHeight As Double

Public Property Set form(oNew As Object)
    Dim hWndForm As Long, iStyle As Long
    Set moForm = oNew
    If val(Application.Version) < 9 Then
        hWndForm = FindWindow("ThunderXFrame", moForm.Caption)
    Else
        hWndForm = FindWindow("ThunderDFrame", moForm.Caption)
    End If
    iStyle = GetWindowLong(hWndForm, GWL_STYLE)
    iStyle = iStyle Or WS_THICKFRAME
    SetWindowLong hWndForm, GWL_STYLE, iStyle
    ShowWindow hWndForm, SW_SHOW
    DrawMenuBar hWndForm
    SetFocus hWndForm
    mdWidth = moForm.Width
    mdHeight = moForm.Height
End Property

Public Sub FormResize()
    Dim dWidthAdj As Double, dHeightAdj As Double, sTag As String
    Dim oCtl As MSForms.control
    If mdWidth = 0 Then mdWidth = moForm.Width
    If mdHeight = 0 Then mdHeight = moForm.Height
    dWidthAdj = moForm.Width - mdWidth
    dHeightAdj = moForm.Height - mdHeight
    For Each oCtl In moForm.Controls
        With oCtl
            sTag = UCase(.Tag)
            If InStr(1, sTag, "L", vbBinaryCompare) Then
                If .left + dWidthAdj <= 0 Then moForm.Width = mdWidth
            End If
            If InStr(1, sTag, "W", vbBinaryCompare) Then
                If .Width + dWidthAdj <= 0 Then moForm.Width = mdWidth
            End If
            If InStr(1, sTag, "T", vbBinaryCompare) Then
                If .top + dHeightAdj <= 0 Then moForm.Height = mdHeight
            End If
            If InStr(1, sTag, "H", vbBinaryCompare) Then
                If .Height + dHeightAdj <= 0 Then moForm.Height = mdHeight
            End If
        End With
    Next
    dWidthAdj = moForm.Width - mdWidth
    dHeightAdj = moForm.Height - mdHeight
    For Each oCtl In moForm.Controls
        With oCtl
            sTag = UCase(.Tag)
            If InStr(1, sTag, "L", vbBinaryCompare) Then .left = .left + dWidthAdj * ResizeFactor(sTag, "L")
            If InStr(1, sTag, "T", vbBinaryCompare) Then .top = .top + dHeightAdj * ResizeFactor(sTag, "T")
            If InStr(1, sTag, "W", vbBinaryCompare) Then .Width = .Width + dWidthAdj * ResizeFactor(sTag, "W")
            If InStr(1, sTag, "H", vbBinaryCompare) Then .Height = .Height + dHeightAdj * ResizeFactor(sTag, "H")
        End With
    Next
    mdWidth = moForm.Width
    mdHeight = moForm.Height
End Sub

Private Function ResizeFactor(sTag As String, sChange As String)
    Dim i As Integer, d As Double
    i = InStr(1, sTag, sChange, vbBinaryCompare)
    If i > 0 Then
        d = val(Mid$(sTag, i + 1))
        If d = 0 Then d = 1
    End If
    ResizeFactor = d
End Function


'A_MAIN	1


Rem @Folder Main
Public Const AUTHOR_GITHUB = "https://github.com/AlexOfRhodes"
Public Const AUTHOR_YOUTUBE = "https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg"
Public Const AUTHOR_VK = "https://vk.com/video/playlist/735281600_1"
Public Const AUTHOR_NAME = "Anastasiou Alex"
Public Const AUTHOR_EMAIL = "AnastasiouAlex@gmail.com"
Public Const AUTHOR_COPYRIGHT = ""
Public Const AUTHOR_OTHERTEXT = ""
Public Const AUTHOR_MEDIA = "'* GITHUB     : " & AUTHOR_GITHUB & vbNewLine & _
"'* YOUTUBE    : " & AUTHOR_YOUTUBE & vbNewLine & _
"'* VK         : " & AUTHOR_VK & vbNewLine
Public Const PROJECT_URL = "https://github.com/alexofrhodes/vbArc-Addin/"
Public Const PROJECT_DOWNLAOD_URL = "https://github.com/alexofrhodes/vbArc-Addin/raw/main/vbArc-Addin.xlsm"
Public Const PROJECT_CHANGELOG_URL = "https://github.com/alexofrhodes/vbArc-Addin/raw/main/ChangeLog.md"
Public Const PROJECT_NAME = "vbArc-Addin"
Public Const PROJECT_VERSION_URL = "https://github.com/alexofrhodes/vbArc-Addin/raw/main/changelog.md"
Public ShowInVBE As Boolean
Public Const SNIP_FOLDER As String = "C:\Users\acer\My Documents\vbArc\SNIPPETS\"
Public myRibbon As IRibbonUI
#If VBA7 Then
    Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, source As Any, ByVal Length As LongPtr)
#Else
    Public Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, source As Any, ByVal Length As Long)
#End If

Function IMAGE_FOLDER() As String
    '#INCLUDE FoldersCreate
    Dim myPath As String
    myPath = ThisWorkbook.Path & "\Ribbon Images\"
    FoldersCreate myPath
    IMAGE_FOLDER = myPath
End Function

Sub vbArcRibbon_OnLoad(ribbon As IRibbonUI)
    #If VBA7 Then
        Dim StoreRibbonPointer As LongPtr
    #Else
        Dim StoreRibbonPointer As Long
    #End If
    Set myRibbon = ribbon
    StoreRibbonPointer = ObjPtr(ribbon)
    ThisWorkbook.SHEETS("vbArc_Addin_Settings").Range("B1").Value = StoreRibbonPointer
End Sub

Sub vbArcRibbon_RefreshRibbon()
    Rem PURPOSE: Refresh Ribbon UI
    '#INCLUDE GetRibbon
    Dim myRibbon As Object
    On Error GoTo RestartExcel
    If myRibbon Is Nothing Then
        Set myRibbon = GetRibbon(ThisWorkbook.SHEETS("vbArc_Addin_Settings").Range("B1").Value)
    End If
    Rem Redo Ribbon Load
    myRibbon.Invalidate
    On Error GoTo 0
    Exit Sub
RestartExcel:
    MsgBox "Ribbon UI Refresh Failed"
End Sub

Sub InvalidateControl(controlID)
    Rem PURPOSE: Refresh Ribbon UI
    '#INCLUDE GetRibbon
    On Error GoTo RestartExcel
    If myRibbon Is Nothing Then
        Set myRibbon = GetRibbon(ThisWorkbook.SHEETS("vbArc_Addin_Settings").Range("B1").Value)
    End If
    myRibbon.InvalidateControl controlID
    On Error GoTo 0
    Exit Sub
RestartExcel:
    MsgBox "Ribbon UI Refresh Failed"
End Sub

#If VBA7 Then
Function GetRibbon(ByVal lRibbonPointer As LongPtr) As Object
#Else
Function GetRibbon(ByVal lRibbonPointer As Long) As Object
#End If
Dim objRibbon As Object
CopyMemory objRibbon, lRibbonPointer, LenB(lRibbonPointer)
Set GetRibbon = objRibbon
Set objRibbon = Nothing
End Function

Sub vbArcRibbon_getSize(control As IRibbonControl, ByRef returnedVal)
    '#INCLUDE vbArcRibbon_ReturnValue
    returnedVal = vbArcRibbon_ReturnValue(control.ID, "Size")
End Sub

Sub vbArcRibbon_getLabel(control As IRibbonControl, ByRef returnedVal)
    '#INCLUDE vbArcRibbon_ReturnValue
    returnedVal = vbArcRibbon_ReturnValue(control.ID, "Label")
End Sub

Sub vbArcRibbon_getScreenTip(control As IRibbonControl, ByRef returnedVal)
    '#INCLUDE vbArcRibbon_ReturnValue
    returnedVal = vbArcRibbon_ReturnValue(control.ID, "ScreenTip")
End Sub

Sub vbArcRibbon_getSuperTip(control As IRibbonControl, ByRef returnedVal)
    '#INCLUDE vbArcRibbon_ReturnValue
    returnedVal = vbArcRibbon_ReturnValue(control.ID, "superTip")
End Sub

Sub vbArcRibbon_getVisible(control As IRibbonControl, ByRef returnedVal)
    '#INCLUDE vbArcRibbon_ReturnValue
    returnedVal = vbArcRibbon_ReturnValue(control.ID, "visible")
End Sub

Sub vbArcRibbon_getImage(control As IRibbonControl, ByRef returnedVal)
    '#INCLUDE IMAGE_FOLDER
    '#INCLUDE vbArcRibbon_ReturnValue
    '#INCLUDE FileExists
    '#INCLUDE LoadPictureGDI
    Dim image
    Dim ImageName As String
    ImageName = vbArcRibbon_ReturnValue(control.ID, "Image")
    If InStr(1, ImageName, ".") > 0 Then
        On Error GoTo ErrorHandler
        Dim strPath As String
        strPath = IMAGE_FOLDER
        If FileExists(strPath & ImageName) Then
            Set returnedVal = LoadPictureGDI(strPath & ImageName)
        Else
            returnedVal = "WordPicture"
        End If
    Else
        returnedVal = ImageName
    End If
ErrorHandler:
End Sub

Sub ShowImagePicker()
    If ActiveSheet.Name <> "vbArc_Addin_Settings" Then Exit Sub
    If ActiveSheet.Cells(2, ActiveCell.Column) = "image" Then
        uImageMso.Show
    Else
        MsgBox "Select a cell in column ""image"""
    End If
End Sub

Sub ShowLocalImagePicker()
    '#INCLUDE IMAGE_FOLDER
    '#INCLUDE FolderExists
    If ThisWorkbook.SHEETS("vbArc_Addin_Settings").Cells(2, ActiveCell.Column).TEXT Like "IMAGE" Then
        MsgBox "Select a cell in column ""IMAGE"""
        Exit Sub
    End If
    Dim initialFileName As String
    initialFileName = IMAGE_FOLDER
    Dim strFile As String
    Dim fd As Office.FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Filters.clear
        .title = "Choose an Image file"
        .AllowMultiSelect = False
        If FolderExists(initialFileName) Then
            .initialFileName = initialFileName
        End If
        If .Show = True Then
            strFile = .SelectedItems(1)
            strFile = Mid(strFile, InStrRev(strFile, "\") + 1)
            ActiveCell.Value = strFile
        End If
    End With
End Sub

Sub SetControlValue(controlID, TargetProperty, controlValue)
    Dim TargetSheet As Worksheet
    Set TargetSheet = ThisWorkbook.SHEETS("vbArc_Addin_Settings")
    Dim PropertyColumn As Long
    PropertyColumn = TargetSheet.rows(2).Find(TargetProperty).Column
    Dim ControlRow As Long
    ControlRow = TargetSheet.Columns(2).Find(controlID).row
    TargetSheet.Cells(ControlRow, PropertyColumn).Value = controlValue
End Sub

Function vbArcRibbon_ReturnValue(controlID, TargetProperty)
    Dim TargetSheet As Worksheet
    Set TargetSheet = ThisWorkbook.SHEETS("vbArc_Addin_Settings")
    Dim PropertyColumn As Long
    PropertyColumn = TargetSheet.rows(2).Find(TargetProperty).Column
    Dim ControlRow As Long
    ControlRow = TargetSheet.Columns(2).Find(controlID).row
    vbArcRibbon_ReturnValue = TargetSheet.Cells(ControlRow, PropertyColumn)
End Function

Function ControlLabel(control As IRibbonControl)
    '#INCLUDE vbArcRibbon_ReturnValue
    ControlLabel = vbArcRibbon_ReturnValue(control.ID, "label")
End Function

Sub vbArcRibbon_ButtonAction(control As IRibbonControl)
    '#INCLUDE CreateAllBars
    '#INCLUDE SaveThisAddin
    '#INCLUDE ShowUserformAuthorCard
    '#INCLUDE ShowUserformSnippetsWorkbook
    '#INCLUDE ShowUserformProjectManager
    Select Case control.ID
        Case "MainButtonAuthorCard"
            ShowUserformAuthorCard
        Case "MainButtonUpdate"
            Rem @TODO
        Case "MainButtonReload"
            CreateAllBars
        Case "MainButtonToggleIsAddin"
            ThisWorkbook.IsAddin = Not ThisWorkbook.IsAddin
        Case "MainButtonSave"
            SaveThisAddin
        Case "MainProjectManager"
            ShowUserformProjectManager
        Case "MainSnippetsWorkbook"
            ShowUserformSnippetsWorkbook
        Case "MainFinder"
            uFinder.Show
        Case "MainFormNavigator"
            uFormNavigator.Show
        Case "MainWorksheetNavigator"
            uSheetsNavigator.Show
        Case "MainRangeManager"
            uRangeControl.Show
        Case "MainImageManager"
            uImageControl.Show
        Case "MainFileManager"
            uFileManager.Show
        Case "MainSessionManager"
            uSessions.Show
        Case "MainAddinsManager"
            uAddinManager.Show
        Case "MainXray"
            uSkeleton.Show
        Case "MainNotekeeper"
            uMemoryKnots.Show
        Case "MainMouseRecorder"
            uMouseRecorder.Show
    End Select
End Sub

Sub SaveThisAddin()
    Dim WasOpen As Boolean: WasOpen = ThisWorkbook.IsAddin
    If Right(ThisWorkbook.Name, 4) = "xlam" Then ThisWorkbook.IsAddin = True
    ThisWorkbook.Save
    If WasOpen = False Then ThisWorkbook.IsAddin = False
End Sub

Sub ShowUserformAuthorCard()
    uDEV.Show
End Sub

Sub ShowUserformSnippetsWorkbook()
    ShowInVBE = False
    uSnippets.Show
End Sub

Sub ShowUserformSnippetsVBE()
    ShowInVBE = True
    Application.VBE.MainWindow.visible = True
    Application.VBE.MainWindow.SetFocus
    uSnippets.Show
End Sub

Sub ShowUserformProjectManager()
    uProjectManager.Show
End Sub

Sub ShowUserformComponentsRemove()
    '#INCLUDE ActiveCodepaneWorkbook
    Set pmWorkbook = ActiveCodepaneWorkbook
    RemoveComps.Show
End Sub

Sub ShowUserformComponentsAdd()
    '#INCLUDE ActiveCodepaneWorkbook
    Set pmWorkbook = ActiveCodepaneWorkbook
    AddComps.Show
End Sub

Sub ShowUserformComponentsRename()
    '#INCLUDE ActiveCodepaneWorkbook
    Set pmWorkbook = ActiveCodepaneWorkbook
    RenameComps.Show
End Sub

Sub ShowUserformReferences()
    uReferences.Show
End Sub

Sub ShowUserformFormBuilder()
    uFormBuilder.Show
End Sub

Sub ShowFormBuilderSheet()
    ThisWorkbook.IsAddin = False
    With ThisWorkbook.SHEETS("FormBuilder")
        .visible = xlSheetVisible
        .Activate
    End With
End Sub

Sub HideFormBuilderSheet()
    If Right(ThisWorkbook.Name, 4) = "xlam" Then ThisWorkbook.IsAddin = True
End Sub

Sub ShowUserformProjectExplorer()
    uProjectExplorer.Show
End Sub

Sub ShowUserformSkeleton()
    uSkeleton.Show
End Sub

Sub ShowUserformPickImageMSO()
    uImageMso.Show
End Sub

Sub AddReadmeToWorkbook()
    '#INCLUDE WorksheetExists
    If WorksheetExists("README", ActiveWorkbook) Then
        MsgBox "Sheet ""README"" already exists."
        Exit Sub
    Else
        ThisWorkbook.SHEETS("README").Copy ActiveWorkbook.SHEETS(1)
        ActiveWorkbook.SHEETS("README").visible = True
    End If
End Sub



'F_Arrays	1

Rem @Folder ARRAY
Function ArrayMultiFilter(SourceArray As Variant, Matches As Variant, Optional Include As Boolean, Optional CompareMode As VbCompareMethod = vbBinaryCompare) As Variant
    Dim X&, arr, sJoined$
    For X = LBound(Matches) To UBound(Matches)
        arr = VBA.Filter(SourceArray, Matches(X), Include, CompareMode)
        sJoined = sJoined & VBA.Join(arr, ",") & ","
    Next X
    sJoined = left(sJoined, Len(sJoined) - 1)
    ArrayMultiFilter = Split(sJoined, ",")
End Function

Public Function ArrayRemoveEmptyElemets(varArray As Variant) As Variant
    Dim tempArray() As Variant
    Dim oldIndex As Integer
    Dim newIndex As Integer
    ReDim tempArray(LBound(varArray) To UBound(varArray))
    For oldIndex = LBound(varArray) To UBound(varArray)
        If Not Trim(varArray(oldIndex) & " ") = "" Then
            tempArray(newIndex) = varArray(oldIndex)
            newIndex = newIndex + 1
        End If
    Next oldIndex
    ReDim Preserve tempArray(LBound(varArray) To newIndex - 1)
    ArrayRemoveEmptyElemets = tempArray
End Function

Sub ArrayToRange1d(arr As Variant, Optional rng As Range)
    '#INCLUDE GetInputRange
    If rng Is Nothing Then
        If GetInputRange(rng, "select range", "select range") = False Then Exit Sub
    End If
    Dim dif As Long, difC As Long
    dif = IIf(LBound(arr, 1) = "0", 0, 1)
    rng.RESIZE(UBound(arr, 1) + dif) = arr
    rng.TextToColumns rng, , , , , , True
End Sub

Public Function SortArray( _
       ByVal sortableArray As Variant, _
       Optional ByVal descendingFlag As Boolean) _
        As Variant
    Dim i As Integer
    Dim swapOccuredBool As Boolean
    Dim arrayLength As Integer
    arrayLength = UBound(sortableArray) - LBound(sortableArray) + 1
    Dim sortedArray() As Variant
    ReDim sortedArray(arrayLength)
    Dim dif As Long
    dif = IIf(LBound(sortableArray) = 1, 1, 0)
    For i = 0 To arrayLength - 1
        sortedArray(i) = sortableArray(i + dif)
    Next
    Dim temporaryValue As Variant
    Do
        swapOccuredBool = False
        For i = 0 To arrayLength - 1
            If (sortedArray(i)) < sortedArray(i + 1) Then
                temporaryValue = sortedArray(i)
                sortedArray(i) = sortedArray(i + 1)
                sortedArray(i + 1) = temporaryValue
                swapOccuredBool = True
            End If
        Next
    Loop While swapOccuredBool
    If descendingFlag = True Then
        SortArray = sortedArray
    Else
        Dim ascendingArray() As Variant
        ReDim ascendingArray(arrayLength)
        For i = 0 To arrayLength - 1
            ascendingArray(i) = sortedArray(arrayLength - i - 1)
        Next
        SortArray = ascendingArray
    End If
End Function

Public Function DuplicatesInArray(ArrayOfValues) As String
    On Error GoTo Err_DuplicatesInArray
    Dim intUB As Integer
    Dim intElem As Integer
    Dim intLoop As Integer
    Dim intCount As Integer
    Dim varValue
    Dim varLoop
    Dim strResults As String
    intUB = UBound(ArrayOfValues)
    strResults = ""
    For intElem = 0 To intUB
        intCount = 0
        varValue = ArrayOfValues(intElem)
        If Not IsNull(varValue) Then
            For intLoop = 0 To intUB
                varLoop = ArrayOfValues(intLoop)
                If Not IsNull(varLoop) Then
                    If varLoop = varValue Then
                        intCount = intCount + 1
                    End If
                End If
            Next intLoop
            If intCount > 1 Then
                If InStr(strResults, varValue & ", ") = 0 Then
                    strResults = strResults & varValue & ", "
                End If
            End If
        End If
    Next intElem
    If Len(strResults) > 0 Then
        DuplicatesInArray = left(strResults, Len(strResults) - 2)
    Else
        DuplicatesInArray = ""
    End If
Exit_DuplicatesInArray:
    On Error Resume Next
    Exit Function
Err_DuplicatesInArray:
    MsgBox err.Number & " " & err.Description, vbCritical, "DuplicatesInArray()"
    DuplicatesInArray = ""
    Resume Exit_DuplicatesInArray
End Function

Public Sub SampleSortByLength()
    '#INCLUDE CustomQuickSort
    Dim sample As Variant
    sample = Split("this,is,a,random,phrase", ",")
    CustomQuickSort sample, LBound(sample), UBound(sample)
    Dim i As Integer
    For i = LBound(sample) To UBound(sample)
        Debug.Print sample(i)
    Next i
End Sub

Private Function SortByLengthCompare(one As Variant, two As Variant) As Boolean
    Select Case True
        Case Len(one) < Len(two)
            SortByLengthCompare = True
        Case Len(one) > Len(two)
            SortByLengthCompare = False
        Case Len(one) = Len(two)
            SortByLengthCompare = LCase$(one) < LCase$(two)
    End Select
End Function

Public Sub CustomQuickSort(list As Variant, first As Long, last As Long)
    '#INCLUDE SortByLengthCompare
    Dim pivot As String
    Dim low As Long
    Dim high As Long
    low = first
    high = last
    pivot = list((first + last) \ 2)
    Do While low <= high
        Do While low < last And SortByLengthCompare(list(low), pivot)
            low = low + 1
        Loop
        Do While high > first And SortByLengthCompare(pivot, list(high))
            high = high - 1
        Loop
        If low <= high Then
            Dim swap As String
            swap = list(low)
            list(low) = list(high)
            list(high) = swap
            low = low + 1
            high = high - 1
        End If
    Loop
    If (first < high) Then CustomQuickSort list, first, high
    If (low < last) Then CustomQuickSort list, low, last
End Sub

Function Transpose2DArray(inputArray As Variant) As Variant
    Dim X As Long, yUbound As Long
    Dim Y As Long, xUbound As Long
    Dim tempArray As Variant
    xUbound = UBound(inputArray, 2)
    yUbound = UBound(inputArray, 1)
    ReDim tempArray(1 To xUbound, 1 To yUbound)
    For X = 1 To xUbound
        For Y = 1 To yUbound
            tempArray(X, Y) = inputArray(Y, X)
        Next Y
    Next X
    Transpose2DArray = tempArray
End Function

Public Function ArrayDimensionLength(SourceArray As Variant) As Integer
    Dim i As Integer
    Dim test As Long
    On Error GoTo catch
    Do
        i = i + 1
        test = UBound(SourceArray, i)
    Loop
catch:
    ArrayDimensionLength = i - 1
End Function

Public Function IsArrayAllocated(ByRef arr As Variant) As Boolean
    On Error Resume Next
    IsArrayAllocated = IsArray(arr) And (Not IsError(LBound(arr, 1))) And LBound(arr, 1) <= UBound(arr, 1)
End Function

Rem @AUTHOR ROBERT TODAR
Public Function ArrayToString(SourceArray As Variant, Optional Delimiter As String = ",") As String
    '#INCLUDE ArrayDimensionLength
    Dim temp As String
    Select Case ArrayDimensionLength(SourceArray)
        Case 1
            temp = Join(SourceArray, Delimiter)
        Case 2
            Dim RowIndex As Long
            Dim ColIndex As Long
            For RowIndex = LBound(SourceArray, 1) To UBound(SourceArray, 1)
                For ColIndex = LBound(SourceArray, 2) To UBound(SourceArray, 2)
                    temp = temp & SourceArray(RowIndex, ColIndex)
                    If ColIndex <> UBound(SourceArray, 2) Then temp = temp & Delimiter
                Next ColIndex
                If RowIndex <> UBound(SourceArray, 1) Then temp = temp & vbNewLine
            Next RowIndex
    End Select
    ArrayToString = temp
End Function

Public Sub ArrayToRange2D(arr2d As Variant, rng As Range)
    rng.RESIZE(UBound(arr2d, 1), UBound(arr2d, 2)) = arr2d
End Sub

Function Filter2DArray(ByVal sArray, ByVal ColIndex As Long, ByVal FindStr As String, ByVal HasTitle As Boolean)
    Dim tmpArr, i As Long, j As Long, arr, dic, TmpStr, tmp, Chk As Boolean, TmpVal As Double
    On Error Resume Next
    Set dic = CreateObject("Scripting.Dictionary")
    tmpArr = sArray
    ColIndex = ColIndex + LBound(tmpArr, 2) - 1
    Chk = (InStr("><=", left(FindStr, 1)) > 0)
    For i = LBound(tmpArr, 1) - HasTitle To UBound(tmpArr, 1)
        If Chk Then
            TmpVal = CDbl(tmpArr(i, ColIndex))
            If Evaluate(TmpVal & FindStr) Then dic.Add i, ""
        Else
            If UCase(tmpArr(i, ColIndex)) Like UCase(FindStr) Then dic.Add i, ""
        End If
    Next
    If dic.count > 0 Then
        tmp = dic.keys
        ReDim arr(LBound(tmpArr, 1) To UBound(tmp) + LBound(tmpArr, 1) - HasTitle, LBound(tmpArr, 2) To UBound(tmpArr, 2))
        For i = LBound(tmpArr, 1) - HasTitle To UBound(tmp) + LBound(tmpArr, 1) - HasTitle
            For j = LBound(tmpArr, 2) To UBound(tmpArr, 2)
                arr(i, j) = tmpArr(tmp(i - LBound(tmpArr, 1) + HasTitle), j)
            Next
        Next
        If HasTitle Then
            For j = LBound(tmpArr, 2) To UBound(tmpArr, 2)
                arr(LBound(tmpArr, 1), j) = tmpArr(LBound(tmpArr, 1), j)
            Next
        End If
    End If
    Filter2DArray = arr
End Function

Function RotateArray(inputArray, Optional ShiftByNum = 1) As Variant
    Rem @TODO - Rotate right
    Rem rotates array left
    '#INCLUDE Len2
    Dim ub As Long: ub = UBound(inputArray)
    Dim LB As Long: LB = LBound(inputArray)
    Dim dif As Long: dif = 1 - LB
    Dim NewArray() As Variant
    Dim element As Variant
    Dim counter As Long
    Dim fromStart As Long: fromStart = LB
    For counter = LB To ub
        ReDim Preserve NewArray(1 To counter + dif)
        If counter + ShiftByNum <= ub Then
            NewArray(UBound(NewArray)) = inputArray(counter + ShiftByNum)
        ElseIf UBound(NewArray) <= Len2(inputArray) Then
            NewArray(UBound(NewArray)) = inputArray(fromStart)
            fromStart = fromStart + 1
        End If
    Next
    RotateArray = NewArray
End Function

Public Function Len2( _
       ByVal val As Variant) _
        As Integer
    If IsArray(val) And Right(TypeName(val), 2) = "()" Then
        Len2 = UBound(val) - LBound(val) + 1
    ElseIf TypeName(val) = "String" Then
        Len2 = Len(val)
    ElseIf IsNumeric(val) Then
        Len2 = Len(CStr(val))
    Else
        Len2 = val.count
    End If
End Function

Public Function IsInArray( _
       ByVal value1 As Variant, _
       ByVal array1 As Variant, _
       Optional CaseSensitive As Boolean) _
        As Boolean
    Dim individualElement As Variant
    If CaseSensitive = True Then value1 = UCase(value1)
    For Each individualElement In array1
        If CaseSensitive = True Then individualElement = UCase(individualElement)
        If individualElement = value1 Then
            IsInArray = True
            Exit Function
        End If
    Next
    IsInArray = False
End Function

Function joinArrays(arr1 As Variant, arr2 As Variant) As Variant
    Dim arrToReturn() As Variant, myCollection As New Collection
    For Each X In arr1: myCollection.Add X: Next
    For Each Y In arr2: myCollection.Add Y: Next
    If myCollection.count = 0 Then
        joinArrays = Array("")
        Exit Function
    End If
    ReDim arrToReturn(1 To myCollection.count)
    For i = 1 To myCollection.count: arrToReturn(i) = myCollection.item(i): Next
    joinArrays = arrToReturn
End Function

Function appendArray(ByVal arr1 As Variant, ByVal arr2 As Variant) As Variant
    Dim holdarr As Variant
    Dim ub1 As Long
    Dim ub2 As Long
    Dim i As Long
    Dim newind As Long
    If IsEmpty(arr1) Or Not IsArray(arr1) Then
        arr1 = Array()
    End If
    If IsEmpty(arr2) Or Not IsArray(arr2) Then
        arr2 = Array()
    End If
    ub1 = UBound(arr1)
    ub2 = UBound(arr2)
    If ub1 = -1 Then
        appendArray = arr2
        Exit Function
    End If
    If ub2 = -1 Then
        appendArray = arr1
        Exit Function
    End If
    holdarr = arr1
    ReDim Preserve holdarr(ub1 + ub2 + 1)
    newind = UBound(arr1) + 1
    For i = 0 To ub2
        If VarType(arr2(i)) = vbObject Then
            Set holdarr(newind) = arr2(i)
        Else
            holdarr(newind) = arr2(i)
        End If
        newind = newind + 1
    Next i
    appendArray = holdarr
End Function

Public Function Combine2Array(ByVal arr1 As Variant, ByVal arr2 As Variant) As Variant
    '#INCLUDE NumberOfArrayDimensions
    Dim LowRowArr1 As Long
    Dim HighRowArr1 As Long
    Dim LowColumnArr1 As Long
    Dim HighColumnArr1 As Long
    Dim NumOfRowsArr1 As Long
    Dim NumOfColumnsArr1 As Long
    Dim LowRowArr2 As Long
    Dim HighRowArr2 As Long
    Dim LowColumnArr2 As Long
    Dim HighColumnArr2 As Long
    Dim NumOfRowsArr2 As Long
    Dim NumOfColumnsArr2 As Long
    Dim output As Variant
    Dim OutputRow As Long
    Dim OutputColumn As Long
    Dim RowIdx As Long
    Dim ColIdx As Long
    If (IsArray(arr1) = False) Or (IsArray(arr2) = False) Then
        Combine2Array = Null
        MsgBox "Both need to be array"
        Exit Function
    End If
    If (NumberOfArrayDimensions(arr1) <> 2) Or (NumberOfArrayDimensions(arr2) <> 2) Then
        Combine2Array = Null
        MsgBox "Both need to be 2D array"
        Exit Function
    End If
    LowRowArr1 = LBound(arr1, 1)
    HighRowArr1 = UBound(arr1, 1)
    LowColumnArr1 = LBound(arr1, 2)
    HighColumnArr1 = UBound(arr1, 2)
    NumOfRowsArr1 = HighRowArr1 - LowRowArr1 + 1
    NumOfColumnsArr1 = HighColumnArr1 - LowColumnArr1 + 1
    LowRowArr2 = LBound(arr2, 1)
    HighRowArr2 = UBound(arr2, 1)
    LowColumnArr2 = LBound(arr2, 2)
    HighColumnArr2 = UBound(arr2, 2)
    NumOfRowsArr2 = HighRowArr2 - LowRowArr2 + 1
    NumOfColumnsArr2 = HighColumnArr2 - LowColumnArr2 + 1
    If NumOfColumnsArr1 <> NumOfColumnsArr2 Then
        Combine2Array = Null
        MsgBox "Both array must have same number of column"
        Exit Function
    End If
    ReDim output(0 To NumOfRowsArr1 + NumOfRowsArr2 - 1, 0 To NumOfColumnsArr1 - 1)
    For RowIdx = LowRowArr1 To HighRowArr1
        OutputColumn = 0
        For ColIdx = LowColumnArr1 To HighColumnArr1
            output(OutputRow, OutputColumn) = arr1(RowIdx, ColIdx)
            OutputColumn = OutputColumn + 1
        Next ColIdx
        OutputRow = OutputRow + 1
    Next RowIdx
    For RowIdx = LowRowArr2 To HighRowArr2
        OutputColumn = 0
        For ColIdx = LowColumnArr2 To HighColumnArr2
            output(OutputRow, OutputColumn) = arr2(RowIdx, ColIdx)
            OutputColumn = OutputColumn + 1
        Next ColIdx
        OutputRow = OutputRow + 1
    Next RowIdx
    Combine2Array = output
End Function

Public Function NumberOfArrayDimensions(arr As Variant) As Byte
    Dim Ndx As Byte
    Dim Res As Long
    On Error Resume Next
    Do
        Ndx = Ndx + 1
        Res = UBound(arr, Ndx)
    Loop Until err.Number <> 0
    NumberOfArrayDimensions = Ndx - 1
End Function



'F_FunctionsUnsorted	1

Rem @Folder Unsorted Declarations
Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Enum myColors
    FormBackgroundDarkGray = 4208182        ' BACKGROUND DARK GRAY
    FormSidebarMediumGray = 5457992        ' TILE COLORS LIGHTER GRAY
    FormSidebarMouseOverLightGray = &H808080        ' lighter light gray
    FormSelectedGreen = 8435998        ' green tile
End Enum

Sub StartOptimizeCodeRun()
    Application.ScreenUpdating = False
    Application.DisplayStatusBar = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    ActiveSheet.DisplayPageBreaks = False
End Sub

Sub StopOptimizeCodeRun()
    Application.ScreenUpdating = True
    Application.DisplayStatusBar = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    ActiveSheet.DisplayPageBreaks = False
End Sub

Rem @Folder Unsorted
Function getLastRow(TargetSheet As Worksheet)
    '#INCLUDE LastCell
    Dim LastCell As Range
    On Error Resume Next
    Set LastCell = ActiveSheet.Cells.Find("*", SearchOrder:=xlByRows, SearchDirection:=xlPrevious)
    On Error GoTo 0
    If LastCell Is Nothing Then
        getLastRow = 1
    Else
        getLastRow = LastCell.row
    End If
End Function

Function getLastColumn(TargetSheet As Worksheet) As Long
    '#INCLUDE LastCell
    Dim LastCell As Range
    On Error Resume Next
    Set LastCell = ActiveSheet.Cells.Find("*", SearchOrder:=xlByColumns, SearchDirection:=xlPrevious)
    On Error GoTo 0
    If LastCell Is Nothing Then
        getLastColumn = 1
    Else
        getLastColumn = LastCell.Column
    End If
End Function

Function GithubImageFormat(Optional GithubImageString As String) As String
    '#INCLUDE CLIP
    If GithubImageString = "" Then GithubImageString = CLIP
    Dim v
    v = Split(GithubImageString, Chr(10))
    Dim i As Long
    Dim s As String
    Dim tmp As String
    For i = LBound(v) To UBound(v)
        If left(Trim(v(i)), 1) = "!" Then
            v(i) = Trim(v(i))
            tmp = "<img src=" & Chr(34) & Mid(v(i), InStr(v(i), "(") + 1)
            tmp = left(tmp, InStrRev(tmp, ")") - 1)
            tmp = tmp & Chr(34) & " width=" & Chr(34) & "300" & Chr(34) & " height=" & Chr(34) & Chr(34) & ">"
            s = IIf(s = "", tmp, s & vbNewLine & tmp)
        Else
            s = IIf(s = "", v(i), s & vbNewLine & v(i))
        End If
    Next
    GithubImageFormat = s
    CLIP s
End Function

Sub OpenValidationComboboxOnClick(ByVal Target As Range)
    If TypeName(Selection) <> "Range" Then Exit Sub
    Dim lngValType As Long
    On Error Resume Next
    lngValType = Target.Validation.Type
    On Error GoTo 0
    If lngValType = 3 Then SendKeys "%{DOWN}", True
End Sub

Sub BackupActiveWorkbook()
    '#INCLUDE BackupWorkbook
    BackupWorkbook ActiveWorkbook
End Sub

Sub BackupActiveCodepaneWorkbook()
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE BackupWorkbook
    BackupWorkbook ActiveCodepaneWorkbook
End Sub

Sub BackupWorkbook(TargetWorkbook As Workbook)
    '#INCLUDE GetProjectText
    '#INCLUDE FollowLink
    '#INCLUDE FoldersCreate
    '#INCLUDE TxtOverwrite
    workbookName = left(TargetWorkbook.Name, InStr(1, TargetWorkbook.Name, ".") - 1)
    Dim exportPath As String
    exportPath = Environ("USERprofile") & "\My Documents\vbArc\Backups\" & workbookName
    FoldersCreate exportPath
    TargetWorkbook.SaveCopyAs _
        fileName:=exportPath & "\" & _
                   Format(Now, "YY-MM-DD HHNNSS") & " " & _
                   TargetWorkbook.Name
    TxtOverwrite exportPath & "\" & Format(Now, "YY-MM-DD HHNNSS") & " " & workbookName & ".txt", _
                                                                   GetProjectText(TargetWorkbook)
    FollowLink exportPath
End Sub

Function LargestLength(Optional myObj) As Long
    LargestLength = 0
    Dim element As Variant
    If IsMissing(myObj) Then
        If TypeName(Selection) = "Range" Then
            Set myObj = Selection
        Else
            Exit Function
        End If
    End If
    Select Case TypeName(myObj)
        Case Is = "String"
            LargestLength = Len(myObj)
        Case "Collection"
            For Each element In myObj
                If Len(element) > LargestLength Then LargestLength = Len(element)
            Next element
        Case "Variant", "Variant()", "String()"
            For element = LBound(myObj) To UBound(myObj)
                If Len(myObj(element)) > LargestLength Then LargestLength = Len(myObj(element))
            Next
        Case Else
    End Select
End Function

Sub ListContainedProceduresInTXT(fileName As String)
    '#INCLUDE TxtOverwrite
    '#INCLUDE TxtRead
    '#INCLUDE ProceduresOfTXT
    Dim v As Variant: v = ProceduresOfTXT(fileName, True)
    If TypeName(v) = "Empty" Then Exit Sub
    Dim s As String: s = TxtRead(fileName)
    Dim line As String: line = String(30, "'")
    TxtOverwrite fileName, _
                 line & vbNewLine & _
                 "'Contains the following " & "#" & UBound(v) & " procedures " & vbNewLine & line & vbNewLine & "'" & _
                 Join(v, vbNewLine & "'") & vbNewLine & vbNewLine & s
End Sub

Function ExcludeRange(ByVal rngMain As Range, rngExc As Range) As Range
    Dim rngTemp     As Range
    Dim rng         As Range
    Set rngTemp = rngMain
    Set rngMain = Nothing
    For Each rng In rngTemp
        If Intersect(rng, rngExc) Is Nothing Then
            If rngMain Is Nothing Then
                Set rngMain = rng
            Else
                Set rngMain = Union(rngMain, rng)
            End If
        End If
    Next
    Set ExcludeRange = rngMain
End Function

Function CellRow(cell As Range) As Range
    Dim ws As Worksheet
    Set ws = cell.parent
    Dim r: r = cell.row
    Dim c As Long: c = cell.CurrentRegion.Column
    Set CellRow = ws.Range(ws.Cells(r, c), ws.Cells(r, c + cell.CurrentRegion.Columns.count - 1))
End Function

Function RangeToString(ByVal myRange As Range, Optional delim As String = ",") As String
    RangeToString = ""
    If Not myRange Is Nothing Then
        Dim myCell As Range
        For Each myCell In myRange
            RangeToString = RangeToString & delim & myCell.Value
        Next myCell
        RangeToString = Right(RangeToString, Len(RangeToString) - Len(delim))
    End If
End Function

Function ContainsIllegalCharacter(strIn As String) As Boolean
    Dim strSpecialChars As String: strSpecialChars = "~""#%@&*:<>?!{|}/\[]" & Chr(10) & Chr(13)
    Dim strOut As String: strOut = strIn
    Dim i As Long
    For i = 1 To Len(strSpecialChars)
        strOut = Replace(strOut, Mid$(strSpecialChars, i, 1), "")
        If Len(strIn) <> Len(strOut) Then ContainsIllegalCharacter = True: Exit Function
    Next
End Function

Function Translate(SourceText As String, SourceLanguage As String, TargetLanguage As String) As String
    Dim URL As String, objHTTP As Object, objHTML As Object, allDivs As Object, div As Variant
    txtTgt = "N/A"
    URL = "https://translate.google.com/m?hl=" & SourceLanguage & _
          "&sl=" & SourceLanguage & _
          "&tl=" & TargetLanguage & _
          "&ie=UTF-8&prev=_m&q=" & SourceText
    Set objHTTP = CreateObject("MSXML2.ServerXMLHTTP")
    objHTTP.Open "GET", URL, False
    objHTTP.setRequestHeader "User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"
    objHTTP.send ""
    Set objHTML = CreateObject("htmlfile")
    With objHTML
        .Open
        .Write objHTTP.responseText
        .Close
    End With
    Rem Browse through the HTML virtual file to find the proper <div>
    Rem Currently, the <div> with the translation can be identified by its class name "result-container"
    Rem It
    Set allDivs = objHTML.getElementsByTagName("div")
    For Each div In allDivs
        If div.ClassName = "result-container" Then
            Rem Found
            Translate = div.innerText
            Exit For
        End If
    Next
    Set allDivs = Nothing
    Set objHTTP = Nothing
    Set objHTML = Nothing
End Function

Function AddShape() As Shape
    Dim shp As Shape
    Set shp = ActiveSheet.Shapes.AddShape _
              (msoShapeRoundedRectangle, 1, 1, 500, 10)
    With shp.ThreeD
        .BevelTopType = msoBevelCircle
        .BevelTopInset = 6
        .BevelTopDepth = 6
    End With
    With shp.Fill
        .visible = msoTrue
        .ForeColor.RGB = RGB(0, 176, 80)
        .Transparency = 0
        .Solid
    End With
    With shp.line
        .visible = msoTrue
        .ForeColor.ObjectThemeColor = msoThemeColorBackground1
        .ForeColor.TintAndShade = 0
        .ForeColor.Brightness = 0
        .Transparency = 0
    End With
    Set AddShape = shp
End Function

Public Function CLIP(Optional StoreText As String) As String
    Dim X As Variant
    X = StoreText
    With CreateObject("htmlfile")
        With .parentWindow.clipboardData
            Select Case True
                Case Len(StoreText)
                    .SetData "text", X
                Case Else
                    CLIP = .GetData("text")
            End Select
        End With
    End With
End Function

Function OutlookCheck() As Boolean
    Dim xOLApp As Object
    Set xOLApp = CreateObject("Outlook.Application")
    If Not xOLApp Is Nothing Then
        OutlookCheck = True
        Set xOLApp = Nothing
        Exit Function
    End If
    OutlookCheck = False
End Function

Function InputboxString(Optional sTitle As String = "Select String", Optional sPrompt As String = "Select String", Optional DefaultValue = "") As String
    Dim stringVariable As String
    stringVariable = Application.InputBox( _
                     title:=sTitle, _
                     Prompt:=sPrompt, _
                     Type:=2, _
                     Default:=DefaultValue)
    InputboxString = CStr(stringVariable)
End Function

Function LastCell(rng As Range, Optional booCol As Boolean, Optional onlyAfterFirstCell As Boolean) As Range
    Dim ws As Worksheet
    Set ws = rng.parent
    Dim cell As Range
    If booCol = False Then
        Set cell = ws.Cells(rows.count, rng.Column).End(xlUp)
        If cell.MergeCells Then Set cell = Cells(cell.row + cell.rows.count - 1, cell.Column)
    Else
        Set cell = ws.Cells(rng.row, Columns.count).End(xlToLeft)
        If cell.MergeCells Then Set cell = Cells(cell.row, cell.Column + cell.Columns.count - 1)
    End If
    If onlyAfterFirstCell = True Then
        If booCol = False Then
            Do While cell.row <= rng.row
                Set cell = cell.OFFSET(1, 0)
            Loop
        Else
            Do While cell.Column <= rng.Column
                Set cell = cell.OFFSET(0, 1)
            Loop
        End If
    End If
    Set LastCell = cell
End Function

Public Sub MsgPOP(message As String, Optional CloseAfterSeconds As Long = 1)
    CreateObject("WScript.Shell").PopUp message, CloseAfterSeconds
End Sub

Public Function PadRight(ByVal str As String, ByVal Length As Long, Optional Character As String = " ", Optional removeExcess As Boolean)
    If Len(str) < Length Then
        PadRight = str & String$(Length - Len(str), Character)
    ElseIf removeExcess = True Then
        PadRight = left$(str, Length)
    Else
        PadRight = str
    End If
End Function

Function RangeFindNth(rng As Range, strText As String, occurence As Integer) As Range
    Dim c As Range
    Dim counter As Integer
    For Each c In rng
        If InStr(1, c, strText) > 0 Then counter = counter + 1
        If counter = occurence Then
            Set RangeFindNth = c
            Exit Function
        End If
    Next c
End Function

Function WorkbookIsOpen(ByVal sWbkName As String) As Boolean
    WorkbookIsOpen = False
    On Error Resume Next
    WorkbookIsOpen = Len(Workbooks(sWbkName).Name) <> 0
    On Error GoTo 0
End Function

Function WorksheetExists(shtName As String, Optional wb As Workbook) As Boolean
    Dim sht As Worksheet
    If wb Is Nothing Then
        Set wb = ThisWorkbook
    End If
    On Error Resume Next
    Set sht = wb.SHEETS(shtName)
    On Error GoTo 0
    WorksheetExists = Not sht Is Nothing
End Function

Function CreateOrSetSheet(SheetName As String, TargetWorkbook As Workbook) As Worksheet
    '#INCLUDE WorksheetExists
    Dim NewSheet As Worksheet
    If WorksheetExists(SheetName, TargetWorkbook) = True Then
        Set CreateOrSetSheet = TargetWorkbook.SHEETS(SheetName)
    Else
        Set CreateOrSetSheet = TargetWorkbook.SHEETS.Add
        CreateOrSetSheet.Name = SheetName
    End If
End Function

Sub FollowLink(FolderPath As String)
    If Right(FolderPath, 1) = "\" Then FolderPath = left(FolderPath, Len(FolderPath) - 1)
    On Error Resume Next
    Dim oShell As Object
    Dim Wnd As Object
    Set oShell = CreateObject("Shell.Application")
    For Each Wnd In oShell.Windows
        If Wnd.Name = "File Explorer" Then
            If Wnd.document.Folder.Self.Path = FolderPath Then Exit Sub
        End If
    Next Wnd
    Application.ThisWorkbook.FollowHyperlink Address:=FolderPath, NewWindow:=True
End Sub

Sub SortColumns(rng As Range)
    '#INCLUDE ArrayToRange2D
    '#INCLUDE CreateOrSetSheet
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("TEMP SORT", ThisWorkbook)
    Dim arr As Variant
    arr = rng
    ArrayToRange2D WorksheetFunction.Transpose(arr), ws.Range("A1")
    ws.UsedRange.Sort (ws.UsedRange.Cells(1, 1))
    rng.ClearContents
    rng = WorksheetFunction.Transpose(ws.UsedRange)
    Application.DisplayAlerts = False
    ws.Delete
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
End Sub



'F_Files	1

Option Compare Text
Rem @Folder Files
Rem @Subfolder Files>Convert Declarations
'#Const EarlyBind = True 'Use Early Binding, Req. Reference Library
#Const EarlyBind = False        'Use Late Binding
Enum XlFileFormat
    'Ref: https://msdn.microsoft.com/en-us/vba/excel-vba/articles/xlfileformat-enumeration-excel
    xlAddIn = 18        'Microsoft Excel 97-2003 Add-In *.xla
    xlAddIn8 = 18        'Microsoft Excel 97-2003 Add-In *.xla
    xlCSV = 6        'CSV *.csv
    xlCSVMac = 22        'Macintosh CSV *.csv
    xlCSVMSDOS = 24        'MSDOS CSV *.csv
    xlCSVWindows = 23        'Windows CSV *.csv
    xlCurrentPlatformText = -4158        'Current Platform Text *.txt
    xlDBF2 = 7        'Dbase 2 format *.dbf
    xlDBF3 = 8        'Dbase 3 format *.dbf
    xlDBF4 = 11        'Dbase 4 format *.dbf
    xlDIF = 9        'Data Interchange format *.dif
    xlExcel12 = 50        'Excel Binary Workbook *.xlsb
    xlExcel2 = 16        'Excel version 2.0 (1987) *.xls
    xlExcel2FarEast = 27        'Excel version 2.0 far east (1987) *.xls
    xlExcel3 = 29        'Excel version 3.0 (1990) *.xls
    xlExcel4 = 33        'Excel version 4.0 (1992) *.xls
    xlExcel4Workbook = 35        'Excel version 4.0. Workbook format (1992) *.xlw
    xlExcel5 = 39        'Excel version 5.0 (1994) *.xls
    xlExcel7 = 39        'Excel 95 (version 7.0) *.xls
    xlExcel8 = 56        'Excel 97-2003 Workbook *.xls
    xlExcel9795 = 43        'Excel version 95 and 97 *.xls
    xlHtml = 44        'HTML format *.htm; *.html
    xlIntlAddIn = 26        'International Add-In No file extension
    xlIntlMacro = 25        'International Macro No file extension
    xlOpenDocumentSpreadsheet = 60        'OpenDocument Spreadsheet *.ods
    xlOpenXMLAddIn = 55        'Open XML Add-In *.xlam
    xlOpenXMLStrictWorkbook = 61        '(&;H3D) Strict Open XML file *.xlsx
    xlOpenXMLTemplate = 54        'Open XML Template *.xltx
    xlOpenXMLTemplateMacroEnabled = 53        'Open XML Template Macro Enabled *.xltm
    xlOpenXMLWorkbook = 51        'Open XML Workbook *.xlsx
    xlOpenXMLWorkbookMacroEnabled = 52        'Open XML Workbook Macro Enabled *.xlsm
    xlSYLK = 2        'Symbolic Link format *.slk
    xlTemplate = 17        'Excel Template format *.xlt
    xlTemplate8 = 17        ' Template 8 *.xlt
    xlTextMac = 19        'Macintosh Text *.txt
    xlTextMSDOS = 21        'MSDOS Text *.txt
    xlTextPrinter = 36        'Printer Text *.prn
    xlTextWindows = 20        'Windows Text *.txt
    xlUnicodeText = 42        'Unicode Text No file extension; *.txt
    xlWebArchive = 45        'Web Archive *.mht; *.mhtml
    xlWJ2WD1 = 14        'Japanese 1-2-3 *.wj2
    xlWJ3 = 40        'Japanese 1-2-3 *.wj3
    xlWJ3FJ3 = 41        'Japanese 1-2-3 format *.wj3
    xlWK1 = 5        'Lotus 1-2-3 format *.wk1
    xlWK1ALL = 31        'Lotus 1-2-3 format *.wk1
    xlWK1FMT = 30        'Lotus 1-2-3 format *.wk1
    xlWK3 = 15        'Lotus 1-2-3 format *.wk3
    xlWK3FM3 = 32        'Lotus 1-2-3 format *.wk3
    xlWK4 = 38        'Lotus 1-2-3 format *.wk4
    xlWKS = 4        'Lotus 1-2-3 format *.wks
    xlWorkbookDefault = 51        'Workbook default *.xlsx
    xlWorkbookNormal = -4143        'Workbook normal *.xls
    xlWorks2FarEast = 28        'Microsoft Works 2.0 far east format *.wks
    xlWQ1 = 34        'Quattro Pro format *.wq1
    xlXMLSpreadsheet = 46        'XML Spreadsheet *.xml
    TypePDF = 47
End Enum

Enum WdSaveFormat
    'Ref: https://msdn.microsoft.com/en-us/vba/word-vba/articles/wdsaveformat-enumeration-word
    wdFormatDocument = 0        'Microsoft Office Word 97 - 2003 binary file format.
    wdFormatDOSText = 4        'Microsoft DOS text format.  *.txt
    wdFormatDOSTextLineBreaks = 5        'Microsoft DOS text with line breaks preserved.  *.txt
    wdFormatEncodedText = 7        'Encoded text format.  *.txt
    wdFormatFilteredHTML = 10        'Filtered HTML format.
    wdFormatFlatXML = 19        'Open XML file format saved as a single XML file.
    '    wdFormatFlatXML = 20                                                    'Open XML file format with macros enabled saved as a single XML file.
    wdFormatFlatXMLTemplate = 21        'Open XML template format saved as a XML single file.
    wdFormatFlatXMLTemplateMacroEnabled = 22        'Open XML template format with macros enabled saved as a single XML file.
    wdFormatOpenDocumentText = 23        'OpenDocument Text format. *.odt
    wdFormatHTML = 8        'Standard HTML format. *.html
    wdFormatRTF = 6        'Rich text format (RTF). *.rtf
    wdFormatStrictOpenXMLDocument = 24        'Strict Open XML document format.
    wdFormatTemplate = 1        'Word template format.
    wdFormatText = 2        'Microsoft Windows text format. *.txt
    wdFormatTextLineBreaks = 3        'Windows text format with line breaks preserved. *.txt
    wdFormatUnicodeText = 7        'Unicode text format. *.txt
    wdFormatWebArchive = 9        'Web archive format.
    wdFormatXML = 11        'Extensible Markup Language (XML) format. *.xml
    wdFormatDocument97 = 0        'Microsoft Word 97 document format. *.doc
    wdFormatDocumentDefault = 16        'Word default document file format. For Word, this is the DOCX format. *.docx
    wdFormatPDF = 17        'PDF format. *.pdf
    wdFormatTemplate97 = 1        'Word 97 template format.
    wdFormatXMLDocument = 12        'XML document format.
    wdFormatXMLDocumentMacroEnabled = 13        'XML document format with macros enabled.
    wdFormatXMLTemplate = 14        'XML template format.
    wdFormatXMLTemplateMacroEnabled = 15        'XML template format with macros enabled.
    wdFormatXPS = 18        'XPS format. *.xps
End Enum

Rem @Subfolder Files>Recycle Declarations
Private Declare PtrSafe Function SHFileOperation Lib "shell32.dll" Alias _
"SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long
Private Declare PtrSafe Function PathIsNetworkPath Lib "shlwapi.dll" _
Alias "PathIsNetworkPathA" ( _
ByVal pszPath As String) As Long
Private Declare PtrSafe Function GetSystemDirectory Lib "kernel32" _
Alias "GetSystemDirectoryA" ( _
ByVal lpBuffer As String, _
ByVal nSize As Long) As Long
Private Declare PtrSafe Function SHEmptyRecycleBin _
Lib "Shell32" Alias "SHEmptyRecycleBinA" _
(ByVal hWnd As Long, _
ByVal pszRootPath As String, _
ByVal dwFlags As Long) As Long
Private Declare PtrSafe Function PathIsDirectory Lib "shlwapi" (ByVal pszPath As String) As Long
Private Const FO_DELETE = &H3
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_NOCONFIRMATION = &H10
Private Const MAX_PATH As Long = 260
Private Type SHFILEOPSTRUCT
    hWnd As Long
    wFunc As Long
    pFrom As String
    pTo As String
    fFlags As Integer
    fAnyOperationsAborted As Boolean
    hNameMappings As Long
    lpszProgressTitle As String
End Type

Rem @Subfolder Files>Recycle
Public Function RecycleFile(fileName As String) As Boolean
    '#INCLUDE Recycle
    Dim SHFileOp As SHFILEOPSTRUCT
    Dim Res As Long
    If Dir(fileName, vbNormal) = vbNullString Then
        RecycleFile = True
        Exit Function
    End If
    With SHFileOp
        .wFunc = FO_DELETE
        .pFrom = fileName
        .fFlags = FOF_ALLOWUNDO
        .fFlags = FOF_ALLOWUNDO + FOF_NOCONFIRMATION
    End With
    Res = SHFileOperation(SHFileOp)
    If Res = 0 Then
        RecycleFile = True
    Else
        RecycleFile = False
    End If
End Function

Public Function Recycle(filespec As String, Optional ErrText As String) As Boolean
    Dim SHFileOp As SHFILEOPSTRUCT
    Dim Res As Long
    Dim sFileSpec As String
    ErrText = vbNullString
    sFileSpec = filespec
    If InStr(1, filespec, ":", vbBinaryCompare) = 0 Then
        ErrText = "'" & filespec & "' is not a fully qualified name on the local machine"
        Recycle = False
        Exit Function
    End If
    If Dir(filespec, vbDirectory) = vbNullString Then
        ErrText = "'" & filespec & "' does not exist"
        Recycle = False
        Exit Function
    End If
    If Right(sFileSpec, 1) = "\" Then
        sFileSpec = left(sFileSpec, Len(sFileSpec) - 1)
    End If
    With SHFileOp
        .wFunc = FO_DELETE
        .pFrom = sFileSpec
        .fFlags = FOF_ALLOWUNDO
        .fFlags = FOF_ALLOWUNDO + FOF_NOCONFIRMATION
    End With
    Res = SHFileOperation(SHFileOp)
    If Res = 0 Then
        Recycle = True
    Else
        Recycle = False
    End If
End Function

Public Function RecycleSafe(filespec As String, Optional ByRef ErrText As String) As Boolean
    Dim ThisWorkbookFullName As String
    Dim ThisWorkbookPath As String
    Dim WindowsFolder As String
    Dim SystemFolder As String
    Dim ProgramFiles As String
    Dim MyDocuments As String
    Dim Desktop As String
    Dim ApplicationPath As String
    Dim pos As Long
    Dim ShellObj As Object
    Dim sFileSpec As String
    Dim SHFileOp As SHFILEOPSTRUCT
    Dim Res As Long
    Dim FileNum As Integer
    sFileSpec = filespec
    If InStr(1, filespec, ":", vbBinaryCompare) = 0 Then
        RecycleSafe = False
        ErrText = "'" & filespec & "' is not a fully qualified name on the local machine"
        Exit Function
    End If
    If Dir(filespec, vbDirectory) = vbNullString Then
        RecycleSafe = False
        ErrText = "'" & filespec & "' does not exist"
        Exit Function
    End If
    If Right(sFileSpec, 1) = "\" Then
        sFileSpec = left(sFileSpec, Len(sFileSpec) - 1)
    End If
    ThisWorkbookFullName = ThisWorkbook.FullName
    ThisWorkbookPath = ThisWorkbook.Path
    SystemFolder = String$(MAX_PATH, vbNullChar)
    GetSystemDirectory SystemFolder, Len(SystemFolder)
    SystemFolder = left(SystemFolder, InStr(1, SystemFolder, vbNullChar, vbBinaryCompare) - 1)
    pos = InStrRev(SystemFolder, "\")
    If pos > 0 Then
        WindowsFolder = left(SystemFolder, pos - 1)
    End If
    pos = InStr(1, Application.Path, "\", vbBinaryCompare)
    pos = InStr(pos + 1, Application.Path, "\", vbBinaryCompare)
    ProgramFiles = left(Application.Path, pos - 1)
    ApplicationPath = Application.Path
    On Error Resume Next
    err.clear
    Set ShellObj = CreateObject("WScript.Shell")
    If ShellObj Is Nothing Then
        RecycleSafe = False
        ErrText = "Error Creating WScript.Shell. " & CStr(err.Number) & ": " & err.Description
        Exit Function
    End If
    MyDocuments = ShellObj.SpecialFolders("MyDocuments")
    Desktop = ShellObj.SpecialFolders("Desktop")
    Set ShellObj = Nothing
    If (sFileSpec Like "?*:") Or (sFileSpec Like "?*:\") Then
        RecycleSafe = False
        ErrText = "File Specification is a root directory."
        Exit Function
    End If
    If (InStr(1, sFileSpec, "*", vbBinaryCompare) > 0) Or (InStr(1, sFileSpec, "?", vbBinaryCompare) > 0) Then
        RecycleSafe = False
        ErrText = "File specification contains wildcard characters"
        Exit Function
    End If
    If StrComp(sFileSpec, ThisWorkbookFullName, vbTextCompare) = 0 Then
        RecycleSafe = False
        ErrText = "File specification is the same as this workbook."
        Exit Function
    End If
    If StrComp(sFileSpec, ThisWorkbookPath, vbTextCompare) = 0 Then
        RecycleSafe = False
        ErrText = "File specification is this workbook's path"
        Exit Function
    End If
    If StrComp(ThisWorkbook.FullName, sFileSpec, vbTextCompare) = 0 Then
        RecycleSafe = False
        ErrText = "File specification is this workbook."
        Exit Function
    End If
    If StrComp(sFileSpec, SystemFolder, vbTextCompare) = 0 Then
        RecycleSafe = False
        ErrText = "File specification is the System Folder"
        Exit Function
    End If
    If StrComp(sFileSpec, WindowsFolder, vbTextCompare) = 0 Then
        RecycleSafe = False
        ErrText = "File specification is the Windows folder"
        Exit Function
    End If
    If StrComp(sFileSpec, Application.Path, vbTextCompare) = 0 Then
        RecycleSafe = False
        ErrText = "File specification is Application Path"
        Exit Function
    End If
    If StrComp(sFileSpec, MyDocuments, vbTextCompare) = 0 Then
        RecycleSafe = False
        ErrText = "File specification is MyDocuments"
        Exit Function
    End If
    If StrComp(sFileSpec, Desktop, vbTextCompare) = 0 Then
        RecycleSafe = False
        ErrText = "File specification is Desktop"
        Exit Function
    End If
    If (GetAttr(sFileSpec) And vbSystem) <> 0 Then
        RecycleSafe = False
        ErrText = "File specification is a System entity"
        Exit Function
    End If
    If PathIsDirectory(sFileSpec) = 0 Then
        FileNum = FreeFile()
        On Error Resume Next
        err.clear
        Open sFileSpec For Input Lock Read As #FileNum
        If err.Number <> 0 Then
            Close #FileNum
            RecycleSafe = False
            ErrText = "File in use: " & CStr(err.Number) & "  " & err.Description
            Exit Function
        End If
        Close #FileNum
    End If
    With SHFileOp
        .wFunc = FO_DELETE
        .pFrom = sFileSpec
        .fFlags = FOF_ALLOWUNDO
        .fFlags = FOF_ALLOWUNDO + FOF_NOCONFIRMATION
    End With
    Res = SHFileOperation(SHFileOp)
    If Res = 0 Then
        RecycleSafe = True
    Else
        RecycleSafe = False
    End If
End Function

Public Function EmptyRecycleBin(Optional DriveRoot As String = vbNullString) As Boolean
    '#INCLUDE Recycle
    Const SHERB_NOCONFIRMATION = &H1
    Const SHERB_NOPROGRESSUI = &H2
    Const SHERB_NOSOUND = &H4
    Dim Res As Long
    If DriveRoot <> vbNullString Then
        If PathIsNetworkPath(DriveRoot) <> 0 Then
            MsgBox "You can't empty the Recycle Bin of a network drive."
            Exit Function
        End If
    End If
    Res = SHEmptyRecycleBin(hWnd:=0&, _
                            pszRootPath:=DriveRoot, _
                            dwFlags:=SHERB_NOCONFIRMATION + _
                                      SHERB_NOPROGRESSUI + _
                                      SHERB_NOSOUND)
    If Res = 0 Then
        EmptyRecycleBin = True
    Else
        EmptyRecycleBin = False
    End If
End Function

Rem End of Recycle
Rem @Subfolder Files>ConvertWord
'---------------------------------------------------------------------------------------
' Procedure : Word_ConvertFileFormat
' Author    : Daniel Pineault, CARDA Consultants Inc.
' Website   : http://www.cardaconsultants.com
' Purpose   : Converts a Word compatible file format to another format
' Copyright : The following is release as Attribution-ShareAlike 4.0 International
'             (CC BY-SA 4.0) - https://creativecommons.org/licenses/by-sa/4.0/
' Req'd Refs: Uses Late Binding, so none required
'
' Input Variables:
' ~~~~~~~~~~~~~~~~
' sOrigFile     : String - Original file path, name and extension to be converted
' lNewFileFormat: New File format to save the original file as
' bDelOrigFile  : True/False - Should the original file be deleted after the conversion
'
' Usage:
' ~~~~~~
' Convert a doc file into a docx file but retain the original copy
'   Call Word_ConvertFileFormat("C:\Users\Daniel\Documents\Resume.doc", wdFormatPDF)
' Convert a doc file into a docx file and delete the original doc once converted
'   Call Word_ConvertFileFormat("C:\Users\Daniel\Documents\Resume.doc", wdFormatPDF, True)
'
' Revision History:
' Rev       Date(yyyy/mm/dd)        Description
' **************************************************************************************
' 1         2018-02-27              Initial Release
'---------------------------------------------------------------------------------------
Function Word_ConvertFileFormat(ByVal sOrigFile As String, _
                                Optional lNewFileFormat As WdSaveFormat = wdFormatDocumentDefault, _
                                Optional bDelOrigFile As Boolean = False) As Boolean
    '#INCLUDE Recycle
    '#INCLUDE XLS_ConvertFileFormat
    #If EarlyBind = True Then
        Dim oWord             As Word.Application
        Dim oDoc              As Word.document
    #Else
        Dim oWord             As Object
        Dim oDoc              As Object
    #End If
    Dim bWordOpened           As Boolean
    Dim sOrigFileExt          As String
    Dim sNewFileExt           As String
    Select Case lNewFileFormat
        Case wdFormatDocument
            sNewFileExt = "."
        Case wdFormatDOSText, wdFormatDOSTextLineBreaks, wdFormatEncodedText, wdFormatOpenDocumentText, wdFormatText, wdFormatTextLineBreaks, wdFormatUnicodeText
            sNewFileExt = ".txt"
        Case wdFormatFilteredHTML, wdFormatHTML
            sNewFileExt = ".html"
        Case wdFormatFlatXML, wdFormatXML, wdFormatXMLDocument
            sNewFileExt = ".xml"
        Case wdFormatFlatXMLTemplate
            sNewFileExt = "."
        Case wdFormatFlatXMLTemplateMacroEnabled
            sNewFileExt = "."
        Case wdFormatRTF
            sNewFileExt = ".rtf"
        Case wdFormatStrictOpenXMLDocument
            sNewFileExt = "."
        Case wdFormatTemplate
            sNewFileExt = "."
        Case wdFormatWebArchive
            sNewFileExt = "."
        Case wdFormatDocument97
            sNewFileExt = ".doc"
        Case wdFormatDocumentDefault
            sNewFileExt = ".docx"
        Case wdFormatPDF
            sNewFileExt = ".pdf"
        Case wdFormatTemplate97
            sNewFileExt = "."
        Case wdFormatXMLDocumentMacroEnabled
            sNewFileExt = ".docm"
        Case wdFormatXMLTemplate
            sNewFileExt = ".doct"
        Case wdFormatXMLTemplateMacroEnabled
            sNewFileExt = "."
        Case wdFormatXPS
            sNewFileExt = ".xps"
    End Select
    sOrigFileExt = "." & Right(sOrigFile, Len(sOrigFile) - InStrRev(sOrigFile, "."))
    On Error Resume Next
    Set oWord = GetObject(, "Word.Application")
    If err.Number <> 0 Then
        err.clear
        On Error GoTo Error_Handler
        Set oWord = CreateObject("Word.Application")
    Else
        bWordOpened = True
    End If
    On Error GoTo Error_Handler
    oWord.visible = False
    Set oDoc = oWord.Documents.Open(sOrigFile)
    oDoc.SaveAs2 Replace(sOrigFile, sOrigFileExt, sNewFileExt), lNewFileFormat
    Word_ConvertFileFormat = True
    oDoc.Close False
    If bWordOpened = False Then
        oWord.Quit
    Else
        oWord.visible = True
    End If
    If bDelOrigFile = True Then Recycle (sOrigFile)
Error_Handler_Exit:
    On Error Resume Next
    Set oDoc = Nothing
    Set oWord = Nothing
    Exit Function
Error_Handler:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: XLS_ConvertFileFormat" & vbCrLf & _
           "Error Description: " & err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    oWord.visible = True
    Resume Error_Handler_Exit
End Function

Rem @Subfolder Files>ConvertExcel
'---------------------------------------------------------------------------------------
' Procedure : XLS_ConvertFileFormat
' Author    : Daniel Pineault, CARDA Consultants Inc.
' Website   : http://www.cardaconsultants.com
' Purpose   : Converts an Excel compatible file format to another format
' Copyright : The following is release as Attribution-ShareAlike 4.0 International
'             (CC BY-SA 4.0) - https://creativecommons.org/licenses/by-sa/4.0/
' Req'd Refs: Uses Late Binding, so none required
'
' Input Variables:
' ~~~~~~~~~~~~~~~~
' sOrigFile     : String - Original file path, name and extension to be converted
' lNewFileFormat: New File format to save the original file as
' bDelOrigFile  : True/False - Should the original file be deleted after the conversion
'
' Usage:
' ~~~~~~
' Convert an xls file into a txt file and delete the xls once completed
'   Call XLS_ConvertFileFormat("C:TempTest.xls", xlTextWindows)
' Convert an xls file into a xlsx file and NOT delete the xls once completed
'   Call XLS_ConvertFileFormat("C:TempTest.xls",, False)
' Convert a csv file into a xlsx file and delete the xls once completed
'   Call XLS_ConvertFileFormat("C:TempTest.csv", xlWorkbookDefault, True)
'
' Revision History:
' Rev       Date(yyyy/mm/dd)        Description
' **************************************************************************************
' 1         2018-02-27              Initial Release
' 2         2020-12-31              Fixed typo xlDBF24 -> xlDBF4
'---------------------------------------------------------------------------------------
Function XLS_ConvertFileFormat(ByVal sOrigFile As String, _
                               Optional lNewFileFormat As XlFileFormat = xlOpenXMLWorkbook, _
                               Optional bDelOrigFile As Boolean = False) As Boolean
    '#INCLUDE Recycle
    #If EarlyBind = True Then
        Dim oExcel            As Excel.Application
        Dim oExcelWrkBk       As Excel.Workbook
    #Else
        Dim oExcel            As Object
        Dim oExcelWrkBk       As Object
    #End If
    Dim bExcelOpened          As Boolean
    Dim sOrigFileExt          As String
    Dim sNewXLSFileExt        As String
    Select Case lNewFileFormat
        Case xlAddIn, xlAddIn8
            sNewFileExt = ".xla"
        Case xlCSV, xlCSVMac, xlCSVMSDOS, xlCSVWindows
            sNewFileExt = ".csv"
        Case xlCurrentPlatformText, xlTextMac, xlTextMSDOS, xlTextWindows, xlUnicodeText
            sNewFileExt = ".txt"
        Case xlDBF2, xlDBF3, xlDBF4
            sNewFileExt = ".dbf"
        Case xlDIF
            sNewFileExt = ".dif"
        Case xlExcel12 = 50
            sNewFileExt = ".xlsb"
        Case xlExcel2, xlExcel2FarEast, xlExcel3, xlExcel4, xlExcel5, xlExcel7, _
             xlExcel8, xlExcel9795, xlWorkbookNormal
            sNewFileExt = ".xls"
        Case xlExcel4Workbook = 35
            sNewFileExt = ".xlw"
        Case xlHtml = 44
            sNewFileExt = ".html"
        Case xlIntlAddIn, xlIntlMacro
            sNewFileExt = ""
        Case xlOpenDocumentSpreadsheet
            sNewFileExt = ".ods"
        Case xlOpenXMLAddIn
            sNewFileExt = ".xlam"
        Case xlOpenXMLStrictWorkbook, xlOpenXMLWorkbook, xlWorkbookDefault = 51
            sNewFileExt = ".xlsx"
        Case xlOpenXMLTemplate
            sNewFileExt = ".xltx"
        Case xlOpenXMLTemplateMacroEnabled
            sNewFileExt = ".xltm"
        Case xlOpenXMLWorkbookMacroEnabled
            sNewFileExt = ".xlsm"
        Case xlSYLK
            sNewFileExt = ".slk"
        Case xlTemplate, xlTemplate8
            sNewFileExt = ".xlt"
        Case xlTextPrinter
            sNewFileExt = ".prn"
        Case xlWebArchive
            sNewFileExt = ".mhtml"
        Case xlWJ2WD1
            sNewFileExt = ".wj2"
        Case xlWJ3, xlWJ3FJ3
            sNewFileExt = ".wj3"
        Case xlWK1, xlWK1ALL, xlWK1FMT
            sNewFileExt = ".wk1"
        Case xlWK3, xlWK3FM3
            sNewFileExt = ".wk3"
        Case xlWK4
            sNewFileExt = ".wk4"
        Case xlWKS, xlWorks2FarEast
            sNewFileExt = ".wks"
        Case xlWQ1
            sNewFileExt = ".wq1"
        Case xlXMLSpreadsheet
            sNewFileExt = ".xml"
        Case TypePDF
            sNewFileExt = ".pdf"
    End Select
    sOrigFileExt = "." & Right(sOrigFile, Len(sOrigFile) - InStrRev(sOrigFile, "."))
    On Error Resume Next
    Set oExcel = GetObject(, "Excel.Application")
    If err.Number <> 0 Then
        err.clear
        On Error GoTo Error_Handler
        Set oExcel = CreateObject("Excel.Application")
    Else
        bExcelOpened = True
    End If
    On Error GoTo Error_Handler
    oExcel.ScreenUpdating = False
    oExcel.visible = False
    Set oExcelWrkBk = oExcel.Workbooks.Open(sOrigFile)
    oExcelWrkBk.SaveAs Replace(sOrigFile, sOrigFileExt, sNewFileExt), lNewFileFormat, , , , False
    XLS_ConvertFileFormat = True
    oExcelWrkBk.Close False
    If bExcelOpened = False Then
        oExcel.Quit
    Else
        oExcel.ScreenUpdating = True
        oExcel.visible = True
    End If
    If bDelOrigFile = True Then Recycle (sOrigFile)
Error_Handler_Exit:
    On Error Resume Next
    Set oExcelWrkBk = Nothing
    Set oExcel = Nothing
    Exit Function
Error_Handler:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: XLS_ConvertFileFormat" & vbCrLf & _
           "Error Description: " & err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    oExcel.ScreenUpdating = True
    oExcel.visible = True
    Resume Error_Handler_Exit
End Function

Sub ExcelToPDF(FileFullPath As String, SeparateSheets As Boolean, CloseFile As Boolean)
    Dim wb As Workbook
    Set wb = Workbooks.Open(FileFullPath)
    Dim ws As Worksheet
    If SeparateSheets = False Then
        wb.ExportAsFixedFormat xlTypePDF, _
                               VBA.Replace(FileFullPath, Right(FileFullPath, Len(FileFullPath) - InStrRev(FileFullPath, ".") + 1), ".pdf")
        If CloseFile = True Then wb.Close False
    Else
        For Each ws In wb
            ws.ExportAsFixedFormat xlTypePDF, wb.Path & "\" & ws.Name & ".pdf"
        Next ws
    End If
    MsgBox "Process Completed"
End Sub

Rem @Subfolder Files>Unsorted
Function IsFileFolderURL(Path) As String
    '#INCLUDE HttpExists
    '#INCLUDE FileExists
    '#INCLUDE FolderExists
    Dim retval As String
    retval = "I"
    If (retval = "I") And FileExists(Path) Then retval = "F"
    If (retval = "I") And FolderExists(Path) Then retval = "D"
    If (retval = "I") And HttpExists(Path) Then retval = "U"
    ' I => Invalid | F => File | D => Directory | U => Valid Url
    IsFileFolderURL = retval
End Function

Rem Folders
Public Function SelectFolder(Optional initFolder As String) As String
    '#INCLUDE FolderExists
    With Application.FileDialog(msoFileDialogFolderPicker)
        .AllowMultiSelect = False
        .title = "Select a folder"
        If FolderExists(initFolder) Then .initialFileName = initFolder
        .Show
        If .SelectedItems.count > 0 Then
            SelectFolder = .SelectedItems.item(1)
        Else
        End If
    End With
End Function

Sub FoldersCreate(FolderPath As String)
    '#INCLUDE FolderExists
    On Error Resume Next
    Dim individualFolders() As String
    Dim tempFolderPath As String
    Dim arrayElement As Variant
    individualFolders = Split(FolderPath, "\")
    For Each arrayElement In individualFolders
        tempFolderPath = tempFolderPath & arrayElement & "\"
        If FolderExists(tempFolderPath) = False Then
            MkDir tempFolderPath
        End If
    Next arrayElement
End Sub

Rem Files
Function GetFilePartPath(fileNameWithExtension, Optional IncludeSlash As Boolean) As String
    GetFilePartPath = left(fileNameWithExtension, InStrRev(fileNameWithExtension, "\") - 1 - IncludeSlash)
End Function

Public Function FFileDialog(Optional ByRef lDialogType As MsoFileDialogType = msoFileDialogFilePicker, _
                            Optional sTitle As String = "", _
                            Optional sInitFileName = "", _
                            Optional bMultiSelect As Boolean = False, _
                            Optional sFilter As String = "All Files,*.*") As String
    Dim out As String
    On Error GoTo Error_Handler
    Dim oFd                   As Object
    Dim vItems                As Variant
    Dim vFilter               As Variant
    Const msoFileDialogViewDetails = 2
    Set oFd = Application.FileDialog(lDialogType)
    With oFd
        If sTitle = "" Then
            Select Case lDialogType
                Case msoFileDialogFilePicker
                    .title = "Browse for File"
                Case msoFileDialogFolderPicker
                    .title = "Browse for Folder"
            End Select
        Else
            .title = sTitle
        End If
        If sInitFileName <> "" Then .initialFileName = sInitFileName
        .AllowMultiSelect = bMultiSelect
        .InitialView = msoFileDialogViewDetails
        If lDialogType <> msoFileDialogFolderPicker Then
            Call .Filters.clear
            For Each vFilter In Split(sFilter, "~")
                Call .Filters.Add(Split(vFilter, ",")(0), Split(vFilter, ",")(1))
            Next vFilter
        End If
        If .Show = True Then
            For Each vItems In .SelectedItems
                If out = "" Then
                    out = vItems
                Else
                    out = out & "," & vItems
                End If
            Next
        End If
    End With
    FFileDialog = out
Error_Handler_Exit:
    On Error Resume Next
    If Not oFd Is Nothing Then Set oFd = Nothing
    Exit Function
Error_Handler:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: fFileDialog" & vbCrLf & _
           "Error Description: " & err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Function

Function splitLineBreaks(ByVal str As String) As String
    str = Replace(str, vbCrLf, vbCr)
    str = Replace(str, vbLf, vbCr)
    splitLineBreaks = Split(str, vbCr)
End Function

Public Sub LoopAllFilesAndFolders(FolderPath As String)
    '#INCLUDE getFolder
    If Right(FolderPath, 1) <> "\" Then FolderPath = FolderPath & "\"
    Dim objFSO As Scripting.FileSystemObject
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Dim objFile As Scripting.file
    Dim objFolder As Scripting.Folder
    Set objTopFolder = objFSO.getFolder(FolderPath)
    For Each objFile In objFolder.Files
        Rem code here
    Next
    Dim objSubFolder As Scripting.Folder
    For Each objSubFolder In objFolder.SubFolders
        LoopAllFilesAndFolders objSubFolder.Path
    Next
End Sub

Function isFDU(Path) As String
    '#INCLUDE HttpExists
    '#INCLUDE FileExists
    '#INCLUDE FolderExists
    Dim retval
    retval = "I"
    If (retval = "I") And FileExists(Path) Then retval = "F"
    If (retval = "I") And FolderExists(Path) Then retval = "D"
    If (retval = "I") And HttpExists(Path) Then retval = "U"
    ' I => Invalid | F => File | D => Directory | U => Valid Url
    isFDU = retval
End Function

Public Function FileExists(ByVal fileName As String) As Boolean
    If InStr(1, fileName, "\") = 0 Then Exit Function
    If Right(fileName, 1) = "\" Then fileName = left(fileName, Len(fileName) - 1)
    FileExists = (Dir(fileName, vbArchive + vbHidden + vbReadOnly + vbSystem) <> "")
End Function

'Function FileExists(ByVal strFile As String, Optional bFindFolders As Boolean) As Boolean
'    'Purpose:   Return True if the file exists, even if it is hidden.
'    'Arguments: strFile: File name to look for. Current directory searched if no path included.
'    '           bFindFolders. If strFile is a folder, FileExists() returns False unless this argument is True.
'    'Note:      Does not look inside subdirectories for the file.
'    'Author:    Allen Browne. http://allenbrowne.com June, 2006.
'    Dim lngAttributes As Long
'
'    'Include read-only files, hidden files, system files.
'    lngAttributes = (vbReadOnly Or vbHidden Or vbSystem)
'    If bFindFolders Then
'        lngAttributes = (lngAttributes Or vbDirectory) 'Include folders as well.
'    Else
'        'Strip any trailing slash, so Dir does not look inside the folder.
'        Do While Right$(strFile, 1) = "\"
'            strFile = left$(strFile, Len(strFile) - 1)
'        Loop
'    End If
'    'If Dir() returns something, the file exists.
'    On Error Resume Next
'    FileExists = (Len(Dir(strFile, lngAttributes)) > 0)
'End Function
Function TrailingSlash(varIn As Variant) As String
    '#INCLUDE FileExists
    If Len(varIn) > 0 Then
        If Right(varIn, 1) = "\" Then
            TrailingSlash = varIn
        Else
            TrailingSlash = varIn & "\"
        End If
    End If
End Function

Function GetInputRange(rInput As Excel.Range, _
                       sPrompt As String, _
                       sTitle As String, _
                       Optional ByVal sDefault As String, _
                       Optional ByVal bActivate As Boolean, _
                       Optional X, _
                       Optional Y) As Boolean
    Dim bGotRng As Boolean
    Dim bEvents As Boolean
    Dim nAttempt As Long
    Dim sAddr As String
    Dim vReturn
    On Error Resume Next
    If Len(sDefault) = 0 Then
        If TypeName(Application.Selection) = "Range" Then
            sDefault = "=" & Application.Selection.Address
            If Len(sDefault) > 240 Then
                sDefault = "=" & Application.ActiveCell.Address
            End If
        ElseIf TypeName(Application.ActiveSheet) = "Chart" Then
            sDefault = " first select a Worksheet"
        Else
            sDefault = " Select Cell(s) or type address"
        End If
    End If
    Set rInput = Nothing
    For nAttempt = 1 To 3
        vReturn = False
        vReturn = Application.InputBox(sPrompt, sTitle, sDefault, X, Y, Type:=0)
        If False = vReturn Or Len(vReturn) = 0 Then
            Exit For
        Else
            sAddr = vReturn
            If left$(sAddr, 1) = "=" Then sAddr = Mid$(sAddr, 2, 256)
            If left$(sAddr, 1) = Chr(34) Then sAddr = Mid$(sAddr, 2, 255)
            If Right$(sAddr, 1) = Chr(34) Then sAddr = left$(sAddr, Len(sAddr) - 1)
            Set rInput = Application.Range(sAddr)
            If rInput Is Nothing Then
                sAddr = Application.ConvertFormula(sAddr, xlR1C1, xlA1)
                Set rInput = Application.Range(sAddr)
                bGotRng = Not rInput Is Nothing
            Else
                bGotRng = True
            End If
        End If
        If bGotRng Then
            If bActivate Then
                On Error GoTo errH
                bEvents = Application.EnableEvents
                Application.EnableEvents = False
                If Not Application.ActiveWorkbook Is rInput.parent.parent Then
                    rInput.parent.parent.Activate
                End If
                If Not Application.ActiveSheet Is rInput.parent Then
                    rInput.parent.Activate
                End If
                rInput.Select
            End If
            Exit For
        ElseIf nAttempt < 3 Then
            If MsgBox("Invalid reference, do you want to try again ?", _
                      vbOKCancel, sTitle) <> vbOK Then
                Exit For
            End If
        End If
    Next
cleanup:
    On Error Resume Next
    If bEvents Then
        Application.EnableEvents = True
    End If
    GetInputRange = bGotRng
    Exit Function
errH:
    Set rInput = Nothing
    bGotRng = False
    Resume cleanup
End Function

Function FolderExists(ByVal strPath As String) As Boolean
    On Error Resume Next
    FolderExists = ((GetAttr(strPath) And vbDirectory) = vbDirectory)
End Function

Sub ExtractCodeFromFiles()
    '#INCLUDE OleVbaRun
    '#INCLUDE GetFilePath
    Dim v
    v = GetFilePath(Array("xl*"), True)
    Dim el
    Dim coll As New Collection
    For Each el In v
        coll.Add el
    Next
    OleVbaRun coll
End Sub

Sub OleVbaRun(FilePathCollection As Collection)
    '#INCLUDE FollowLink
    '#INCLUDE FoldersCreate
    '#INCLUDE oleVBA
    '#INCLUDE getFilePartName
    '#INCLUDE TxtOverwrite
    Dim MainPath As String
    MainPath = Environ$("USERPROFILE") & "\Documents\vbArc\oleVba\"
    FoldersCreate MainPath
    Dim OutPath As String
    Dim fileName As String
    Dim element As Variant
    Dim output As String
    For Each element In FilePathCollection
        fileName = getFilePartName(CStr(element))
        output = oleVBA(element)
        OutPath = MainPath & "\" & fileName & ".txt"
        TxtOverwrite OutPath, output
    Next
    If FilePathCollection.count > 0 Then FollowLink MainPath
End Sub

Function oleVBA(Path As Variant) As String
    '#INCLUDE ShellText
    Dim Q As String
    Q = """"
    oleVBA = ShellText("cmd.exe /c olevba " & Q & Path & Q)
End Function

Function ShellText(sCmd As String) As String
    Dim oShell   As New WshShell        'requires ref to Windows Script Host Object Model
    ShellText = oShell.Exec(sCmd).StdOut.ReadAll
End Function

Function getFilePartName(fileNameWithExtension As String, Optional IncludeExtension As Boolean) As String
    If InStr(1, fileNameWithExtension, "\") > 0 Then
        getFilePartName = Right(fileNameWithExtension, Len(fileNameWithExtension) - InStrRev(fileNameWithExtension, "\"))
    ElseIf InStr(1, fileNameWithExtension, "/") > 0 Then
        getFilePartName = Right(fileNameWithExtension, Len(fileNameWithExtension) - InStrRev(fileNameWithExtension, "/"))
    Else
        getFilePartName = fileNameWithExtension
    End If
    If IncludeExtension = False Then getFilePartName = left(getFilePartName, InStr(1, getFilePartName, ".") - 1)
End Function

Function PickExcelFile()
    Dim strFile As String
    Dim fd As Office.FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Filters.clear
        .Filters.Add "Excel Files", "*.xl*", 1
        .title = "Choose an Excel file"
        .AllowMultiSelect = False
        .initialFileName = Environ("USERprofile") & "\Desktop\"
        If .Show = True Then
            strFile = .SelectedItems(1)
            PickExcelFile = strFile
        End If
    End With
End Function

Function LoopThroughFiles(Folder, criteria) As Collection
    If Right(Folder, 1) <> "\" Then Folder = Folder & "\"
    Dim out As Collection: Set out = New Collection
    Dim strFile As String
    strFile = Dir(Folder & criteria)
    Do While Len(strFile) > 0
        out.Add strFile
        strFile = Dir
    Loop
    Set LoopThroughFiles = out
End Function

Function FileCreated(FilePath) As Date
    Dim fs, f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(FilePath)
    FileCreated = f.datecreated
End Function

Function FileLastAccessed(FilePath) As Date
    Dim fs, f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(FilePath)
    FileLastAccessed = f.DateLastAccessed
End Function

Function FileLastModified(FilePath) As Date
    Dim fs, f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(FilePath)
    FileLastModified = f.DateLastModified
End Function

Public Function GetFilePath(Optional fileType As Variant, Optional multiSelect As Boolean) As Variant
    Dim blArray As Boolean
    Dim i As Long
    Dim strErrMsg As String, strTitle As String
    Dim varItem As Variant
    If Not IsMissing(fileType) Then
        blArray = IsArray(fileType)
        If Not blArray Then strErrMsg = "Please pass an array in the first parameter of this function!"
    End If
    If strErrMsg = vbNullString Then
        If multiSelect Then strTitle = "Choose one or more files" Else strTitle = "Choose file"
        With Application.FileDialog(msoFileDialogFilePicker)
            .initialFileName = Environ("USERprofile") & "\Desktop\"
            .AllowMultiSelect = multiSelect
            .Filters.clear
            If blArray Then .Filters.Add "File type", Replace("*." & Join(fileType, ", *."), "..", ".")
            .title = strTitle
            If .Show <> 0 Then
                ReDim arrResults(1 To .SelectedItems.count) As Variant
                If blArray Then
                    For Each varItem In .SelectedItems
                        i = i + 1
                        arrResults(i) = varItem
                    Next varItem
                Else
                    arrResults(1) = .SelectedItems(1)
                End If
                GetFilePath = arrResults
            End If
        End With
    Else
        MsgBox strErrMsg, vbCritical, "Error!"
    End If
End Function

Rem @Subfolder Files>TXTFiles
Sub TxtOverwrite(sFile As String, sText As String)
    On Error GoTo ERR_HANDLER
    Dim FileNumber As Integer
    FileNumber = FreeFile
    Open sFile For Output As #FileNumber
    Print #FileNumber, sText
    Close #FileNumber
Exit_Err_Handler:
    Exit Sub
ERR_HANDLER:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: TxtOverwrite" & vbCrLf & _
           "Error Description: " & err.Description, vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Sub

Function TXTtoArray(sFile$)
    Rem https://newbedev.com/vb-vba-import-csv-to-array-code-example
    Rem VBA function to open a CSV file in memory and parse it to a 2D array without ever touching a worksheet:
    '#INCLUDE OpenTextFile
    Dim c&, i&, j&, p&, d$, s$, rows&, cols&, a, r, v
    Const Q = """", QQ = Q & Q
    Const ENQ = ""
    Const ESC = ""
    Const COM = ","
    d = OpenTextFile$(sFile)
    If LenB(d) Then
        r = Split(Trim(d), vbCrLf)
        rows = UBound(r) + 1
        cols = UBound(Split(r(0), ",")) + 1
        ReDim v(1 To rows, 1 To cols)
        For i = 1 To rows
            s = r(i - 1)
            If LenB(s) Then
                If InStrB(s, QQ) Then s = Replace(s, QQ, ENQ)
                For p = 1 To Len(s)
                    Select Case Mid(s, p, 1)
                        Case Q:   c = c + 1
                        Case COM: If c Mod 2 Then Mid(s, p, 1) = ESC
                    End Select
                Next
                If InStrB(s, Q) Then s = Replace(s, Q, "")
                a = Split(s, COM)
                For j = 1 To cols
                    s = a(j - 1)
                    If InStrB(s, ESC) Then s = Replace(s, ESC, COM)
                    If InStrB(s, ENQ) Then s = Replace(s, ENQ, Q)
                    v(i, j) = s
                Next
            End If
        Next
        TXTtoArray = v
    End If
End Function

Rem insert string to txt file (not append, but on top)
Sub TxtPretend(FilePath As String, txt As String)
    '#INCLUDE TxtOverwrite
    '#INCLUDE TxtRead
    Dim s As String
    s = TxtRead(FilePath)
    TxtOverwrite FilePath, txt & Chr(10) & s
End Sub

Function TxtAppend(sFile As String, sText As String)
    On Error GoTo ERR_HANDLER
    Dim iFileNumber           As Integer
    iFileNumber = FreeFile
    Open sFile For Append As #iFileNumber
    Print #iFileNumber, sText
    Close #iFileNumber
Exit_Err_Handler:
    Exit Function
ERR_HANDLER:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: Txt_Append" & vbCrLf & _
           "Error Description: " & err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    GoTo Exit_Err_Handler
End Function

Function OpenTextFile$(f)
    With CreateObject("ADODB.Stream")
        .Charset = "utf-8"
        .Open
        .LoadFromFile f
        OpenTextFile = .ReadText
        .Close
    End With
End Function

Function TxtRead(sPath As Variant) As String
    Dim sTXT As String
    If Dir(sPath) = "" Then
        MsgBox "File was not found."
        Exit Function
    End If
    Open sPath For Input As #1
    Do Until EOF(1)
        Line Input #1, sTXT
        TxtRead = TxtRead & sTXT & vbLf
    Loop
    Close
    If Len(TxtRead) = 0 Then
        TxtRead = ""
    Else
        TxtRead = left(TxtRead, Len(TxtRead) - 1)
    End If
End Function

Sub testSplitProcTXT()
    '#INCLUDE SplitATextFileintoIndividualOnes
    SplitATextFileintoIndividualOnes "C:\Users\acer\Desktop\test\ArrayContainsInRowOrColumn2D.txt"
End Sub

Sub SplitATextFileintoIndividualOnes(FilePath As Variant)
    '#INCLUDE TxtOverwrite
    '#INCLUDE TxtRead
    Dim FName As String
    Dim Pth As String
    Dim txt As String
    Dim i As Long
    Pth = left(FilePath, InStrRev(FilePath, "\"))
    txt = TxtRead(FilePath)
    a = Split(TxtRead(FilePath), vbLf)
    Dim out As String
    For i = LBound(a) To UBound(a)
        If InStr(1, a(i), "Declare ") > 0 Then
            Do While Right(Trim(a(i)), 1) = "_"
                i = i + 1
            Loop
        End If
        out = IIf(out = "", a(i), out & a(i)) & vbNewLine
        If InStr(1, a(i), "Sub ") > 0 Then
            FName = Split(a(i), "Sub ")(1)
            FName = Trim(Split(FName, "(")(0)) & ".txt"
        ElseIf InStr(1, a(i), "Function ") > 0 Then
            FName = Split(a(i), "Function ")(1)
            FName = Trim(Split(FName, "(")(0)) & ".txt"
        End If
        If InStr(1, a(i), "End Sub") > 0 Or InStr(1, a(i), "End Function") > 0 Then
            TxtOverwrite Pth & FName, out
            out = ""
            FName = ""
        End If
    Next
    Set f = Nothing
    Set fs = Nothing
End Sub

Sub MergeFileText(FileCollection As Collection, NewFile As String, Optional criteria As String = "*.txt")
    '#INCLUDE TxtOverwrite
    '#INCLUDE TxtRead
    Dim s As String
    For Each item In FileCollection
        s = s & vbNewLine & TxtRead(FolderPath & item)
    Next
    TxtOverwrite NewFile, s
End Sub

Sub PretendListOfContainedProceduresInTXT(fileName As String)
    '#INCLUDE TxtOverwrite
    '#INCLUDE TxtRead
    '#INCLUDE ProceduresOfTXT
    Dim v As Variant: v = ProceduresOfTXT(fileName, True)
    If TypeName(v) = "Empty" Then Exit Sub
    Dim s As String: s = TxtRead(fileName)
    Dim line As String: line = String(30, "'")
    TxtOverwrite fileName, _
                 line & vbNewLine & _
                 "'Contains the following " & "#" & UBound(v) & " procedures " & vbNewLine & line & vbNewLine & "'" & _
                 Join(v, vbNewLine & "'") & vbNewLine & vbNewLine & s
End Sub

Function ProceduresOfTXT(FilePath As Variant, Optional NameOnly As Boolean) As Variant
    '#INCLUDE SortArray
    '#INCLUDE joinArrays
    '#INCLUDE TxtRead
    Dim var
    var = Split(TxtRead(CStr(FilePath)), Chr(10))
    Dim out
    out = joinArrays(Filter(var, "Sub "), Filter(var, "Function "))
    If TypeName(out) = "Empty" Then Exit Function
    out = Filter(out, "(", True)
    out = Filter(out, "Declare", False)
    out = Filter(out, Chr(34) & "Sub ", False)
    out = Filter(out, Chr(34) & "Function ", False)
    If NameOnly = True Then
        Dim i As Long
        For i = LBound(out) To UBound(out)
            out(i) = left(out(i), InStr(1, out(i), "(") - 1)
            out(i) = Replace(out(i), "Private ", "")
            out(i) = Replace(out(i), "Public ", "")
            out(i) = Replace(out(i), "Sub ", "")
            out(i) = Replace(out(i), "Function ", "")
        Next
    End If
    out = SortArray(out)
    ProceduresOfTXT = out
    Rem ProceduresOfTXT = Join(out, Chr(10))
End Function

Sub ListProceduresOfTXT(FilePaths As Variant, Optional NameOnly As Boolean)
    '#INCLUDE ArrayToRange1d
    '#INCLUDE ProceduresOfTXT
    Dim fileName As String
    Dim var
    Dim out As String
    Dim element
    Dim FileElement
    If TypeName(FilePaths) = "String" Then
        var = ProceduresOfTXT(FilePaths, NameOnly)
        For Each element In var
            out = IIf(out = "", element & "," & FilePaths, out & vbNewLine & element & "," & FilePaths)
        Next
    Else
        For Each FileElement In FilePaths
            var = ProceduresOfTXT(FileElement, NameOnly)
            For Each element In var
                out = IIf(out = "", element & "," & FileElement, out & vbNewLine & element & "," & FileElement)
            Next
        Next
    End If
    ArrayToRange1d Split(out, vbNewLine)
End Sub

Sub TxtRemoveBlankLines(FileFullPath As Variant)
    '#INCLUDE OpenTextFile
    Const ForReading = 1
    Const ForWriting = 2
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Set objFile = objFSO.OpenTextFile(FileFullPath, ForReading)
    Do Until objFile.AtEndOfStream
        strLine = objFile.ReadLine
        If Len(Trim(strLine)) > 0 Then
            strNewContents = strNewContents & strLine & vbCrLf
        End If
    Loop
    objFile.Close
    Set objFile = objFSO.OpenTextFile(FileFullPath, ForWriting)
    objFile.Write strNewContents
    objFile.Close
End Sub

Sub TxtRemoveComments(FileFullPath As Variant)
    '#INCLUDE OpenTextFile
    Const ForReading = 1
    Const ForWriting = 2
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Set objFile = objFSO.OpenTextFile(FileFullPath, ForReading)
    Do Until objFile.AtEndOfStream
        strLine = objFile.ReadLine
        If left(Trim(strLine), 1) <> "'" Then
            strNewContents = strNewContents & strLine & vbCrLf
        End If
    Loop
    objFile.Close
    Set objFile = objFSO.OpenTextFile(FileFullPath, ForWriting)
    objFile.Write strNewContents
    objFile.Close
End Sub

Rem @Subfolder Files>ZIPFiles
Sub FilesAndOrFoldersInFolderOrZipDemo()
    '#INCLUDE dp
    '#INCLUDE FilesAndOrFoldersInFolderOrZip
    Dim out As New Collection
    FilesAndOrFoldersInFolderOrZip _
        FolderOrZipFilePath:="C:\Users\acer\Dropbox\SOFTWARE\EXCEL\00 Review", _
        LogFolders:=True, _
        LogFiles:=False, _
        ScanInSubfolders:=False, _
        out:=out
    dp out
End Sub

Function FilesAndOrFoldersInFolderOrZip(ByVal FolderOrZipFilePath As Variant, LogFolders As Boolean, LogFiles As Boolean, ScanInSubfolders As Boolean, out As Collection, Optional Filter As String = "*")
    Dim oSh As New Shell
    Dim ofi As Object
    For Each ofi In oSh.Namespace(FolderOrZipFilePath).items
        If ofi.IsFolder Then
            If LogFolders Then
                out.Add ofi.Path & "\"
            End If
            If ScanInSubfolders Then FilesAndOrFoldersInFolderOrZip ofi.Path, LogFolders, LogFiles, ScanInSubfolders, out, Filter
        Else
            If LogFiles Then
                If UCase(ofi.Name) Like UCase(Filter) Then
                    out.Add ofi.Path
                End If
            End If
        End If
    Next
    Set FilesAndOrFoldersInFolderOrZip = out
    Set oSh = Nothing
End Function

Public Sub UnzipToOwnFolder(ZippedFile As String, DeleteExistingFiles As Boolean, DeleteZip As Boolean)
    Rem for each cell in selection.cells: UnzipToOwnFolder cell.text,False,false :next
    '#INCLUDE RecycleSafe
    '#INCLUDE FoldersCreate
    '#INCLUDE FolderExists
    '#INCLUDE FilesAndOrFoldersInFolderOrZip
    Dim FileCollection As New Collection
    FilesAndOrFoldersInFolderOrZip ZippedFile, False, True, False, FileCollection
    Dim FolderCollection As New Collection
    FilesAndOrFoldersInFolderOrZip ZippedFile, True, False, False, FolderCollection
    Dim shell_app           As Object:     Set shell_app = CreateObject("Shell.Application")
    Rem   Dim FilesInZip          As Long:        FilesInZip = shell_app.Namespace(CVar(ZippedFile)).items.Count
    Dim LastSlash            As Long:       LastSlash = InStrRev(ZippedFile, "\")
    Dim Dot                      As Long:      Dot = InStrRev(ZippedFile, ".")
    Dim ParentFolder       As String:     ParentFolder = left(ZippedFile, LastSlash)
    Dim UnzipToFolder   As String
    If FolderCollection.count = 1 And FileCollection.count = 0 Then
        UnzipToFolder = ParentFolder
    ElseIf FolderCollection.count > 1 Or FileCollection.count > 0 Then
        UnzipToFolder = left(ZippedFile, Dot - 1) & "\"
        If DeleteExistingFiles Then
            If FolderExists(UnzipToFolder) Then RecycleSafe UnzipToFolder
        End If
        FoldersCreate UnzipToFolder
    End If
    shell_app.Namespace(CVar(UnzipToFolder)).CopyHere shell_app.Namespace(CVar(ZippedFile)).items
    If DeleteZip Then RecycleSafe ZippedFile
    Set shell_app = Nothing
End Sub

Public Sub UnzipAllInFolder(source_folder As String)
    '#INCLUDE create_temp_zip_folder
    '#INCLUDE Zip
    Dim current_zip_file As String
    current_zip_file = Dir(source_folder & "\*.zip")
    If Len(current_zip_file) = 0 Then
        MsgBox "No zip files found!", vbExclamation
        Exit Sub
    End If
    Dim zip_folder As String
    zip_folder = source_folder & "\unzipped"
    Dim error_message As String
    If Not create_temp_zip_folder(zip_folder, error_message) Then
        MsgBox error_message, vbCritical, "Error"
        Exit Sub
    End If
    Dim shell_app As Object
    Set shell_app = CreateObject("Shell.Application")
    Do While Len(current_zip_file) > 0
        shell_app.Namespace(CVar(zip_folder)).CopyHere shell_app.Namespace(source_folder & "\" & current_zip_file).items
        current_zip_file = Dir
    Loop
    Set shell_app = Nothing
End Sub

Function create_temp_zip_folder(ByVal zip_folder As String, ByRef error_message As String) As Boolean
    '#INCLUDE FolderExists
    On Error GoTo Error_Handler
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    If fso.FolderExists(zip_folder) Then
        fso.DeleteFolder zip_folder, True
    End If
    fso.CreateFolder zip_folder
    create_temp_zip_folder = True
    Set fso = Nothing
    Exit Function
Error_Handler:
    error_message = "Error " & err.Number & ":" & vbCrLf & vbCrLf & err.Description
End Function

Public Function getFolder() As String
    With Application.FileDialog(msoFileDialogFolderPicker)
        .AllowMultiSelect = False
        .title = "Select a folder"
        .Show
        If .SelectedItems.count > 0 Then
            getFolder = .SelectedItems.item(1)
        Else
            'MsgBox "Folder is not selected."
        End If
    End With
End Function



'F_TreeView	1

Rem @Folder Treeview Declarations
Public Enum tvImages
    tvProject = 1
    tvSheet = 2
    tvForm = 3
    tvModule = 4
    tvClass = 5
    tvMacro = 6
    tvText = 7
End Enum

Rem @Folder Treeview
Sub FindCode(Optional s As String)
    '#INCLUDE CodepaneSelection
    '#INCLUDE TreeviewExpandAllNodes
    '#INCLUDE TreeviewAssignProjectImages
    '#INCLUDE FindCodeEverywhere
    Load uCodeFinder
    If s = "" Then s = CodepaneSelection
    If Len(s) > 0 Then
        FindCodeEverywhere s, uCodeFinder.TreeView1
        TreeviewAssignProjectImages uCodeFinder.TreeView1
        TreeviewExpandAllNodes uCodeFinder.TreeView1
    End If
    uCodeFinder.TextBox1.TEXT = s
    uCodeFinder.Show
End Sub

Sub DebugPrintCodeLinesContaining(f)
    '#INCLUDE ProceduresOfModule
    '#INCLUDE dp
    '#INCLUDE ProtectedVBProject
    '#INCLUDE GetModuleText
    '#INCLUDE GetProjectText
    '#INCLUDE GetProcText
    Const ModuleString = vbNewLine & "    m|"
    Const Procedurestring = "" & vbTab & "p" & "|" & "---" & "| "
    Const FoundString = "" & vbTab & "s" & "|" & vbTab & " |" & "---" & "| "
    Dim X, Y, s, p As Variant
    Dim Module As VBComponent
    On Error Resume Next
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not ProtectedVBProject(Workbooks(Y.Name)) Then
                If err.Number = 0 Then
                    If UBound(Filter(Split(GetProjectText(Workbooks(Y.Name)), vbNewLine), f, True, vbTextCompare)) > -1 Then
                        dp vbNewLine
                        dp "----------------------------------"
                        dp "| " & Y.Name
                        dp "----------------------------------"
                        For Each Module In Workbooks(Y.Name).VBProject.VBComponents
                            If UBound(Filter(Split(GetModuleText(Module), vbNewLine), f, True, vbTextCompare)) > -1 Then
                                dp ModuleString & Module.Name
                                For Each p In ProceduresOfModule(Module)
                                    If UBound(Filter(Split(GetProcText(Module, CStr(p)), vbNewLine), f, True, vbTextCompare)) > -1 Then
                                        dp Procedurestring & CStr(p)
                                        s = Filter(Split(GetProcText(Module, CStr(p)), vbNewLine), f, True, vbTextCompare)
                                        For i = 0 To UBound(s)
                                            dp FoundString & Trim(s(i))
                                        Next i
                                    End If
                                Next p
                            End If
                        Next Module
                    End If
                End If
            End If
            err.clear
        Next Y
    Next X
End Sub

Sub TreeviewExpandAllNodes(TV As TreeView)
    For i = 1 To TV.Nodes.count
        TV.Nodes(i).Expanded = True
    Next
End Sub

Sub TreeviewCollapseAllNodes(TV As TreeView)
    For i = 1 To TV.Nodes.count
        TV.Nodes(i).Expanded = False
    Next
End Sub

Sub TreeviewClear(TV As TreeView)
    For i = TV.Nodes.count To 1 Step -1
        TV.Nodes.Remove i
    Next
End Sub

Sub TreeviewCheckAllChildren(parent As MSComctlLib.node, _
                             Optional check As Boolean = True)
    Rem In userform:
    Rem Sub treeview1_NodeCheck(ByVal node As MSComctlLib.node)
    Rem     TreeviewNodeCheck node, node.Checked
    Rem End Sub
    Dim child As MSComctlLib.node
    parent.Checked = check
    Set child = parent.child
    While Not child Is Nothing
        TreeviewCheckAllChildren child, check
        Set child = child.Next
    Wend
End Sub

Public Function TreeviewGetLevel(theNode As node) As Integer
    TreeviewGetLevel = 1
    Do Until theNode.Root = theNode.FirstSibling
        TreeviewGetLevel = TreeviewGetLevel + 1
        Set theNode = theNode.parent
    Loop
End Function

Sub PopulateTreeviewFromSheetHierarchy( _
    TargetTreeView As TreeView, _
    StartRange As Range, _
    Optional ClearPreviousNodes As Boolean = True, _
    Optional Expanded As Boolean = False)
    Rem example use
    Rem    PopulateTreeviewFromSheetHierarchy me.Treeview1,thisworkbook.sheets("TreeviewHierarchy").range("A1"),true,false
    Rem example of sheet structure
    Rem  |1|2|3
    Rem 1|A| |
    Rem 2| |1|
    Rem 3| | |1.1
    Rem 4| | |1.2
    Rem 5|B| |
    Rem 6| |2|
    Rem 7| | |2.1
    Rem 8| | |2.2
    Dim nP As node
    Dim c As Excel.Range
    On Error Resume Next
    With TargetTreeView
        If ClearPreviousNodes = True Then .Nodes.clear
        For Each c In StartRange.parent.Columns(StartRange.Column).SpecialCells(xlCellTypeConstants)
            Set nP = .Nodes.Add(, , c.Address, c.Value)
        Next
        For Each c In StartRange.CurrentRegion
            If c.Value <> vbNullString And c.Address <> StartRange.Address And c.Column <> 1 Then
                Set nP = .Nodes(c.OFFSET(, -1).End(xlUp).Address)
                If nP Is Nothing Then
                    MsgBox "ERROR: Parent node " & c.OFFSET(, -1).End(xlUp).Value & " not found...", vbExclamation, "Error"
                    Exit Sub
                End If
                .Nodes.Add nP, tvwChild, c.Address, c.Value
                If err.Number <> 0 Then
                    MsgBox "ERROR: The node " & c.Value & " is a duplicate. All node descrptions must be unique", vbExclamation, "Error"
                    Exit Sub
                End If
                nP.Expanded = Expanded
            End If
        Next
        With .Nodes(Range(cROOT).Address)
            .SELECTED = True
            .EnsureVisible
        End With
    End With
    Exit Sub
End Sub

Sub TreeviewAllProjects(TV As TreeView)
    '#INCLUDE ProceduresOfModule
    '#INCLUDE getModuleName
    '#INCLUDE ProtectedVBProject
    Dim nP As node
    Dim nM As node
    Dim nS As node
    Dim X, Y, s, p As Variant
    Dim Module As VBComponent
    On Error Resume Next
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not ProtectedVBProject(Workbooks(Y.Name)) Then
                If err.Number = 0 Then
                    Set nP = TV.Nodes.Add(, , , Y.Name)
                    For Each element In Array(vbext_ct_Document, vbext_ct_MSForm, vbext_ct_StdModule, vbext_ct_ClassModule)
                        For Each Module In Workbooks(Y.Name).VBProject.VBComponents
                            If Module.Type = element Then
                                Set nM = TV.Nodes.Add(nP, tvwChild, , getModuleName(Module))
                                For Each p In ProceduresOfModule(Module)
                                    Set nS = TV.Nodes.Add(nM, tvwChild, , CStr(p))
                                Next p
                            End If
                        Next Module
                    Next
                End If
            End If
            err.clear
        Next Y
    Next X
End Sub

Sub ImageListLoadProjectIcons(imgList As ImageList, TV As TreeView)
    strPath = "C:\Users\acer\Dropbox\SOFTWARE\EXCEL\0 Alex\treeviewicons\"
    With imgList.ListImages
        .Add , "Project", LoadPicture(strPath & "Project.jpg")
        .Add , "Sheet", LoadPicture(strPath & "Sheet.jpg")
        .Add , "Form", LoadPicture(strPath & "Form.jpg")
        .Add , "Module", LoadPicture(strPath & "Module.jpg")
        .Add , "Class", LoadPicture(strPath & "Class.jpg")
        .Add , "Macro", LoadPicture(strPath & "Macro.jpg")
        .Add , "Text", LoadPicture(strPath & "Text.jpg")
    End With
    TV.ImageList = imgList
End Sub

Sub TreeviewAssignProjectImages(TV As TreeView)
    '#INCLUDE ComponentTypeToString
    '#INCLUDE ModuleOfWorksheet
    '#INCLUDE TreeviewGetLevel
    Dim i As Long
    Dim Module As VBComponent
    For i = 1 To TV.Nodes.count
        Select Case TreeviewGetLevel(TV.Nodes.item(i))
            Case 1
                If InStr(1, TV.Nodes.item(i).TEXT, ".") = 0 Then GoTo Skip
                TV.Nodes.item(i).image = tvImages.tvProject
            Case 2
                Set TargetWorkbook = Workbooks(TV.Nodes.item(i).parent.TEXT)
                If InStr(1, TargetWorkbook.Name, ".") = 0 Then GoTo Skip
                ModuleName = TV.Nodes.item(i).TEXT
                Set Module = Nothing
                On Error Resume Next
                Set Module = TargetWorkbook.VBProject.VBComponents(ModuleName)
                On Error GoTo 0
                If Module Is Nothing Then
                    Set Module = ModuleOfWorksheet(TargetWorkbook.Worksheets(TV.Nodes.item(i).TEXT))
                End If
                Select Case ComponentTypeToString(Module.Type)
                    Case "Document Module"
                        TV.Nodes.item(i).image = tvImages.tvSheet
                    Case "UserForm"
                        TV.Nodes.item(i).image = tvImages.tvForm
                    Case "Code Module"
                        TV.Nodes.item(i).image = tvImages.tvModule
                    Case "Class Module"
                        TV.Nodes.item(i).image = tvImages.tvClass
                End Select
            Case 3
                TV.Nodes.item(i).image = tvImages.tvMacro
            Case 4
                TV.Nodes.item(i).image = tvImages.tvText
        End Select
Skip:
    Next i
End Sub

Sub TreeviewGotoProjectElement(TV As TreeView)
    '#INCLUDE GoToModule
    '#INCLUDE TreeviewGetLevel
    Dim Module As VBComponent
    Select Case TreeviewGetLevel(TV.SelectedItem)
        Case Is = 1
        Case Is = 2
            With TV.SelectedItem
                On Error Resume Next
                Set Module = Workbooks(.parent.TEXT).VBProject.VBComponents(.TEXT)
                On Error GoTo 0
                If Module Is Nothing Then Set Module = Workbooks(.parent.TEXT).VBProject.VBComponents(Workbooks(.parent.TEXT).SHEETS(.TEXT).CodeName)
                GoToModule Module
            End With
        Case Is = 3
            With TV.SelectedItem
                On Error Resume Next
                Set Module = Workbooks(.parent.parent.TEXT).VBProject.VBComponents(.parent.TEXT)
                On Error GoTo 0
                If Module Is Nothing Then Set Module = _
                   Workbooks(.parent.parent.TEXT).VBProject.VBComponents(Workbooks(.parent.parent.TEXT).SHEETS(.parent.TEXT).CodeName)
                GoToModule Module
                For i = 1 To Module.CodeModule.CountOfLines
                    If InStr(1, Module.CodeModule.Lines(i, 1), "Sub " & .TEXT) > 0 Or _
                                                                               InStr(1, Module.CodeModule.Lines(i, 1), "Function " & .TEXT) > 0 Then
                        Module.CodeModule.CodePane.SetSelection i, 1, i, 1
                        Exit Sub
                    End If
                Next
            End With
        Case Is = 4
            With TV.SelectedItem
                Set Module = Workbooks(.parent.parent.parent.TEXT).VBProject.VBComponents(.parent.parent.TEXT)
                GoToModule Module
                DoEvents
                For i = 1 To Module.CodeModule.CountOfLines
                    If Trim(Module.CodeModule.Lines(i, 1)) = .TEXT Then
                        Module.CodeModule.CodePane.SetSelection i, 1, i, 1
                        Exit Sub
                    End If
                Next
            End With
    End Select
End Sub

Sub FindCodeEverywhere(f As String, TV As TreeView)
    '#INCLUDE ProceduresOfModule
    '#INCLUDE getModuleName
    '#INCLUDE ProtectedVBProject
    '#INCLUDE GetModuleText
    '#INCLUDE GetProjectText
    '#INCLUDE GetProcText
    Dim nP As node
    Dim nM As node
    Dim nS As node
    Dim nF As node
    Dim X, Y, s, p As Variant
    Dim Module As VBComponent
    On Error Resume Next
    For Each X In Array(Workbooks, AddIns)
        For Each Y In X
            If Not ProtectedVBProject(Workbooks(Y.Name)) Then
                If err.Number = 0 Then
                    If UBound(Filter(Split(GetProjectText(Workbooks(Y.Name)), vbNewLine), f, True, vbTextCompare)) > -1 Then
                        Set nP = TV.Nodes.Add(, , , Y.Name)
                        For Each Module In Workbooks(Y.Name).VBProject.VBComponents
                            If UBound(Filter(Split(GetModuleText(Module), vbNewLine), f, True, vbTextCompare)) > -1 Then
                                Set nM = TV.Nodes.Add(nP, tvwChild, , getModuleName(Module))
                                For Each p In ProceduresOfModule(Module)
                                    If UBound(Filter(Split(GetProcText(Module, CStr(p)), vbNewLine), f, True, vbTextCompare)) > -1 Then
                                        Set nS = TV.Nodes.Add(nM, tvwChild, , CStr(p))
                                        s = Filter(Split(GetProcText(Module, CStr(p)), vbNewLine), f, True, vbTextCompare)
                                        For i = 0 To UBound(s)
                                            Set nF = TV.Nodes.Add(nS, tvwChild, , Trim(s(i)))
                                        Next i
                                    End If
                                Next p
                            End If
                        Next Module
                    End If
                End If
            End If
            err.clear
        Next Y
    Next X
End Sub

Sub TreeviewSelectNodes(TV As TreeView, SingleSelect As Boolean, lvl1crit As String, Optional CriteriaByLevel As Variant)
    Dim nd As node
    For Each nd In TV.Nodes
        If nd.TEXT = lvl1crit Then
            nd.SELECTED = True
            nd.Expanded = True
            If SingleSelect = True Then Exit For
        End If
    Next
    X = nd.index + 1
    Dim crit
    For Each crit In CriteriaByLevel
        For i = X To TV.Nodes.count
            If TV.Nodes.item(i).TEXT = crit Then
                TV.Nodes.item(i).SELECTED = True
                TV.Nodes.item(i).Expanded = True
                If SingleSelect = True Then Exit For
            End If
        Next
        X = i + 1
    Next
End Sub



'F_ListView	1

Rem @Folder ListView Declarations
Public Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" ( _
ByVal hWnd As Long, _
ByVal wMsg As Long, _
ByVal wParam As Long, _
lParam As Any) As Long
Public Const LVM_FIRST = &H1000
Public Const LVM_SETCOLUMNWIDTH = (LVM_FIRST + 30)
Public Const LVSCW_AUTOSIZE = -1
Public Const LVSCW_AUTOSIZE_USEHEADER = -2

Rem @Folder ListView
Public Sub ListviewAutoSizeColumns(LV As ListView, Optional Column As ColumnHeader = Nothing)
    Dim c As ColumnHeader
    If Column Is Nothing Then
        For Each c In LV.ColumnHeaders
            SendMessage LV.hWnd, LVM_FIRST + 30, c.index - 1, ByVal -2
        Next
    Else
        SendMessage LV.hWnd, LVM_FIRST + 30, Column.index - 1, ByVal -2
    End If
    LV.Refresh
End Sub

Sub ListViewEdit(LV As ListView, RowIndex As Long, ColumnIndex As Long, NewValue As Variant)
    Rem base 1 like range
    If ColumnIndex = 1 Then
        LV.ListItems(RowIndex).TEXT = NewValue
    ElseIf ColumnIndex > 1 Then
        LV.ListItems(RowIndex).ListSubItems(ColumnIndex - 1).TEXT = NewValue
    End If
End Sub

Function ListViewSelected(LV As ListView, Optional ColumnIndex As Long = 0, Optional delimeter As String = ",") As Variant
    Rem base 1 like range
retry:
    If ColumnIndex = 0 Then
        Dim s As String
        s = LV.ListItems(LV.SelectedItem.index)
        Dim counter
        For counter = 1 To LV.ColumnHeaders.count - 1
            s = s & delimeter & LV.ListItems(LV.SelectedItem.index).ListSubItems(counter)
        Next
        ListViewSelected = Split(s, delimeter)
    ElseIf ColumnIndex = 1 Then
        ListViewSelected = LV.ListItems(LV.SelectedItem.index)
    ElseIf ColumnIndex > 1 Then
        ListViewSelected = LV.ListItems(ColumnIndex).ListSubItems(ColumnIndex - 1)
    Else
        ColumnIndex = -1
        GoTo retry
    End If
End Function

Sub ListViewPopulateFromArray(LV As ListView, inputArray As Variant)
    Dim vListItem As listItem
    Dim vChildItem As ListSubItem
    Dim vHeader As Variant
    Dim iRows As Long, iColumns As Long
    For iColumns = LBound(inputArray, 2) To UBound(inputArray, 2)
        Set vHeader = LV.ColumnHeaders.Add(, , inputArray(LBound(inputArray, 1), iColumns))
    Next
    For iRows = LBound(inputArray, 1) + 1 To UBound(inputArray, 1)
        Set vListItem = LV.ListItems.Add(, , inputArray(iRows, 1))
        For iColumns = LBound(inputArray, 2) + 1 To UBound(inputArray, 2)
            Set vChildItem = vListItem.ListSubItems.Add(, , inputArray(iRows, iColumns))
        Next
    Next
    LV.View = lvwReport
End Sub

Sub ListViewClear(LV As ListView)
    Dim i As Long
    For i = LV.ListItems.count To 1 Step -1
        LV.ListItems.Remove i
    Next
    LV.Refresh
End Sub



'F_Collections	1

Rem @Folder Collection
Function collectionToString(coll As Collection, delim As String) As String
    Dim element
    Dim out As String
    For Each element In coll
        out = IIf(out = "", element, out & delim & element)
    Next
    collectionToString = out
End Function

Public Function CollectionOfUnique( _
       FullCollection As Collection) _
        As Variant
    Dim UniqueCollection As Collection: Set UniqueCollection = New Collection
    Dim eachItem As Variant
    On Error Resume Next
    For Each eachItem In FullCollection
        UniqueCollection.Add eachItem, CStr(eachItem)
    Next
    On Error GoTo 0
    Set CollectionOfUnique = UniqueCollection
End Function

Public Function SortCollection(colInput As Collection) As Collection
    Dim iCounter As Integer
    Dim iCounter2 As Integer
    Dim temp As Variant
    Set SortCollection = New Collection
    For iCounter = 1 To colInput.count - 1
        For iCounter2 = iCounter + 1 To colInput.count
            If colInput(iCounter) > colInput(iCounter2) Then
                temp = colInput(iCounter2)
                colInput.Remove iCounter2
                colInput.Add temp, , iCounter
            End If
        Next iCounter2
    Next iCounter
    Set SortCollection = colInput
End Function

Public Function CollectionContains(Kollection As Collection, Optional key As Variant, Optional item As Variant) As Boolean
    Dim strKey As String
    Dim var As Variant
    If Not IsMissing(key) Then
        strKey = CStr(key)
        On Error Resume Next
        CollectionContains = True
        var = Kollection(strKey)
        If err.Number = 91 Then GoTo CheckForObject
        If err.Number = 5 Then GoTo NotFound
        On Error GoTo 0
        Exit Function
CheckForObject:
        If IsObject(Kollection(strKey)) Then
            CollectionContains = True
            On Error GoTo 0
            Exit Function
        End If
NotFound:
        CollectionContains = False
        On Error GoTo 0
        Exit Function
    ElseIf Not IsMissing(item) Then
        CollectionContains = False
        For Each var In Kollection
            If var = item Then
                CollectionContains = True
                Exit Function
            End If
        Next var
    Else
        CollectionContains = False
    End If
End Function

Function CollectionToArray(c As Collection) As Variant
    Dim a() As Variant: ReDim a(0 To c.count - 1)
    Dim i As Long
    For i = 1 To c.count
        a(i - 1) = c.item(i)
    Next
    CollectionToArray = a
End Function

Function CollectionsToArrayTable(collections As Collection) As Variant
    If collections.count = 0 Then Exit Function
    Dim columnCount As Long
    columnCount = collections.count
    Dim rowCount As Long
    rowCount = collections.item(1).count
    Dim var As Variant
    ReDim var(1 To rowCount, 1 To columnCount)
    Dim cols As Long
    Dim rows As Long
    For rows = 1 To rowCount
        For cols = 1 To collections.count
            var(rows, cols) = collections(cols).item(rows)
        Next cols
    Next rows
    CollectionsToArrayTable = var
End Function



'Sheet3	100



'Sheet6	100



'SheetVisibility	100

Const VISIBILITY_MANAGER As String = "o"

Sub AddGoToSheetVisibilityManagerShape()
    '#INCLUDE GoToSheetVisibilityManager
    If TypeName(Selection) <> "Range" Then Exit Sub
    Application.ScreenUpdating = False
    Dim s As Shape
    Dim ws As Worksheet
    Set s = ThisWorkbook.SHEETS(VISIBILITY_MANAGER).Shapes("GoToSheetVisibilityManager")
    s.Copy
    Dim ts As Shape
    Dim cell As Range
    For Each cell In Selection
        If cell <> "" Then
            Set ws = Workbooks(s.parent.parent.Name).SHEETS(cell.TEXT)
            On Error Resume Next
            Set ts = ws.Shapes("GoToSheetVisibilityManager")
            On Error GoTo 0
            If ts Is Nothing Then
                ws.Paste
                Set ts = ws.Shapes(ws.Shapes.count)
                ts.left = 1
                ts.top = 1
                ws.Hyperlinks.Add Anchor:=ts, Address:="", _
                                  SubAddress:="o!A1", ScreenTip:=""
                Application.GoTo ws.Cells(1, 1), True
            End If
        End If
    Next
    GoToSheetVisibilityManager
    Application.ScreenUpdating = True
End Sub

Sub GoToSheetVisibilityManager()
    ThisWorkbook.SHEETS(VISIBILITY_MANAGER).Activate
End Sub

Sub AddVisibilityControls()
    Dim FromCell As Range
    Dim ToCell As Range
    Dim s As Shape
    With ThisWorkbook.SHEETS(VISIBILITY_MANAGER)
        Set FromCell = .Range("A2")
        Set ToCell = .Cells(2, 3)
        Do While CellHasShape(ToCell) = True
            Set ToCell = ToCell.OFFSET(0, 1)
        Loop
        .Columns(ToCell.Column).ColumnWidth = 10
        FromCell.Copy ToCell
        For Each s In .Shapes
            If Not Intersect(ToCell, s.TopLeftCell) Is Nothing Then
                s.visible = True
                s.Name = "Shape_" & Replace(s.TopLeftCell.Address, "$", "")
            End If
        Next
        .Columns(ToCell.Column).AutoFit
    End With
End Sub

Function CellHasShape(cell As Range)
    Dim s As Shape
    With ThisWorkbook.SHEETS(VISIBILITY_MANAGER)
        For Each s In .Shapes
            If s.TopLeftCell.Address = cell.Address Then
                CellHasShape = True
                Exit Function
            End If
        Next
    End With
End Function

Sub DeleteShapesFromSelectedCells()
    Dim s As Shape
    For Each s In ThisWorkbook.SHEETS(VISIBILITY_MANAGER).Shapes
        If s.TopLeftCell.Column > 2 Then
            If Not Intersect(s.TopLeftCell, Selection) Is Nothing Then s.Delete
        End If
    Next
End Sub

Sub ListSheets()
    '#INCLUDE LoopSheetsSignalVisibility
    Application.ScreenUpdating = False
    Dim cell As Range
    Set cell = ThisWorkbook.SHEETS(VISIBILITY_MANAGER).Range("A3")
    Range(cell, cell.End(xlDown)).ClearContents
    Dim ws As Worksheet
    For Each ws In Worksheets
        If ws.Name <> VISIBILITY_MANAGER Then
            cell = ws.Name
            Set cell = cell.OFFSET(1, 0)
        End If
    Next
    Range(cell, cell.End(xlDown)).HorizontalAlignment = xlLeft
    LoopSheetsSignalVisibility
    Application.ScreenUpdating = True
End Sub

Sub ActivateSheet()
    SHEETS(ActiveSheet.Shapes(Application.Caller).TextFrame2.TextRange.TEXT).Activate
End Sub

Sub AllSheetsVisible()
    '#INCLUDE LoopSheetsSignalVisibility
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    For Each ws In Worksheets
        ws.visible = xlSheetVisible
    Next
    SheetVisibility.Activate
    LoopSheetsSignalVisibility
    Application.ScreenUpdating = True
End Sub

Sub AllSheetsHidden()
    '#INCLUDE LoopSheetsSignalVisibility
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    For Each ws In Worksheets
        If ws.Name <> VISIBILITY_MANAGER Then ws.visible = xlSheetHidden
    Next
    SheetVisibility.Activate
    LoopSheetsSignalVisibility
    Application.ScreenUpdating = True
End Sub

Sub LoopSheetsSignalVisibility()
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    Dim rng As Range
    On Error Resume Next
    Set rng = ThisWorkbook.SHEETS(VISIBILITY_MANAGER).UsedRange.SpecialCells(xlCellTypeConstants)
    On Error GoTo 0
    If rng Is Nothing Then Exit Sub
    Dim cell As Range
    For Each cell In rng
        On Error Resume Next
        Set ws = SHEETS(cell.TEXT)
        On Error GoTo 0
        If Not ws Is Nothing Then
            If ws.visible = xlSheetVisible Then
                cell.Font.color = RGB(0, 128, 0)
            Else
                cell.Font.color = RGB(128, 0, 0)
            End If
        End If
        Set ws = Nothing
    Next
    ThisWorkbook.SHEETS(VISIBILITY_MANAGER).Activate
    Application.ScreenUpdating = True
End Sub

Sub LoopSheetsMakeVisible()
    '#INCLUDE LoopSheetsSignalVisibility
    Application.ScreenUpdating = False
    Dim actSheet As Worksheet: Set actSheet = ActiveSheet
    Dim ws As Worksheet
    Dim rng As Range
    On Error Resume Next
    Set rng = ActiveSheet.Columns(ActiveSheet.Shapes(Application.Caller).TopLeftCell.Column).SpecialCells(xlCellTypeConstants)
    On Error GoTo 0
    If rng Is Nothing Then Exit Sub
    Dim cell As Range
    For Each cell In rng
        On Error Resume Next
        Set ws = SHEETS(cell.TEXT)
        On Error GoTo 0
        If Not ws Is Nothing Then ws.visible = xlSheetVisible
    Next
    actSheet.Activate
    LoopSheetsSignalVisibility
    Application.ScreenUpdating = True
End Sub

Sub LoopSheetsMakeHidden()
    '#INCLUDE LoopSheetsSignalVisibility
    Application.ScreenUpdating = False
    Dim actSheet As Worksheet: Set actSheet = ActiveSheet
    Dim ws As Worksheet
    Dim rng As Range
    On Error Resume Next
    Set rng = ActiveSheet.Columns(ActiveSheet.Shapes(Application.Caller).TopLeftCell.Column).SpecialCells(xlCellTypeConstants)
    On Error GoTo 0
    If rng Is Nothing Then Exit Sub
    Dim cell As Range
    For Each cell In rng
        On Error Resume Next
        Set ws = SHEETS(cell.TEXT)
        On Error GoTo 0
        If Not ws Is Nothing Then ws.visible = xlSheetHidden
    Next
    actSheet.Activate
    LoopSheetsSignalVisibility
    Application.ScreenUpdating = True
End Sub

Sub LoopSheetsToggleVisibility()
    '#INCLUDE LoopSheetsSignalVisibility
    '#INCLUDE ToggleSheetView
    Application.ScreenUpdating = False
    Dim actSheet As Worksheet: Set actSheet = ActiveSheet
    Dim ws As Worksheet
    Dim rng As Range
    On Error Resume Next
    Set rng = ActiveSheet.Columns(ActiveSheet.Shapes(Application.Caller).TopLeftCell.Column).SpecialCells(xlCellTypeConstants)
    On Error GoTo 0
    If rng Is Nothing Then Exit Sub
    Dim cell As Range
    For Each cell In rng
        On Error Resume Next
        Set ws = SHEETS(cell.TEXT)
        On Error GoTo 0
        If Not ws Is Nothing Then ToggleSheetView ws
    Next
    actSheet.Activate
    LoopSheetsSignalVisibility
    Application.ScreenUpdating = True
End Sub

Sub ToggleSheetView(ws As Worksheet)
    If ws.visible = xlSheetHidden Then
        ws.visible = xlSheetVisible
    Else
        If ws.Name <> ">" Then ws.visible = xlSheetHidden
    End If
End Sub

Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean)
    Dim rng As Range
    Set rng = ActiveSheet.Cells.SpecialCells(xlCellTypeConstants)
    If Intersect(Target, rng) Is Nothing Then Exit Sub
    On Error Resume Next
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS(Target.TEXT)
    On Error GoTo 0
    If ws Is Nothing Then Exit Sub
    
    ToggleSheetView ThisWorkbook.SHEETS(Target.TEXT)
   
    LoopSheetsSignalVisibility
    Cancel = True
End Sub

Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ThisWorkbook.SHEETS(CStr(Target))
    On Error GoTo 0
    If ws Is Nothing Then Exit Sub
    ws.visible = xlSheetVisible
    LoopSheetsSignalVisibility
    ws.Activate
    Cancel = True
End Sub



'Sheet7	100



'M_UserformReBuilder	1


Rem @Folder FormBuilder Declarations
Public UFSheet As Worksheet

Rem @Folder FormBuilder
Sub ExportUserform(ByRef uForm As VBComponent)
    '#INCLUDE GetModuleText
    '#INCLUDE WorkbookOfModule
    '#INCLUDE SortColumns
    '#INCLUDE PutFramesFirst
    Dim str As String
    Dim counter As Long
    Dim RowNumber As Long
    Dim ColumnNumber As Long
    Dim controlItem As MSForms.control
    Set UFSheet = ThisWorkbook.SHEETS("FormBuilder")
    UFSheet.Range("D:D").ClearContents
    UFSheet.Range("G:ZZ").ClearContents
    Application.ScreenUpdating = False
    RowNumber = 1
    ColumnNumber = 7
    Dim PropertyName As String
    Dim PropertyValue As Range
    Rem otherwise would throw error if control doesn
    On Error Resume Next
    Rem uForm.Controls
    For Each controlItem In uForm.Designer.Controls
        UFSheet.Cells(1, ColumnNumber) = TypeName(controlItem)
        For counter = 2 To 79
            PropertyName = UFSheet.Cells(counter, 6).Value
            Set PropertyValue = UFSheet.Cells(counter, ColumnNumber)
            PropertyValue.Value = CallByName(controlItem, PropertyName, VbGet)
            Rem mark if control is inside frame
            If UCase(PropertyName) = UCase("NAME") Then
                If controlItem.parent.Name <> uForm.Name Then
                    PropertyValue.Value = PropertyValue.Value & "_" & controlItem.parent.Name
                End If
            End If
        Next counter
        ColumnNumber = ColumnNumber + 1
    Next
    Rem export userform properties
    ColumnNumber = 2
    UFSheet.Cells(1, ColumnNumber) = uForm.Name
    UFSheet.Cells(2, ColumnNumber) = uForm.Name & "RC"
    RowNumber = 2
    Dim rng As Range
    Set rng = UFSheet.Range("A3:A" & UFSheet.Range("A" & rows.count).End(xlUp).row)
    For Each cell In rng
        cell.OFFSET(0, 1).Value = uForm.Properties(cell.Value)
    Next
    Rem export code
    ColumnNumber = 4
    UFSheet.Cells(1, 4) = "CODE"
    Dim Code As Variant
    Code = GetModuleText(WorkbookOfModule(uForm).VBProject.VBComponents(uForm.Name))
    Code = Split(Code, vbNewLine)
    UFSheet.Range("D2").RESIZE(UBound(Code) + 1).Value = WorksheetFunction.Transpose(Code)
    UFSheet.Cells.Range("G1:XFD1").EntireColumn.AutoFit
    UFSheet.Cells.NumberFormat = "General"
    With UFSheet.rows(1)
        .Font.Bold = True
        .Font.Size = 14
    End With
    Rem Sort-group controls and put frames first as they need to be created first to hold their controls
    Set rng = UFSheet.Range("F1").CurrentRegion.OFFSET(0, 1)
    Set rng = rng.RESIZE(, rng.Columns.count - 1)
    SortColumns rng
    PutFramesFirst
    Application.ScreenUpdating = True
End Sub

Sub PutFramesFirst()
    '#INCLUDE dp
    Dim ws As Worksheet
    Set ws = SHEETS("FormBuilder")
    Dim rng As Range
    Set rng = ws.Range("F1").CurrentRegion.OFFSET(0, 1).RESIZE(1)
    Set rng = rng.RESIZE(, rng.Columns.count - 1)
    dp rng.Address
    Dim cell As Range
    For Each cell In rng
        If cell Like "Frame" And cell.Column <> Columns("G").Column Then
            cell.EntireColumn.Cut
            ws.Columns("G").Insert
        End If
    Next
    For Each cell In rng
        If cell = "Frame" Then
            If InStr(1, cell.OFFSET(1), "_") = 0 Then
                cell.EntireColumn.Cut
                ws.Columns("G").Insert
            End If
        End If
    Next
End Sub

Public Sub CreateUserForm(Optional TargetWorkbook As Workbook)
    '#INCLUDE ArrayToString
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveWorkbook
    Set UFSheet = ThisWorkbook.SHEETS("FormBuilder")
    On Error Resume Next
    Dim ctr As MSForms.control
    Dim propertyCOUNTER As Long
    Dim counter As Long
    Dim cell As Range
    Dim rng As Range
    Rem ----create userform-------------------------
    Dim uf As VBComponent
    Set uf = TargetWorkbook.VBProject.VBComponents.Add(vbext_ct_MSForm)
    uf.Name = UFSheet.Range("B2")
    Set rng = UFSheet.Range("A3:A" & UFSheet.Range("A" & rows.count).End(xlUp).row)
    For Each cell In rng
        uf.Properties(cell.Value) = cell.OFFSET(0, 1).Value
    Next
    Rem ---add controls to userform-------------------
    Dim ControlName As Range
    Dim FrameName As String
    Set rng = UFSheet.Range("G1", UFSheet.Cells(1, Columns.count).End(xlToLeft))
    For Each cell In rng
        Set ControlName = cell.OFFSET(1)
        If InStr(1, ControlName.Value, "_") > 0 Then
            FrameName = Split(ControlName.Value, "_")(1)
            Set ctr = uf.Designer.Controls(FrameName).Add("forms." & cell & ".1")
            CallByName ctr, Split(ControlName.Value, "_")(0), VbLet, UFSheet.Cells(counter, cell.Column).Value
        Else
            Set ctr = uf.Designer.Controls.Add("forms." & cell & ".1")
            CallByName ctr, ControlName.Value, VbLet, UFSheet.Cells(counter, cell.Column).Value
        End If
        With ctr
            For counter = 3 To 71
                CallByName ctr, UFSheet.Cells(counter, 6).Value, VbLet, UFSheet.Cells(counter, cell.Column).Value
            Next counter
        End With
    Next cell
    Rem ---add code to userform--------------------------
    With UFSheet.Range("D1")
        .Value = "CODE"
        .Font.Bold = True
    End With
    Dim ImportCode As String
    ImportCode = ArrayToString(UFSheet.Range("D2:D" & UFSheet.Range("D" & rows.count).End(xlUp).row).Value, vbNewLine)
    uf.CodeModule.AddFromString (ImportCode)
End Sub


'EventListenerEmitter	2

Rem Developer Robert Todar

Option Explicit
Option Compare Text

' Array of all the different event listeners for every userform control and the form itself
Private EventList() As New EventListenerItem

' All the current possible events that can be emitted.
' Note, EmittedEvent is sent for all events!
Public Event EmittedEvent(ByRef control As Object, ByVal EventType As EmittedEvent, ByRef EventParameters As Collection)
Public Event Click(ByRef control As Object)
Public Event DblClick(ByRef control As Object, ByRef Cancel As MSForms.ReturnBoolean)
Public Event KeyUp(ByRef control As Object, ByRef KeyCode As MSForms.ReturnInteger, ByRef Shift As Integer)
Public Event KeyDown(ByRef control As Object, ByRef KeyCode As MSForms.ReturnInteger, ByRef Shift As Integer)
Public Event MouseOver(ByRef control As Object)
Public Event MouseOut(ByRef control As Object)
Public Event MouseMove(ByRef control As Object, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)
Public Event Focus(ByRef control As Object)
Public Event Blur(ByRef control As Object)
Public Event Change(ByRef control As Object)

' Events to Labels
Public Event LabelMouseOver(ByRef label As MSForms.label)
Public Event LabelMouseOut(ByRef label As MSForms.label)
Public Event LabelClick(ByRef label As MSForms.label)
Public Event LabelDoubleClick(ByRef label As MSForms.label, ByRef Cancel As MSForms.ReturnBoolean)
Public Event LabelMouseMove(ByRef label As MSForms.label, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)

' Events to Textboxes
Public Event TextboxFocus(ByRef Textbox As MSForms.Textbox)
Public Event TextboxBlur(ByRef Textbox As MSForms.Textbox)
Public Event TextboxMouseOver(ByRef Textbox As MSForms.Textbox)
Public Event TextboxMouseOut(ByRef Textbox As MSForms.Textbox)
Public Event TextboxClick(ByRef Textbox As MSForms.Textbox)
Public Event TextboxDoubleClick(ByRef Textbox As MSForms.Textbox, ByRef Cancel As MSForms.ReturnBoolean)
Public Event TextboxMouseMove(ByRef Textbox As MSForms.Textbox, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)

' Events to CommandButtons
Public Event CommandButtonMouseOver(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonMouseOut(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonClick(ByRef CommandButton As MSForms.CommandButton)
Public Event CommandButtonDoubleClick(ByRef CommandButton As MSForms.CommandButton, ByRef Cancel As MSForms.ReturnBoolean)
Public Event CommandButtonMouseMove(ByRef CommandButton As MSForms.CommandButton, ByRef Shift As Integer, ByRef X As Single, ByRef Y As Single)

' Types of events that can occur
Public Enum EmittedEvent
    Click
    DoubleClick
    MouseMove
    MouseOut
    MouseOver
    MouseDown
    MouseUp
    KeyUp
    KeyDown
    Focus
    Blur
End Enum

' Called by EventListenerItem class - main entryway of emitting all events
Public Sub EmitEvent(ByRef control As Object, ByVal EventType As EmittedEvent, Optional ByRef EventParameters As Collection)
    ' Event raised for all events. This is a way for the user to collect from a single location.
    RaiseEvent EmittedEvent(control, EventType, EventParameters)
    
    ' Specific events
    Select Case EventType
    
        Case Click
            RaiseEvent Click(control)
        
        Case DoubleClick
            RaiseEvent DblClick(control, EventParameters("Cancel"))
        
        Case KeyUp
            RaiseEvent KeyUp(control, EventParameters("KeyCode"), EventParameters("Shift"))
            
        Case KeyDown
            RaiseEvent KeyDown(control, EventParameters("KeyCode"), EventParameters("Shift"))
        
        Case MouseOver
            RaiseEvent MouseOver(control)
            
        Case MouseOut
            RaiseEvent MouseOut(control)
            
        Case Focus
            RaiseEvent Focus(control)
            
        Case Blur
            RaiseEvent Blur(control)
            
        Case MouseMove
            RaiseEvent MouseMove(control, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
        
    End Select
    
    ' Call the specific control type events
    Select Case TypeName(control)
        Case "Label"
            EmitLabelEvent control, EventType, EventParameters
            
        Case "Textbox"
            EmitTextboxEvent control, EventType, EventParameters
            
        Case "CommandButton"
            EmitCommandButtonEvent control, EventType, EventParameters
        
    End Select
End Sub

' Events for Labels
Private Sub EmitLabelEvent(ByRef label As MSForms.label, ByVal EventType As String, ByRef EventParameters As Collection)
    Select Case EventType
        Case EmittedEvent.Click
            RaiseEvent LabelClick(label)
            
        Case EmittedEvent.DoubleClick
            RaiseEvent LabelDoubleClick(label, EventParameters("Cancel"))
            
        Case EmittedEvent.MouseOver
            RaiseEvent LabelMouseOver(label)
            
        Case EmittedEvent.MouseOut
            RaiseEvent LabelMouseOut(label)

        Case EmittedEvent.MouseMove
            RaiseEvent MouseMove(label, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' Events for Textboxes
Private Sub EmitTextboxEvent(ByRef Textbox As MSForms.Textbox, ByVal EventType As String, ByRef EventParameters As Collection)
    Select Case EventType
        Case EmittedEvent.Blur
            RaiseEvent TextboxBlur(Textbox)
        
        Case EmittedEvent.Focus
            RaiseEvent TextboxFocus(Textbox)
    
        Case EmittedEvent.Click
            RaiseEvent TextboxClick(Textbox)
            
        Case EmittedEvent.DoubleClick
            RaiseEvent TextboxDoubleClick(Textbox, EventParameters("Cancel"))
            
        Case EmittedEvent.MouseOver
            RaiseEvent TextboxMouseOver(Textbox)
            
        Case EmittedEvent.MouseOut
            RaiseEvent TextboxMouseOut(Textbox)

        Case EmittedEvent.MouseMove
            RaiseEvent MouseMove(Textbox, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' Events for CommandButton
Private Sub EmitCommandButtonEvent(ByRef CommandButton As MSForms.CommandButton, ByVal EventType As String, ByRef EventParameters As Collection)
    Select Case EventType
        Case EmittedEvent.Click
            RaiseEvent CommandButtonClick(CommandButton)
            
        Case EmittedEvent.DoubleClick
            RaiseEvent CommandButtonDoubleClick(CommandButton, EventParameters("Cancel"))
            
        Case EmittedEvent.MouseOver
            RaiseEvent CommandButtonMouseOver(CommandButton)
            
        Case EmittedEvent.MouseOut
            RaiseEvent CommandButtonMouseOut(CommandButton)

        Case EmittedEvent.MouseMove
            RaiseEvent MouseMove(CommandButton, EventParameters("Shift"), EventParameters("X"), EventParameters("Y"))
    End Select
End Sub

' MUST CALL THIS IF YOU WANT TO programmatically SET CONTROL! OTHERWISE, EVENT'S WILL BE OFF!
Public Sub SetFocusToControl(ByRef control As Object)
    'If the user was to set focus through VBA then this code will fall apart considering
    'it is unaware of that event occurring.
    If Not control Is Nothing Then
        control.SetFocus
        EmitEvent control, Focus
    End If
End Sub

' ADD EVENT Listeners ON SPECIFIC CONTROLS - ALSO CALLED BY AddEventListenerAll
Public Sub AddEventListener(ByRef control As Object)
    ' Events are stored in a private EventListenerItem array
    If IsArrayEmpty(EventList) Then
        ReDim EventList(0 To 0)
    Else
        ReDim Preserve EventList(0 To UBound(EventList) + 1)
    End If
    
    'CALL AddEventListener IN EventListenerItem. THIS IS KEPT IN
    EventList(UBound(EventList)).AddEventListener control, Me
End Sub

'ADD EVENT Listener TO ALL CONTROLS INCLUDING THE FORM
Public Sub AddEventListenerAll(ByRef form As Object)
    AddEventListener form
    
    Dim control As MSForms.control
    For Each control In form.Controls
        AddEventListener control
    Next control
End Sub

Private Function IsArrayEmpty(arr As Variant) As Boolean
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' CPEARSON: http://www.cpearson.com/excel/VBAArrays.htm
    ' This function tests whether the array is empty (unallocated). Returns TRUE or FALSE.
    '
    ' The VBA IsArray function indicates whether a variable is an array, but it does not
    ' distinguish between allocated and unallocated arrays. It will return TRUE for both
    ' allocated and unallocated arrays. This function tests whether the array has actually
    ' been allocated.
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

    err.clear
    On Error Resume Next
    If IsArray(arr) = False Then
        ' we weren't passed an array, return True
        IsArrayEmpty = True
    End If

    ' Attempt to get the UBound of the array. If the array is
    ' unallocated, an error will occur.
    Dim ub As Long
    ub = UBound(arr, 1)
    If (err.Number <> 0) Then
        IsArrayEmpty = True
    Else
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' On rare occasion, under circumstances I cannot reliably replicate, Err.Number
        ' will be 0 for an unallocated, empty array. On these occasions, LBound is 0 and
        ' UBound is -1. To accommodate the weird behavior, test to see if LB > UB.
        ' If so, the array is not allocated.
        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        err.clear
        Dim LB As Long
        LB = LBound(arr)
        If LB > ub Then
            IsArrayEmpty = True
        Else
            IsArrayEmpty = False
        End If
    End If
End Function


'EventListenerItem	2

Rem Developer Robert Todar

Option Explicit
Option Compare Text

'SET FROM AddEventListener - NEEDED TO EMIT EVENT BACK TO IT.
Private WithEvents Emitter As EventListenerEmitter

'CONTROLS THAT HAVE THE EVENTS
Private WithEvents form As MSForms.UserForm
Private WithEvents Textbox As MSForms.Textbox
Private WithEvents label As MSForms.label
Private WithEvents CommandButton As MSForms.CommandButton
Private WithEvents ComboBox As MSForms.ComboBox
Private WithEvents Frame As MSForms.Frame

Private Type State
    control As Object
    IsHoveredControl As Boolean
    IsFocusedControl As Boolean
End Type

Private this As State


'TODO
' - ADD EVENTS FOR ALL USERFORM CONTROLS
' - ADD MORE EVENTS THAN THE LIST BELOW
' - DOUBLE CHECK THAT EMITTS ARE ALL CURRENT

'CURRENT EVENTS (WILL ADD MORE AS I HAVE NEED)
' - MouseOver
' - MouseOut
' - MouseMove
' - Click
' - DblClick
' - Focus
' - Blur
' - KeyUp
' - KeyDown

' The Only public method. This will be called from EventListenerEmitter class module
Public Sub AddEventListener(ByRef ControlOrForm As Object, ByRef EmitterReference As EventListenerEmitter)
    ' Capture the emitter class. This will be used to emit events from each control.
    Set Emitter = EmitterReference
    
    ' This is used to compare and check to see if this is the control triggering the event.
    Set this.control = ControlOrForm
    
    ' Set control (or form) based on its type
    Select Case TypeName(ControlOrForm)
        Case "CommandButton"
            Set CommandButton = ControlOrForm
        
        Case "ComboBox"
            Set ComboBox = ControlOrForm
            
        Case "Frame"
            Set Frame = ControlOrForm
        
        Case "Label"
            Set label = ControlOrForm
        
        Case "TextBox"
            Set Textbox = ControlOrForm
            
        Case Else
 
            If TypeOf ControlOrForm Is MSForms.UserForm Then
                Set form = ControlOrForm
            Else
                Rem todo
                Rem err.Raise 5, TypeName(Me), "Invalid control: Currently unable to listen to events on " & TypeName(ControlOrForm)
            End If

    End Select
End Sub

'***********************************************************************************
' Helper functions
'***********************************************************************************

' Called on mousemove event. This is a way of creating a mouseover and mouseout event.
Private Sub CheckIfHoveredControl()
    If Not this.IsHoveredControl Then
        this.IsHoveredControl = True
        Emitter.EmitEvent this.control, MouseOver
    End If
End Sub

' Called on mousemove event. This is a way of creating a mouseover and mouseout event.
Private Sub CheckIfFocusedControl()
    If Not this.IsFocusedControl Then
        If TypeName(this.control) = "Frame" Then
            Emitter.SetFocusToControl this.control.ActiveControl
        Else
            this.IsFocusedControl = True
            Emitter.EmitEvent this.control, Focus
        End If
    End If
End Sub

' Simple Collection factory  for ease of use.
Private Function ToCollection(ParamArray keyValuePairs() As Variant) As Collection
    ' Check to see if there is even number of parameters
    Dim ArrayLenght As Long
    ArrayLenght = UBound(keyValuePairs) - LBound(keyValuePairs) + 1
    
    If ArrayLenght Mod 2 <> 0 Then
        err.Raise 5, TypeName(Me), "Invalid parameters: expecting key/value pairs, but received an odd number of arguments."
    End If
    
    Set ToCollection = New Collection
    Dim index As Long
    For index = LBound(keyValuePairs) To UBound(keyValuePairs) Step 2
        ToCollection.Add keyValuePairs(index + 1), keyValuePairs(index)
    Next index
End Function

'***********************************************************************************
' EVENTS
'***********************************************************************************

' ONCE AN EVENT HAS EMMITED, EACH EVENTListenerITEM WILL LISTEN FOR THAT EVENT
Private Sub Emitter_EmittedEvent(ByRef control As Object, ByVal EventName As EmittedEvent, ByRef EventParameters As Collection)
    ' CREATE A MOUSEOVER MOUSEOUT EVENTS
    Select Case EventName
    
        Case MouseOver
            If this.control.Name <> control.Name And this.IsHoveredControl Then
                this.IsHoveredControl = False
                Emitter.EmitEvent this.control, MouseOut
            End If
            
        Case Focus
            If this.control.Name <> control.Name And this.IsFocusedControl Then
                this.IsFocusedControl = False
                Emitter.EmitEvent this.control, Blur
            ElseIf this.control.Name = control.Name And this.IsFocusedControl = False Then
                this.IsFocusedControl = True
            End If
    
    End Select
End Sub

'------------------------------------------------------------------------
' USERFORM
'------------------------------------------------------------------------
Private Sub Form_Click()
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub Form_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Form_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Form_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Emitter.EmitEvent this.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Form_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

'------------------------------------------------------------------------
' COMMAND BUTTON
'------------------------------------------------------------------------
Private Sub CommandButton_Click()
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub CommandButton_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub CommandButton_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub CommandButton_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub CommandButton_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Emitter.EmitEvent this.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub CommandButton_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, KeyUp, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub CommandButton_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Emitter.EmitEvent this.control, KeyDown, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

'------------------------------------------------------------------------
' LABEL
'------------------------------------------------------------------------
Private Sub Label_Click()
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub Label_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Label_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Label_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Emitter.EmitEvent this.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Label_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

'------------------------------------------------------------------------
' Frame
'------------------------------------------------------------------------
Private Sub Frame_Click()
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub Frame_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Frame_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Frame_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfFocusedControl        'FRAME DOESN'T TAKE FOCUS BUT ACTIVE CONTROL IN FRAME DOES
    Emitter.EmitEvent this.control, MouseDown
End Sub

Private Sub Frame_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

'------------------------------------------------------------------------
' Textbox
'------------------------------------------------------------------------
Private Sub Textbox_Click()
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub Textbox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub Textbox_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Textbox_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, MouseUp, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Textbox_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Emitter.EmitEvent this.control, MouseDown, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub

Private Sub Textbox_KeyUp(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    CheckIfFocusedControl
    Emitter.EmitEvent this.control, KeyUp, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

Private Sub Textbox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Emitter.EmitEvent this.control, KeyDown, ToCollection("KeyCode", KeyCode, "Shift", Shift)
End Sub

'------------------------------------------------------------------------
' Combobox
'------------------------------------------------------------------------
Private Sub ComboBox_Click()
    Emitter.EmitEvent this.control, Click
End Sub

Private Sub ComboBox_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Emitter.EmitEvent this.control, DoubleClick, ToCollection("Cancel", Cancel)
End Sub

Private Sub ComboBox_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    CheckIfHoveredControl
    Emitter.EmitEvent this.control, MouseMove, ToCollection("Button", Button, "Shift", Shift, "X", X, "Y", Y)
End Sub


'Sheet8	100

Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    If Not Intersect(Target, Range("G1:AFK1")) Is Nothing Then openUValiationDropdown
End Sub


'Sheet9	100



'Sheet10	100



'uFormBuilder	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uFormBuilder
'* Created    : 06-10-2022 10:35
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private WithEvents Emitter As EventListenerEmitter

Const codecolumn = 4
Const nameRow = 2
Const firstControlColumn = 7
Dim newType As String

Sub Emitter_MouseOver(ByRef control As Object)
    memo.Caption = control.Tag
End Sub

Private Sub Label9_Click()
    uDEV.Show
End Sub

Private Sub UserForm_Initialize()

    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll Me
    
    Set UFSheet = ThisWorkbook.SHEETS("FormBuilder")
    PopulateUserforms
    ResizeControlColumns Me.ListUserforms
    Me.ListNewType.list = WorksheetFunction.Transpose(ThisWorkbook.SHEETS("FormBuilderEvents").Range("A1").CurrentRegion.RESIZE(1).Value)
    'If ListUserforms.ListCount > 0 Then ListUserforms.Selected(0) = True
End Sub

Private Sub placeholder_Click()
    
    Dim TargetWorkbook As Workbook
    Set TargetWorkbook = Workbooks(ListUserforms.list(ListUserforms.ListIndex, 1))
    If ListItems.ListIndex = -1 Then
        MsgBox "No item selected"
        Exit Sub
    End If
    If ListControls.list(ListControls.ListIndex) <> ListNewType.list(ListNewType.ListIndex) Then
        MsgBox "You are trying to add " & _
               left(ListNewAction.list(ListNewAction.ListIndex), InStr(1, ListNewAction.list(ListNewAction.ListIndex), "(") - 1) & _
               " from a " & ListNewType.list(ListNewType.ListIndex) & " to a " & ListControls.list(ListControls.ListIndex) & vbNewLine & _
               "Since new action may be unavailable for old control type," & vbNewLine & _
               "please <TRANSFORM> the old control type to the new type first"
        Exit Sub
    End If
    For i = 0 To ListItems.ListCount - 1
        If ListItems.SELECTED(i) = True Then
            addControlCode TargetWorkbook, _
                           ListUserforms.list(ListUserforms.ListIndex), _
                           ListItems.list(i), _
                           ListNewAction.list(ListNewAction.ListIndex), _
                           ""
            'addControlCode TargetWorkbook, _
            ListUserforms.List(ListUserforms.ListIndex), _
            ListItems.List(ListItems.ListIndex), _
            ListNewAction.List(ListNewAction.ListIndex), _
            ""
        End If
    Next

    UFSheet.Columns.Cells.WrapText = False
    
    If ListboxSelectedCount(ListItems) = 1 Then
        ListItems_Change
    Else
        Application.EnableEvents = False
        For i = 0 To ListItems.ListCount - 1
            ListItems.SELECTED(i) = i = 0
        Next
        Application.EnableEvents = True
    End If
    
    'ListOldAction.AddItem ListNewAction.List(ListNewAction.ListIndex)

End Sub

Private Sub RECREATE_Click()
    CreateUserForm Workbooks(ListUserforms.list(ListUserforms.ListIndex, 1))
End Sub

Private Sub transform_Click()
    If ListboxSelectedCount(ListItems) > 1 Then
        MsgBox "Can transform only one control at a time"
        Exit Sub
    End If
    If noemptyListindex = False Then
        MsgBox "Some listboxes have no selection"
        Exit Sub
    End If
    transformControl ListItems.list(ListItems.ListIndex)
End Sub

Sub transformControl(CtrName As String)
    Dim i As Long

    newType = ListNewType.list(ListNewType.ListIndex)
    
    'change control type
    Dim rng As Range
    Set rng = UFSheet.Range("G1", UFSheet.Cells(1, Columns.count).End(xlToLeft))
    Set rng = rng.OFFSET(nameRow - 1)
    Dim ctrCol As Long
    ctrCol = rng.Find(CtrName).Column
    UFSheet.Cells(1, ctrCol) = newType
    
    'set new action
    Dim newAction As String
    newAction = ListNewAction.list(ListNewAction.ListIndex)
    
    'set oldAction and newAction
    Dim oldAction As String
    oldAction = ListOldAction.list(ListOldAction.ListIndex)
    
    'replace code with new control action
    On Error Resume Next
    Set cell = UFSheet.Columns(codecolumn).Find(CtrName & oldAction)
    On Error GoTo 0
    cell.Value = Replace(cell.Value, oldAction, newAction)
    ListOldAction.list(ListOldAction.ListIndex) = newAction
    Reselect
    
End Sub

Sub Reselect()
    Dim i As Long
    'save userform and control selections
    Dim pickedUserform As Long
    pickedUserform = ListUserforms.ListIndex
    Dim pickedControl As String
    pickedControl = ListNewType.list(ListNewType.ListIndex)
    Dim pickedItem As String
    pickedItem = ListItems.list(ListItems.ListIndex)
    DeselectAll
    clearAll
    
    'reselect userform
    For i = 0 To ListUserforms.ListCount - 1
        If i = pickedUserform Then ListUserforms.SELECTED(i) = True
    Next i
    
    'reselect control type if more of same type exist
    For i = 0 To ListControls.ListCount - 1
        If ListControls.list(i) = pickedControl Then
            ListControls.SELECTED(i) = True
        End If
    Next i
    ' else select the new type
    'If ListControls.ListIndex = -1 Then
    For i = 0 To ListControls.ListCount - 1
        If ListControls.list(i) = newType Then
            ListControls.SELECTED(i) = True
        End If
    Next i
    'End If
    'ListItems.Selected(0) = True
    For i = 0 To ListItems.ListCount - 1
        If ListItems.list(i) = pickedItem Then
            ListItems.SELECTED(i) = True
        End If
    Next i
    
    If ListOldAction.ListCount > 0 Then ListOldAction.SELECTED(0) = True
End Sub

Sub DeselectAll()
    Dim ctr As control
    Dim LB As MSForms.ListBox
    For Each ctr In Me.Controls
        'Debug.Print ctr.Name
        If TypeName(ctr) = "ListBox" Then
            '            If ctr.Name <> "ListUserforms" Then
            Set LB = ctr
            If LB.ListCount <> 0 Then
                For i = 0 To LB.ListCount - 1
                    LB.SELECTED(i) = False
                Next i
            End If
            '            End If
        End If
    Next ctr
End Sub

Sub clearAll()
    Dim ctr As control
    Dim LB As MSForms.ListBox
    For Each ctr In Me.Controls
        'Debug.Print ctr.Name
        If TypeName(ctr) = "ListBox" Then
            Set LB = ctr
            If LB.Name <> "ListUserforms" And LB.Name <> "ListNewType" Then
                LB.clear
            End If
        End If
    Next ctr
End Sub

Private Sub deselect_Click()
    DeselectAll
    clearAll
End Sub

Private Sub export_Click()
    ExportSelectedForm
End Sub

Sub ExportSelectedForm()
    Dim pickedUserform As String
    If ListUserforms.ListIndex = -1 Then Exit Sub
    pickedUserform = ListUserforms.list(ListUserforms.ListIndex)
    ExportUserform Workbooks(ListUserforms.list(ListUserforms.ListIndex, 1)).VBProject.VBComponents(pickedUserform)

    clearAll
    DeselectAll
    'Reselect UserForm
    For i = 0 To ListUserforms.ListCount - 1
        If ListUserforms.list(i) = pickedUserform Then
            ListUserforms.SELECTED(i) = True
            Exit For
        End If
    Next i
    If ListControls.ListCount > 0 Then ListControls.SELECTED(0) = True
End Sub

Private Sub ListControls_Click()
    Me.ListOldAction.clear
    PopulateItems
    If ListboxSelectedCount(ListItems) > 0 Then _
                                       ListItems.SELECTED(0) = True
    If ListOldAction.ListCount > 0 Then ListOldAction.SELECTED(0) = True
    Dim i As Long
    For i = 0 To ListNewType.ListCount - 1
        If ListNewType.list(i) = ListControls.list(ListControls.ListIndex) Then
            ListNewType.SELECTED(i) = True
        End If
    Next
End Sub

Private Sub ListItems_Change()
    'populate old actions listbox with selected control's events that exist in userform code
    
    ListOldAction.clear
    
    If ListboxSelectedCount(ListItems) > 1 Then Exit Sub
    Dim cell As Range

    Dim nameStr As String
    nameStr = ListItems.list(ListItems.ListIndex)
    Dim actionStr As String
    Dim openPos As Integer
    Dim closePos As Integer
    Dim cellAddress As String
    On Error Resume Next
    Set cell = UFSheet.Columns(codecolumn).Find(nameStr & "_")        ' & oldCtrAction)
    Dim firstAddress As String
    firstAddress = cell.Address
    On Error GoTo 0
    Do While Not cell Is Nothing And cellAddress <> firstAddress
        openPos = InStr(1, cell, "_")        'InStr(1, cell, nameStr) '
        closePos = InStr(1, cell, ")")        'IIf(InStr(1, cell, ")") > 0, InStr(1, cell, ")"), 0)
        ListOldAction.AddItem Mid(cell, openPos, Abs(closePos - openPos) + 1)        ' cell,openpos +1 ...cell, ")")-1, 0)
        Set cell = UFSheet.Columns(codecolumn).FindNext(cell)        '(nameStr & "_") ' & oldCtrAction)
        cellAddress = cell.Address
    Loop
    If ListOldAction.ListCount > 0 Then ListOldAction.ListIndex = 0
End Sub

Private Sub ListNewType_Click()
    'populate new actions listbox with new type's available events
    Me.ListNewAction.clear
    Dim eventSHEET As Worksheet
    Set eventSHEET = ThisWorkbook.SHEETS("FormBuilderEvents")
    Dim rng As Range
    Set rng = eventSHEET.Range("A1").CurrentRegion.RESIZE(1)
    Dim cell As Range
    Dim col As Long
    col = rng.Find(ListNewType.list(ListNewType.ListIndex)).Column
    Dim row As Long
    row = 2
    Set rng = eventSHEET.Cells(row, col)
    Do While Not IsEmpty(eventSHEET.Cells(row, col))
        Set rng = Union(rng, eventSHEET.Cells(row, col))
        row = row + 1
    Loop
    ListNewAction.list = rng.Value
    '    For Each cell In rng
    '        Me.ListNewAction.AddItem cell
    '    Next
    '
    'if new type has same event as old type then select that
    If Me.ListOldAction.ListIndex <> -1 Then
        If Me.ListNewAction.ListCount = 0 Then Exit Sub
        For i = 0 To Me.ListNewAction.ListCount - 1
            If Me.ListNewAction.list(i) = Me.ListOldAction.list(Me.ListOldAction.ListIndex) Then
                Me.ListNewAction.SELECTED(i) = True
            Else
                Me.ListNewAction.SELECTED(i) = False
            End If
        Next i
    End If
    ListNewAction.ListIndex = 0
End Sub

Private Sub ListUserforms_Click()
    clearAll
    'ExportSelectedForm
    If ListUserforms.list(ListUserforms.ListIndex) = UFSheet.Range("B1").Value Then
        PopulateControls
    Else
        Me.ListControls.clear
    End If
    If ListControls.ListCount > 0 Then ListControls.SELECTED(0) = True
End Sub

Sub PopulateUserforms(Optional TargetWorkbook As Workbook)        '
    Dim Module As VBComponent
    Dim X, WorkbookOrAddin As Variant
    
    If TargetWorkbook Is Nothing Then
        On Error Resume Next
        For Each X In Array(Workbooks, AddIns)
            For Each WorkbookOrAddin In X
                If Not ProtectedVBProject(Workbooks(WorkbookOrAddin.Name)) Then
                    If err.Number = 0 Then
                        For Each Module In Workbooks(WorkbookOrAddin.Name).VBProject.VBComponents
                            If Module.Type = vbext_ct_MSForm Then
                                If Module.Name <> "TransFormer" Then
                                    Me.ListUserforms.AddItem
                                    ListUserforms.list(UBound(ListUserforms.list), 0) = Module.Name
                                    ListUserforms.list(UBound(ListUserforms.list), 1) = WorkbookOfModule(Module).Name
                                End If
                            End If
                        Next Module
                    End If
                End If
                err.clear
            Next
        Next
    
    Else
        For Each Module In TargetWorkbook.VBProject.VBComponents
            If Module.Type = vbext_ct_MSForm Then
                If Module.Name <> "TransFormer" Then
                    Me.ListUserforms.AddItem
                    ListUserforms.list(UBound(ListUserforms.list), 0) = Module.Name
                    ListUserforms.list(UBound(ListUserforms.list), 1) = WorkbookOfModule(Module).Name
                End If
            End If
        Next Module
    End If
End Sub

Sub PopulateControls()

    Me.ListControls.clear

    Dim cell As Range
    Dim rng As Range
    Set rng = UFSheet.Range("G1")
    Dim col As Long
    col = firstControlColumn
    
    'get range with controls
    Do While Not IsEmpty(UFSheet.Cells(1, col))
        Set rng = Union(rng, UFSheet.Cells(1, col))
        col = col + 1
    Loop
    
    'use collection to get unique list because it skips existing keys
    Dim coll As Collection
    Set coll = New Collection

    On Error Resume Next
    For Each cell In rng
        coll.Add cell.TEXT, cell.TEXT
    Next
    On Error GoTo 0
    
    'populate controls listbox
    Dim element As Variant
    For Each element In coll
        Me.ListControls.AddItem element
    Next element
End Sub

Sub PopulateItems()
    Me.ListItems.clear
    Dim col As Long
    col = firstControlColumn

    Do While Not IsEmpty(UFSheet.Cells(1, col))
        If UFSheet.Cells(1, col) = Me.ListControls.list(ListControls.ListIndex) Then
            Me.ListItems.AddItem UFSheet.Cells(nameRow, col)
        End If
        col = col + 1
    Loop
End Sub

Function noemptyListindex() As Boolean
    Dim lbcount As Long
    Dim counter As Long
    Dim ctr As control
    Dim LB As MSForms.ListBox
    For Each ctr In Me.Controls
        'Debug.Print ctr.Name
        If TypeName(ctr) = "ListBox" Then
            lbcount = lbcount + 1
            Set LB = ctr
            If LB.ListIndex <> -1 Then
                counter = counter + 1
            End If
        End If
    Next ctr
    If counter = lbcount Then noemptyListindex = True
End Function

'obsolete
'
'Sub ExportTargetUserform(ufName As String)
'    Dim uForm As Variant
'    Set uForm = UserForms.Add(ufName)
'    ExportUserform uForm
'
'End Sub


'''''''''''''''''''''




Function propertyExists(cell As Range) As Boolean
    Dim lookWhere As Range:     Set lookWhere = ThisWorkbook.SHEETS("FromBuilderProperites").rows(1)
    Dim cellHeader As Range:    Set cellHeader = ThisWorkbook.SHEETS("FormBuilder").Cells(1, cell.Column)
    Dim cellProperty As Range:  Set cellProperty = ThisWorkbook.SHEETS("FormBuilder").Cells(cell.row, "F")
    Dim rng As Range:                 Set rng = ThisWorkbook.SHEETS("FormBuilderProperites").Columns(lookWhere.Find(cellHeader).Column).Cells.SpecialCells(xlCellTypeConstants)
    Dim element As Range
    On Error Resume Next
    Set element = rng.Find(cellProperty)
    On Error GoTo 0
    propertyExists = Not element Is Nothing
End Function

Sub addControlCode(wb As Workbook, FormName As String, CtrName As String, action As String, Code As String)
    Dim uf As UserForm
    Set uf = UserForms.Add(FormName)
    Dim ufComp As VBComponent
    Set ufComp = wb.VBProject.VBComponents(FormName)
    Dim ctl As control
    Dim txt As String
    Dim str As String
    'str = "Rem vbArc"
    'If ufComp.CodeModule.CountOfLines = 0 Then ufComp.CodeModule.AddFromString (str)
    If ufComp.CodeModule.CountOfLines > 0 Then
        str = ufComp.CodeModule.Lines(1, ufComp.CodeModule.CountOfLines)
    End If
    If InStr(1, str, CtrName & action) > 0 Then Exit Sub
    txt = "Sub " & CtrName & action & _
          vbNewLine & _
          Code & _
          vbNewLine & _
          "End Sub"
    Dim var As Variant
             
    var = Split(txt, vbNewLine)
    UFSheet.Cells(Columns.count, 4).End(xlUp).OFFSET(1).RESIZE(Len(txt) - Len(Replace(txt, vbNewLine, "")) - 1).Value = WorksheetFunction.Transpose(var)

    'ufComp.CodeModule.InsertLines ufComp.CodeModule.CountOfLines + 1, txt

End Sub



'F_References	1

Option Explicit
Rem @Folder ReferencesUserform Declarations
Private Const HKEY_CLASSES_ROOT As Long = &H80000000
Private Const READ_CONTROL As Long = &H20000
Private Const STANDARD_RIGHTS_READ As Long = (READ_CONTROL)
Private Const KEY_QUERY_VALUE As Long = &H1
Private Const KEY_ENUMERATE_SUB_KEYS As Long = &H8
Private Const KEY_NOTIFY As Long = &H10
Private Const SYNCHRONIZE As Long = &H100000
Private Const KEY_READ As Long = (( _
STANDARD_RIGHTS_READ _
Or KEY_QUERY_VALUE _
Or KEY_ENUMERATE_SUB_KEYS _
Or KEY_NOTIFY) _
And (Not SYNCHRONIZE))
Private Const ERROR_SUCCESS As Long = 0&
Private Const ERROR_NO_MORE_ITEMS As Long = 259&
Private Declare PtrSafe Function RegOpenKeyEx _
Lib "advapi32.dll" Alias "RegOpenKeyExA" ( _
ByVal HKEY As Long, _
ByVal lpSubKey As String, _
ByVal ulOptions As Long, _
ByVal samDesired As Long, _
ByRef phkResult As Long) As Long
Private Declare PtrSafe Function RegEnumKey _
Lib "advapi32.dll" Alias "RegEnumKeyA" ( _
ByVal HKEY As Long, _
ByVal dwIndex As Long, _
ByVal lpName As String, _
ByVal cbName As Long) As Long
Private Declare PtrSafe Function RegQueryValue _
Lib "advapi32.dll" Alias "RegQueryValueA" ( _
ByVal HKEY As Long, _
ByVal lpSubKey As String, _
ByVal lpValue As String, _
ByRef lpcbValue As Long) As Long
Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" (ByVal HKEY As Long) As Long

Rem @Folder ReferencesUserform
Private Sub RefList()
    '#INCLUDE CreateOrSetSheet
    Dim R1 As Long
    Dim R2 As Long
    Dim hHK1 As Long
    Dim hHK2 As Long
    Dim hHK3 As Long
    Dim hHK4 As Long
    Dim i As Long
    Dim i2 As Long
    Dim lpPath As String
    Dim lpGUID As String
    Dim lpName As String
    Dim lpValue As String
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("References", ThisWorkbook)
    ws.Cells.clear
    ws.Cells(1, 1).Value = "Reference Description"
    ws.Cells(1, 2).Value = "GUID"
    ws.Cells(1, 3).Value = "Path"
    ws.Cells(1, 4).Value = "Version"
    lpPath = String$(128, vbNullChar)
    lpValue = String$(128, vbNullChar)
    lpName = String$(128, vbNullChar)
    lpGUID = String$(128, vbNullChar)
    R1 = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", ByVal 0&, KEY_READ, hHK1)
    If R1 = ERROR_SUCCESS Then
        i = 1
        Do While Not R1 = ERROR_NO_MORE_ITEMS
            R1 = RegEnumKey(hHK1, i, lpGUID, Len(lpGUID))
            If R1 = ERROR_SUCCESS Then
                R2 = RegOpenKeyEx(hHK1, lpGUID, ByVal 0&, KEY_READ, hHK2)
                If R2 = ERROR_SUCCESS Then
                    i2 = 0
                    Do While Not R2 = ERROR_NO_MORE_ITEMS
                        R2 = RegEnumKey(hHK2, i2, lpName, Len(lpName))
                        If R2 = ERROR_SUCCESS Then
                            RegQueryValue hHK2, lpName, lpValue, Len(lpValue)
                            RegOpenKeyEx hHK2, lpName, ByVal 0&, KEY_READ, hHK3
                            RegOpenKeyEx hHK3, "0", ByVal 0&, KEY_READ, hHK4
                            RegQueryValue hHK4, "win32", lpPath, Len(lpPath)
                            i2 = i2 + 1
                            ws.Cells(i + 1, 1) = lpValue
                            ws.Cells(i + 1, 2) = lpGUID
                            ws.Cells(i + 1, 3) = lpPath
                            ws.Cells(i + 1, 4) = lpName
                        End If
                    Loop
                End If
            End If
            i = i + 1
        Loop
        RegCloseKey hHK1
        RegCloseKey hHK2
        RegCloseKey hHK3
        RegCloseKey hHK4
    End If
    Rem   ws.Columns("A:A").EntireColumn.AutoFit
    Rem   ws.Columns("B:C").ColumnWidth = 70
    ws.Range("A1").CurrentRegion.Sort Key1:=Range("A1"), header:=xlYes
End Sub

Sub ListAllReferences()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("References")
    ws.Cells(1, 1).Value = "Reference Description"
    ws.Cells(1, 2).Value = "GUID"
    ws.Cells(1, 3).Value = "Path"
    ws.Cells(1, 4).Value = "Version"
    Dim myRef As Reference
    Dim refs As VBIDE.REFERENCES
    Set refs = Application.VBE.ActiveVBProject.REFERENCES
    Dim i As Long
    i = 2
    For Each myRef In refs
        ws.Cells(i, 1) = IIf(myRef.Description <> "", myRef.Description, myRef.Name)
        ws.Cells(i, 2) = myRef.GUID
        ws.Cells(i, 3) = myRef.fullPath
        ws.Cells(i, 4) = myRef.Major & "." & myRef.Minor
        i = i + 1
    Next myRef
End Sub

Sub xlfVBEAddReferences()
    Dim oRefs As REFERENCES
    Set oRefs = Application.VBE.ActiveVBProject.REFERENCES
    On Error GoTo OnError
    oRefs.AddFromFile "C:\Windows\System32\msxml6.dll"
OnError:
End Sub

Sub xlfVBEAddReferencesGUID()
    Dim oRefs As REFERENCES
    Set oRefs = Application.VBE.ActiveVBProject.REFERENCES
    On Error GoTo OnError
    Rem Syntax: AddFromGuid(Guid, Major, Minor)
    oRefs.AddFromGuid "{F5078F18-C551-11D3-89B9-0000F81FE221}", 6, 0
OnError:
End Sub

Sub xlfVBERemoveReference1()
    Dim oRef As Reference
    Dim oRefs As REFERENCES
    Set oRefs = Application.VBE.ActiveVBProject.REFERENCES
    For Each oRef In oRefs
        If oRef.Name = "MSXML2" Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub

Sub xlfVBERemoveReference2()
    Dim oRef As Reference
    Dim oRefs As REFERENCES
    Set oRefs = Application.VBE.ActiveVBProject.REFERENCES
    For Each oRef In oRefs
        If oRef.Description = "Microsoft XML, v6.0" Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub

Sub RemoveReferenceByGUID(TargetWorkbook As Workbook, refGUID As String)
    '#INCLUDE dp
    Dim oRefs As REFERENCES
    Set oRefs = TargetWorkbook.VBProject.REFERENCES
    Dim oRef As Reference
    For Each oRef In oRefs
        dp oRef.Name
        If oRef.GUID = refGUID Then
            oRefs.Remove oRef
            Exit For
        End If
    Next oRef
End Sub



'U_Finder	1


Rem @Folder Finder
Option Compare Text
Public Enum OPERATOR
    IS_LIKE
    IS_EQUAL
    NOT_EQUAL
    IS_CONTAINS
    NOT_CONTAINS
    STARTS_WITH
    ENDS_WITH
    GREATER_THAN
    GREATER_OR_EQUAL
    LESS_THAN
    LESS_OR_EQUAL
    IS_BETWEEN
    NOT_BETWEEN
End Enum

Function FindDateRange(rng As Range) As Range
    Dim CopyRange As Range
    Dim cell As Range
    For Each cell In rng
        If IsDate(cell) Then
            If CopyRange Is Nothing Then
                Set CopyRange = cell
            Else
                Set CopyRange = Union(CopyRange, cell)
            End If
        End If
    Next cell
    Set FindDateRange = CopyRange
End Function

Function FindNumericRange(rng As Range) As Range
    Dim StartTime
    StartTime = Now
    Dim CopyRange As Range
    Dim cell As Range
    For Each cell In rng
        If IsNumeric(cell) And Not IsDate(cell) Then
            If CopyRange Is Nothing Then
                Set CopyRange = cell
            Else
                Set CopyRange = Union(CopyRange, cell)
            End If
        End If
        Rem        If Now() - startTime > TimeSerial(0, 0, 10) Then Stop
    Next cell
    Set FindNumericRange = CopyRange
End Function

Function FindStringRange(rng As Range) As Range
    Dim CopyRange As Range
    Dim cell As Range
    For Each cell In rng
        If IsDate(cell) Then
            If CopyRange Is Nothing Then
                Set CopyRange = cell
            Else
                Set CopyRange = Union(CopyRange, cell)
            End If
        End If
    Next cell
    Set FindStringRange = CopyRange
End Function

Sub ListboxToRange(lBox As MSForms.ListBox, rng As Range)
    rng.RESIZE(lBox.ListCount, lBox.columnCount) = lBox.list
End Sub

Function ArrayColumn(arr As Variant, col As Long) As Variant
    ArrayColumn = WorksheetFunction.index(arr, 0, col)
End Function

Private Function SortCompare(one As Variant, two As Variant) As Boolean
    Select Case True
        Case Len(one) < Len(two)
            SortCompare = True
        Case Len(one) > Len(two)
            SortCompare = False
        Case Len(one) = Len(two)
            SortCompare = LCase$(one) < LCase$(two)
    End Select
End Function

Function FindIfGetRow(FirstValue, operation As OPERATOR, SecondValue, offsetRow As Integer, offsetColumn As Integer, _
                      Optional wb As Workbook, Optional ws As Worksheet, Optional delim As String = ",") As Collection
    '#INCLUDE ArrayToString
    '#INCLUDE compare
    If wb Is Nothing Then Set wb = ActiveWorkbook
    Dim output As New Collection
    Dim arr, element
    Dim str As String
    Dim c As Range
    Dim firstAddress As String
    If TypeName(ws) = "Nothing" Then
        For Each ws In wb.Worksheets
            With ws.Cells
                Set c = .Find(FirstValue, LookIn:=xlValues)
                If Not c Is Nothing Then
                    firstAddress = c.Address
                    Do
                        If compare(c.OFFSET(offsetRow, offsetColumn).Value, operation, SecondValue) = True Then
                            arr = ws.Range(ws.Cells(c.row, c.CurrentRegion.Column), ws.Cells(c.row, c.CurrentRegion.Column + c.CurrentRegion.Columns.count - 1)).Value
                            str = ArrayToString(arr, delim)
                            output.Add str
                            Debug.Print str
                        End If
                        Set c = .FindNext(c)
                    Loop While Not c Is Nothing And c.Address <> firstAddress
                End If
            End With
        Next
    Else
        With ws.Cells
            Set c = .Find(FirstValue, LookIn:=xlValues)
            If Not c Is Nothing Then
                firstAddress = c.Address
                Do
                    If compare(c.OFFSET(offsetRow, offsetColumn).Value, operation, SecondValue) = True Then
                        arr = ws.Range(ws.Cells(c.row, c.CurrentRegion.Column), ws.Cells(c.row, c.CurrentRegion.Column + c.CurrentRegion.Columns.count - 1)).Value
                        str = ArrayToString(arr, delim)
                        output.Add str
                        Debug.Print str
                    End If
                    Set c = .FindNext(c)
                Loop While Not c Is Nothing And c.Address <> firstAddress
            End If
        End With
    End If
    Set FindIfGetRow = output
End Function

Function FindAllGetRow(FirstValue, Optional wb As Workbook, Optional ws As Worksheet) As Collection
    '#INCLUDE dp
    '#INCLUDE ArrayToString
    If wb Is Nothing Then Set wb = ActiveWorkbook
    Dim output As New Collection
    Dim arr, element
    Dim str As String
    Dim c As Range
    Dim firstAddress As String
    If TypeName(ws) = "Nothing" Then
        For Each ws In wb.Worksheets
            With ws.Cells
                Set c = .Find(FirstValue, LookIn:=xlValues)
                If Not c Is Nothing Then
                    firstAddress = c.Address
                    Rem dp vbNewLine & ws.Name
                    Do
                        Rem dp c.Address
                        arr = ws.Range(ws.Cells(c.row, c.CurrentRegion.Column), ws.Cells(c.row, c.CurrentRegion.Column + c.CurrentRegion.Columns.count - 1)).Value
                        str = ArrayToString(arr)
                        Do While InStr(1, str, ",,") > 0
                            str = Replace(str, ",,", ",")
                        Loop
                        str = str
                        output.Add str
                        Debug.Print str
                        Set c = .FindNext(c)
                    Loop While Not c Is Nothing And c.Address <> firstAddress
                End If
            End With
        Next
    Else
        With ws.Cells
            Set c = .Find(FirstValue, LookIn:=xlValues)
            If Not c Is Nothing Then
                firstAddress = c.Address
                Do
                    arr = ws.Range(ws.Cells(c.row, c.CurrentRegion.Column), ws.Cells(c.row, c.CurrentRegion.Column + c.CurrentRegion.Columns.count - 1)).Value
                    str = ArrayToString(arr)
                    output.Add str
                    Debug.Print str
                    Set c = .FindNext(c)
                Loop While Not c Is Nothing And c.Address <> firstAddress
            End If
        End With
    End If
    Set FindAllGetRow = output
End Function

Function compare(inputValue, operation As OPERATOR, FirstComparison, Optional SecondComparison, Optional CaseSensitive As Boolean) As Boolean
    '#INCLUDE InStrExact
    If TypeName(inputValue) = "Range" Then inputValue = inputValue.Value
    Select Case TypeName(inputValue)
        Case "String()", "Variant", "Variant()", "Collection"
            MsgBox "Not able to proccess this case at the moment"
            Stop
    End Select
    If TypeName(inputValue) = "String" Then
        If CaseSensitive = True Then
            inputValue = UCase(inputValue)
            FirstComparison = UCase(FirstComparison)
            If Not IsMissing(SecondComparison) Then SecondComparison = UCase(SecondComparison)
        End If
    ElseIf IsDate(inputValue) Then
        inputValue = CDate(inputValue)
    ElseIf IsNumeric(inputValue) Then
        inputValue = CDbl(inputValue)
    End If
    If IsDate(FirstComparison) Then
        FirstComparison = CDate(FirstComparison)
        If Not IsMissing(SecondComparison) Then
            If IsDate(SecondComparison) Then SecondComparison = CDate(SecondComparison)
        End If
    ElseIf IsNumeric(FirstComparison) Then
        FirstComparison = CDbl(FirstComparison)
        If Not IsMissing(SecondComparison) Then
            If IsNumeric(SecondComparison) Then SecondComparison = CDbl(SecondComparison)
        End If
    End If
    If operation = OPERATOR.IS_LIKE Then
        If inputValue Like FirstComparison Then
            compare = True
        End If
    ElseIf operation = OPERATOR.IS_CONTAINS Then
        If InStrExact(1, CStr(inputValue), CStr(FirstComparison)) > 0 Then compare = True
    ElseIf operation = OPERATOR.NOT_CONTAINS Then
        If InStrExact(1, CStr(inputValue), CStr(FirstComparison)) = 0 Then compare = True
    ElseIf operation = OPERATOR.NOT_EQUAL Then
        If inputValue <> FirstComparison Then compare = True
    ElseIf operation = OPERATOR.STARTS_WITH Then
        If inputValue Like FirstComparison & "*" Then compare = True
    ElseIf operation = OPERATOR.ENDS_WITH Then
        If inputValue Like "*" & FirstComparison Then compare = True
    ElseIf operation = OPERATOR.IS_EQUAL Then
        If inputValue = FirstComparison Then compare = True
    ElseIf operation = OPERATOR.GREATER_THAN Then
        If inputValue > FirstComparison Then compare = True
    ElseIf operation = OPERATOR.GREATER_OR_EQUAL Then
        If inputValue >= FirstComparison Then compare = True
    ElseIf operation = OPERATOR.IS_BETWEEN Then
        If FirstComparison < inputValue And inputValue < SecondComparison Then compare = True
    ElseIf operation = OPERATOR.NOT_BETWEEN Then
        If Not (FirstComparison < inputValue And inputValue < SecondComparison) Then compare = True
    ElseIf operation = OPERATOR.LESS_THAN Then
        If inputValue < FirstComparison Then compare = True
    ElseIf operation = OPERATOR.LESS_OR_EQUAL Then
        If inputValue <= FirstComparison Then compare = True
    End If
End Function

Public Function RangeFindAll(ByRef SearchRange As Range, ByVal Value As Variant, Optional ByVal LookIn As XlFindLookIn = xlValues, Optional LookAt As XlLookAt = xlPart) As Range
    Dim FoundValues As Range, Found As Range, Prev As Range, Looper As Boolean: Looper = True
    Do While Looper
        If Not Prev Is Nothing Then Set Found = SearchRange.Find(Value, Prev, LookIn, LookAt)
        If Found Is Nothing Then Set Found = SearchRange.Find(Value, LookIn:=LookIn, LookAt:=LookAt)
        If Not Found Is Nothing Then
            If FoundValues Is Nothing Then
                Set FoundValues = Found
            Else
                If Not Intersect(Found, FoundValues) Is Nothing Then Looper = False
                Set FoundValues = Union(FoundValues, Found)
            End If
            Set Prev = Found
        End If
        If Found Is Nothing And Prev Is Nothing Then Exit Function
    Loop
    Set RangeFindAll = FoundValues
    Set FoundValues = Nothing
    Set Found = Nothing
    Set Prev = Nothing
End Function



'uFinder	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uFinder
'* Created    : 06-10-2022 10:35
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Dim moResizer As New CFormResizer

Private Sub clear_Click()
    IS_LIKE.Value = True
    FirstComp.TEXT = "*"
    SecondComp.TEXT = ""
    FindThis.TEXT = ""
    offR.TEXT = 0
    offC.TEXT = 0
    ListBox1.clear
    TextBox3.TEXT = ""
    FindThis.SetFocus
End Sub

Private Sub cLookAtRow_Click()
    TrySearch
End Sub

Private Sub HideEmptyColumns_Click()
    TrySearch
End Sub

Private Sub Image1_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub ListBox1_Change()

    DoEvents
    If FindThis = "" Then Exit Sub
    Dim s As String
    s = ListBox1.list(Listbox_Selected(ListBox1, 2), 3)
    TextBox3.Value = s
    
    '
    '    Dim sStart As Long
    '    sStart = InStr(1, UCase(s), UCase(Replace(FindThis.Value, "ò", "Ó"))) - 1
    '    Dim sLen As Long
    '    sLen = Len(FindThis.Value)
    '    On Error GoTo EH
    '    If TextBox3 <> "" Then
    '        With TextBox3
    '            .SelStart = sStart
    '            .SelLength = sLen
    '            .SetFocus
    '        End With
    '    End If
    'EH:
End Sub

Private Sub FirstComp_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = 13 Then
        CommandButton1_Click
        DoEvents
        ListBox1.ListIndex = 0
    End If
End Sub

Private Sub oCurrentRegion_Click()
    TrySearch
End Sub

Private Sub oUsedRange_Click()
    TrySearch
End Sub

Private Sub oVBLF_Click()
    TrySearch
End Sub

Private Sub SecondComp_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = 13 Then
        CommandButton1_Click
        DoEvents
        ListBox1.ListIndex = 0
    End If
End Sub

Private Sub SpinButton1_Change()
    offC.Value = SpinButton1.Value
End Sub

Private Sub SpinButton2_Change()
    offR.Value = SpinButton2.Value
End Sub

Private Sub UserForm_Activate()
    Set moResizer.form = Me
    CreateListboxHeader ListBox1, ListBox2, Array("BOOK", "SHEEET", "RANGE", "ROW", "FORMULA")
    FindThis.SetFocus
    '    on eror resume next
    FindThis.SelStart = 0
    FindThis.SelLength = Len(FindThis.TEXT)
End Sub

Private Sub UserForm_Initialize()
    LoadUserformOptions Me, Array("listbox1", "listbox2", "textbox3")
    AddMinimizeButtonToUserform Me
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    SaveUserformOptions Me
End Sub

Private Sub UserForm_Resize()
    On Error Resume Next
    moResizer.FormResize
End Sub

Private Sub FindThis_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = 13 Then
        CommandButton1_Click
        DoEvents
        ListBox1.ListIndex = 0
    End If
End Sub

Sub ContainsFilter(ws As Worksheet)
    Filtered.Caption = ""
    If ws.FilterMode = True Then Filtered.Caption = "Some data is filtered"
End Sub

Private Sub CommandButton1_Click()
    TrySearch
End Sub

Function GetSearchRange(ByRef RangeOrSheet) As Range
    Dim rng As Range
    If TypeName(RangeOrSheet) = "Range" Then
        If IsDate(FirstComp.Value) Then
            Set rng = FindDateRange(RangeOrSheet.parent.Range(RangeOrSheet.Address))
        ElseIf IsNumeric(FirstComp.Value) Then
            Set rng = FindNumericRange(RangeOrSheet.parent.Range(RangeOrSheet.Address))
        Else
            Set rng = RangeFindAll(RangeOrSheet.parent.Range(RangeOrSheet.Address), FindThis)
        End If
    Else
        If IsDate(FirstComp.Value) Then
            '            Set rng = FindDateRange(RangeOrSheet.UsedRange)
            Set rng = FindDateRange(Union(RangeOrSheet.Columns(FindThis), RangeOrSheet.UsedRange))
        ElseIf IsNumeric(FirstComp.Value) Then
            '            Set rng = FindNumericRange(RangeOrSheet.UsedRange)
            Set rng = FindDateRange(Union(RangeOrSheet.Columns(FindThis), RangeOrSheet.UsedRange))
        Else
            Set rng = RangeFindAll(RangeOrSheet.UsedRange, FindThis)
        End If
    End If
    Set GetSearchRange = rng
End Function

Sub TrySearch()
    If IsNumeric(FindThis.Value) Then
        '        Select Case FirstComp.Text
        '        Case "", "*"
        '            FirstComp.Text = FindThis.Text
        '        End Select
    ElseIf FirstComp.TEXT = "" Then
        FirstComp.TEXT = "*"
    End If
    
    Dim op As OPERATOR
    op = WhichOperator(Frame2)

    Dim TargetWorkbook As Workbook
    Dim TargetWorkSheet As Worksheet
    Dim element As Variant
    Dim str As String
    Dim rng As Range
    Dim cell As Range
    Dim i As Long
    Dim varCompare
    Dim varRange()
    ReDim Preserve varRange(1 To ListBox1.columnCount, 1 To 1)
    
    Dim firstCell As Range
    
    Select Case whichOption(Frame1, "OptionButton").Caption
    
        Case Is = "Selection"
            ContainsFilter Selection.parent
            If TypeName(Selection) <> "Range" Then
                MsgBox "Under current options, please select a Range."
                Exit Sub
            End If

            Set rng = GetSearchRange(Selection)
            
            Dim s As String
            If Not rng Is Nothing Then
                
                For Each cell In rng
                    testMatch cell, i, varRange, op
                Next
            End If
    
        Case Is = "Active Sheet"
            ContainsFilter ActiveSheet
            Set TargetWorkSheet = ActiveSheet
            
            Set rng = GetSearchRange(TargetWorkSheet)
            
            If Not rng Is Nothing Then
                For Each cell In rng
                    If IsEmpty(varRange(1, UBound(varRange, 2))) Then
                        testMatch cell, i, varRange, op
                    Else
                        If cell.row <> Split(varRange(3, UBound(varRange, 2)), "$")(2) Then
                            testMatch cell, i, varRange, op
                        End If
                    End If
                Next
            End If
        Case Is = "Active Book"
            Set TargetWorkbook = ActiveWorkbook
            For Each TargetWorkSheet In TargetWorkbook.Worksheets
                ContainsFilter TargetWorkSheet
                '                Set rng = RangeFindAll(TargetWorkSheet.UsedRange, FindThis)
                Set rng = GetSearchRange(TargetWorkSheet)
                If Not rng Is Nothing Then
                    For Each cell In rng
                        If IsEmpty(varRange(1, UBound(varRange, 2))) Then
                            testMatch cell, i, varRange, op
                        Else
                            If cell.row <> Split(varRange(3, UBound(varRange, 2)), "$")(2) Then
                                testMatch cell, i, varRange, op
                            End If
                        End If
                    Next
                End If
            Next
        Case Is = "All Books"
            For Each TargetWorkbook In Workbooks
                For Each TargetWorkSheet In TargetWorkbook.Worksheets
                    ContainsFilter TargetWorkSheet
                    '                    Set rng = RangeFindAll(TargetWorkSheet.UsedRange, FindThis)
                    Set rng = GetSearchRange(TargetWorkSheet)
                    If Not rng Is Nothing Then
                        For Each cell In rng
                            If IsEmpty(varRange(1, UBound(varRange, 2))) Then
                                testMatch cell, i, varRange, op
                            Else
                                If cell.row <> Split(varRange(3, UBound(varRange, 2)), "$")(2) Then
                                    testMatch cell, i, varRange, op
                                End If
                            End If
                        Next
                    End If
                Next
            Next
    End Select
    
    ListBox1.list = Transpose2DArray(varRange)
    Rem ResizeControlColumns ListBox1, False
    '        ResizeUserformToFitControls Me
    '    var = Split(ListBox1.ColumnWidths, ";")
    '    ListBox1.ColumnWidths = Join(Array(var(0), var(1), var(2)), ";") & ";1500"

End Sub

Function testMatch(ByRef cell As Range, ByRef i As Long, ByRef varRange As Variant, op As OPERATOR) As Boolean
    'On Error GoTo hell
    Dim del As String
    Dim dupdel As String
    del = IIf(oVBLF.Value = True, vbNewLine, "|")
    dupdel = IIf(oVBLF.Value = True, vbNewLine & vbNewLine, "||")
    
    s = RangeToString(CellRow(cell), del)
    If HideEmptyColumns = True Then
        Do While InStr(1, s, dupdel) > 0
            s = Replace(s, dupdel, del)
        Loop
    End If
    
    If cLookAtRow.Value = True Then
        If InStr(1, UCase(s), UCase(FirstComp.Value)) > 0 Then Exit Function
    Else
        If compare(cell.OFFSET(CInt(offR), CInt(offC)).Value, op, _
                   IIf(FirstComp = "", FindThis.Value, FirstComp.Value), _
                   IIf(SecondComp = "", FirstComp.Value, SecondComp.Value)) = False _
                                                                              Then Exit Function
    End If
    
    i = i + 1
    ReDim Preserve varRange(1 To ListBox1.columnCount, 1 To i)
    varRange(1, i) = cell.parent.parent.Name
    varRange(2, i) = cell.parent.Name
    varRange(3, i) = cell.Address
    varRange(4, i) = s
    varRange(5, i) = IIf(cell.HasFormula, cell.Formula, "")
    testMatch = True
    If IsEmpty(varRange(1, i)) Then Exit Function
    'hell:
End Function

Function WhichOperator(Frame As MSForms.Frame) As OPERATOR
    Dim op As OPERATOR

    Select Case whichOption(Frame, "OptionButton").Name
        Case Is = "IS_LIKE"
            op = OPERATOR.IS_LIKE
        Case Is = "IS_EQUAL"
            op = OPERATOR.IS_EQUAL
        Case Is = "NOT_EQUAL"
            op = OPERATOR.NOT_EQUAL
        Case Is = "IS_CONTAINS"
            op = OPERATOR.IS_CONTAINS
        Case Is = "NOT_CONTAINS"
            op = OPERATOR.NOT_CONTAINS
        Case Is = "STARTS_WITH"
            op = OPERATOR.STARTS_WITH
        Case Is = ".ENDS_WITH"
            op = OPERATOR.ENDS_WITH
        Case Is = "GREATER_THAN"
            op = OPERATOR.GREATER_THAN
        Case Is = "GREATER_OR_EQUAL"
            op = OPERATOR.GREATER_OR_EQUAL
        Case Is = "LESS_THAN"
            op = OPERATOR.LESS_THAN
        Case Is = "LESS_OR_EQUAL"
            op = OPERATOR.LESS_OR_EQUAL
        Case Is = "IS_BETWEEN"
            op = OPERATOR.IS_BETWEEN
        Case Is = "NOT_BETWEEN"
            op = OPERATOR.NOT_BETWEEN
    End Select
    WhichOperator = op
End Function

Private Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim i As Long
    i = ListBox1.ListIndex
    Dim wb As Workbook
    Set wb = Workbooks(ListBox1.list(i, 0))
    Dim ws As Worksheet
    Set ws = wb.SHEETS(ListBox1.list(i, 1))
    Dim rng As Range
    Set rng = ws.Range(ListBox1.list(i, 2))
    ws.Activate
    rng.Select
End Sub

'
'Private Sub CommandButton1_Click()
'    If IsNumeric(FindThis.Value) Then
'        Select Case FirstComp.Text
'        Case "", "*"
'            FirstComp.Text = FindThis.Text
'        End Select
'    ElseIf FirstComp.Text = "" Then
'        FirstComp.Text = "*"
'    End If
'
'    Dim op As OPERATOR
'    op = WhichOperator(Frame2)
'
'    Dim TargetWorkbook As Workbook
'    Dim TargetWorkSheet As Worksheet
'    Dim element As Variant
'    Dim str As String
'    Dim rng As Range
'    Dim cell As Range
'    Dim i As Long
'    Dim varCompare
'    Dim varRange()
'    ReDim Preserve varRange(1 To ListBox1.ColumnCount, 1 To 1)
'
'    Select Case whichOption(Frame1, "OptionButton").Caption
'
'        Case Is = "Selection"
'            ContainsFilter Selection.Parent
'            If TypeName(Selection) <> "Range" Then
'                MsgBox "Under current options, please select a Range."
'                Exit Sub
'            End If
'
'
'            If IsDate(FirstComp.Value) Then
'                Set rng = FindDateRange(Selection) '(Selection.SpecialCells(xlCellTypeConstants))
'            ElseIf IsNumeric(FirstComp.Value) Then
'                Set rng = FindNumericRange(Selection) '(Selection.SpecialCells(xlCellTypeConstants))
'            Else
'                Set rng = RangeFindAll(Selection, FindThis) '(Selection.SpecialCells(xlCellTypeConstants), FindThis)
'            End If
'
'            Dim s As String
'            If Not rng Is Nothing Then
'                For Each cell In rng
'                    If compare(cell.Offset(CInt(offR), CInt(offC)).Value, op, IIf(FirstComp = "", FindThis.Value, FirstComp.Value), IIf(SecondComp = "", FirstComp.Value, SecondComp.Value)) = True Then
'                        i = i + 1
'                        ReDim Preserve varRange(1 To ListBox1.ColumnCount, 1 To i)
'                        varRange(1, i) = cell.Parent.Parent.Name
'                        varRange(2, i) = cell.Parent.Name
'                        varRange(3, i) = cell.Address
'                        s = RangeToString(CellRow(cell), "|")
'                        If HideEmptyColumns = True Then
'                            Do While InStr(1, s, "||") > 0
'                                s = Replace(s, "||", "|")
'                            Loop
'                        End If
'                        varRange(4, i) = s
'                        varRange(5, i) = IIf(cell.HasFormula, cell.Formula, "")
'                    End If
'                Next
'            End If
'
'        Case Is = "Active Sheet"
'            ContainsFilter ActiveSheet
'            Set TargetWorkSheet = ActiveSheet
'            If IsDate(FindThis.Value) Then
'                Set rng = FindDateRange(TargetWorkSheet.UsedRange)
'            ElseIf IsNumeric(FindThis.Value) Then
'                Set rng = FindNumericRange(TargetWorkSheet.UsedRange)
'            Else
'                Set rng = RangeFindAll(TargetWorkSheet.UsedRange, FindThis)
'            End If
'
'            If Not rng Is Nothing Then
'                For Each cell In rng
'                    If compare(cell.Offset(offR, offC).Value, op, IIf(FirstComp = "", FindThis.Value, FirstComp.Value), IIf(SecondComp = "", FirstComp.Value, SecondComp.Value)) = True Then
'                        i = i + 1
'                        ReDim Preserve varRange(1 To ListBox1.ColumnCount, 1 To i)
'                        varRange(1, i) = cell.Parent.Parent.Name
'                        varRange(2, i) = cell.Parent.Name
'                        varRange(3, i) = cell.Address
'                        s = RangeToString(CellRow(cell), "|")
'                        If HideEmptyColumns = True Then
'                            Do While InStr(1, s, "||") > 0
'                                s = Replace(s, "||", "|")
'                            Loop
'                        End If
'                        varRange(4, i) = s
'                        varRange(5, i) = IIf(cell.HasFormula, cell.Formula, "")
'                    End If
'                Next
'            End If
'        Case Is = "Active Book"
'            Set TargetWorkbook = ActiveWorkbook
'            For Each TargetWorkSheet In TargetWorkbook.Worksheets
'                ContainsFilter TargetWorkSheet
'                Set rng = RangeFindAll(TargetWorkSheet.UsedRange, FindThis)
'                If Not rng Is Nothing Then
'                    For Each cell In rng
'                        If compare(cell.Offset(offR, offC).Value, op, IIf(FirstComp = "", FindThis.Value, FirstComp.Value), IIf(SecondComp = "", FirstComp.Value, SecondComp.Value)) = True Then
'                            i = i + 1
'                            ReDim Preserve varRange(1 To ListBox1.ColumnCount, 1 To i)
'                            varRange(1, i) = cell.Parent.Parent.Name
'                            varRange(2, i) = cell.Parent.Name
'                            varRange(3, i) = cell.Address
'                            s = RangeToString(CellRow(cell), "|")
'                            If HideEmptyColumns = True Then
'                                Do While InStr(1, s, "||") > 0
'                                    s = Replace(s, "||", "|")
'                                Loop
'                            End If
'                            varRange(4, i) = s
'                            varRange(5, i) = IIf(cell.HasFormula, cell.Formula, "")
'                        End If
'                    Next
'                End If
'            Next
'        Case Is = "All Books"
'            For Each TargetWorkbook In Workbooks
'                For Each TargetWorkSheet In TargetWorkbook.Worksheets
'                ContainsFilter TargetWorkSheet
'                    Set rng = RangeFindAll(TargetWorkSheet.UsedRange, FindThis)
'                    If Not rng Is Nothing Then
'                        For Each cell In rng
'                            If compare(cell.Offset(offR, offC).Value, op, IIf(FirstComp = "", FindThis.Value, FirstComp.Value), IIf(SecondComp = "", FirstComp.Value, SecondComp.Value)) = True Then
'                                i = i + 1
'                                ReDim Preserve varRange(1 To ListBox1.ColumnCount, 1 To i)
'                                varRange(1, i) = cell.Parent.Parent.Name
'                                varRange(2, i) = cell.Parent.Name
'                                varRange(3, i) = cell.Address
'                                s = RangeToString(CellRow(cell), "|")
'                                If HideEmptyColumns = True Then
'                                    Do While InStr(1, s, "||") > 0
'                                        s = Replace(s, "||", "|")
'                                    Loop
'                                End If
'                                varRange(4, i) = s
'                                varRange(5, i) = IIf(cell.HasFormula, cell.Formula, "")
'                            End If
'                        Next
'                    End If
'                Next
'            Next
'    End Select
'
'    ListBox1.list = Transpose2DArray(varRange)
'    Rem ResizeControlColumns ListBox1, False
''        ResizeUserformToFitControls Me
''    var = Split(ListBox1.ColumnWidths, ";")
''    ListBox1.ColumnWidths = Join(Array(var(0), var(1), var(2)), ";") & ";1500"
'
'End Sub



'uFormNavigator	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uFormNavigator
'* Created    : 06-10-2022 10:35
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub CommandButton1_Click()
    ListBox1.ListIndex = -1
End Sub

Private Sub Image2_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub oActive_Click()
    LoadForms
End Sub

Private Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Dim FormName As String
    FormName = ListBox1.list(ListBox1.ListIndex)
    ShowUserform FormName
End Sub

Private Sub UserForm_Initialize()
    LoadForms
End Sub

Sub LoadForms()
    ListBox1.clear
    Dim wb As Workbook
    '    If oActive.Value = True Then
    Set wb = ActiveWorkbook
    '    Else
    '        Set wb = ThisWorkbook
    '    End If
    Dim vbComp As VBComponent
    For Each vbComp In wb.VBProject.VBComponents
        If vbComp.Type = vbext_ct_MSForm Then
            ListBox1.AddItem vbComp.Name
        End If
    Next
End Sub


'U_FormNavigator	1

Rem @Folder UserformNavigator
Sub FormopenCode(FormName As String, TargetWorkbook As Workbook)
    '#INCLUDE AddModule
    Dim Module As VBComponent
    Set Module = AddModule("vbArc", vbext_ct_StdModule, TargetWorkbook)
    Dim addText As String
    addText = "Sub open" & FormName & vbNewLine
    addText = addText & "On error resume next" & vbNewLine
    addText = addText & FormName & ".show" & vbNewLine
    addText = addText & "On error goto 0" & vbNewLine
    addText = addText & "End Sub"
    Module.CodeModule.InsertLines Module.CodeModule.CountOfLines + 1, addText
End Sub

Function AddModule(compName As String, compType As VBIDE.vbext_ComponentType, Optional TargetWorkbook As Workbook) As VBComponent
    '#INCLUDE ActiveCodepaneWorkbook
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim vbComp As VBComponent
    On Error Resume Next
    Set vbComp = TargetWorkbook.VBProject.VBComponents(compName)
    On Error GoTo 0
    If vbComp Is Nothing Then
        Set vbComp = TargetWorkbook.VBProject.VBComponents.Add(compType)
        vbComp.Name = compName
    End If
    Set AddModule = vbComp
End Function


'uSheetsNavigator	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uSheetsNavigator
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Sub SortListbox(oLb As MSForms.ListBox, sCol As Integer, sType As Integer, sDir As Integer)
    On Error GoTo eh
    Dim vaItems As Variant
    Dim i As Long, j As Long
    Dim c As Integer
    Dim vTemp As Variant
    vaItems = oLb.list
    If sType = 1 Then
        For i = LBound(vaItems, 1) To UBound(vaItems, 1) - 1
            For j = i + 1 To UBound(vaItems, 1)
                If sDir = 1 Then
                    If vaItems(i, sCol) > vaItems(j, sCol) Then
                        For c = 0 To oLb.columnCount - 1
                            vTemp = vaItems(i, c)
                            vaItems(i, c) = vaItems(j, c)
                            vaItems(j, c) = vTemp
                        Next c
                    End If
                ElseIf sDir = 2 Then
                    If vaItems(i, sCol) < vaItems(j, sCol) Then
                        For c = 0 To oLb.columnCount - 1
                            vTemp = vaItems(i, c)
                            vaItems(i, c) = vaItems(j, c)
                            vaItems(j, c) = vTemp
                        Next c
                    End If
                End If
            Next j
        Next i
    ElseIf sType = 2 Then
        For i = LBound(vaItems, 1) To UBound(vaItems, 1) - 1
            For j = i + 1 To UBound(vaItems, 1)
                If sDir = 1 Then
                    If CInt(vaItems(i, sCol)) > CInt(vaItems(j, sCol)) Then
                        For c = 0 To oLb.columnCount - 1
                            vTemp = vaItems(i, c)
                            vaItems(i, c) = vaItems(j, c)
                            vaItems(j, c) = vTemp
                        Next c
                    End If
                ElseIf sDir = 2 Then
                    If CInt(vaItems(i, sCol)) < CInt(vaItems(j, sCol)) Then
                        For c = 0 To oLb.columnCount - 1
                            vTemp = vaItems(i, c)
                            vaItems(i, c) = vaItems(j, c)
                            vaItems(j, c) = vTemp
                        Next c
                    End If
                End If
            Next j
        Next i
    End If
    oLb.list = vaItems
    Exit Sub
eh:
    LoadSheetBox
End Sub

Sub LoadSheetBox()
    SheetBox.clear
    Dim sh As Worksheet
    For Each sh In ActiveWorkbook.SHEETS
        If sh.visible = xlSheetVisible Then SheetBox.AddItem sh.Name
    Next
End Sub

Sub SortSheetBox()
    If Me.oDefault.Value = True Then
        Call LoadSheetBox
    Else
        Dim lBox As MSForms.ListBox
        Set lBox = Me.SheetBox
        Dim OnColumn As Integer
        OnColumn = 0
        Dim TextOrNumbers As Integer
        TextOrNumbers = 1
        Dim AscendingOrDescending As Integer
        AscendingOrDescending = IIf(Me.oAZ.Value = True, 1, 2)
        Call SortListbox(lBox, OnColumn, TextOrNumbers, AscendingOrDescending)
    End If
End Sub

Private Sub CommandButton1_Click()
    Dim ans As String
    ans = MsgBox("No undo." & vbNewLine & _
                 "You may only close the workbook without changes to restore original order." & vbNewLine & vbNewLine & "Proceed?", vbYesNo)
    If ans = vbNo Then Exit Sub
    Dim i As Long
    For i = 0 To SheetBox.ListCount - 1
        ActiveWorkbook.SHEETS(SheetBox.list(i)).Move Before:=SHEETS(i + 1)
    Next i
End Sub

Private Sub CommandButton5_Click()
    TextBox2.TEXT = ""
End Sub

Private Sub CommandButton6_Click()
    On Error Resume Next
    Dim note As String
    note = ActiveSheet.Name
    With TextBox1
        ActiveWorkbook.SHEETS(.TEXT).Activate
        .TEXT = note
    End With
End Sub

Private Sub CommandButton7_Click()
    LoadSheetBox
End Sub

Private Sub Image1_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub SheetBox_Click()
    TextBox1.TEXT = ActiveSheet.Name
    With SheetBox
        ActiveWorkbook.SHEETS(.list(.ListIndex)).Activate
    End With
End Sub

Private Sub oAZ_Click()
    SortSheetBox
End Sub

Private Sub oDefault_Click()
    SortSheetBox
End Sub

Private Sub oZA_Click()
    SortSheetBox
End Sub

Private Sub TextBox2_Change()
    LoadSheetBox
    For i = SheetBox.ListCount - 1 To 0 Step -1
        If InStr(1, LCase(SheetBox.list(i)), LCase(TextBox2.TEXT)) = 0 Then
            SheetBox.RemoveItem (i)
        End If
    Next
End Sub

Private Sub UserForm_Initialize()
    Call LoadUserformPosition
    TextBox1.TEXT = ActiveSheet.Name
    Call LoadSheetBox
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Call SaveUserformPosition
End Sub

Sub LoadUserformPosition()
    If GetSetting("My Settings Folder", Me.Name, "Left Position") = "" _
                                                                    And GetSetting("My Settings Folder", Me.Name, "Top Position") = "" Then
        Me.StartUpPosition = 1
    Else
        Me.left = GetSetting("My Settings Folder", Me.Name, "Left Position")
        Me.top = GetSetting("My Settings Folder", Me.Name, "Top Position")
    End If
End Sub

Sub SaveUserformPosition()
    SaveSetting "My Settings Folder", Me.Name, "Left Position", Me.left
    SaveSetting "My Settings Folder", Me.Name, "Top Position", Me.top
End Sub



'M_UserformMouse	1


Rem @Folder FormMouse
Option Explicit
Option Compare Text
Rem in userform:    ShowFormAtCursor me
Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Private Declare PtrSafe Function GetCursorPos Lib "user32" (p As tCursor) As Long
Public Declare PtrSafe Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
Public Declare PtrSafe Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
Public Declare PtrSafe Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hdc As Long) As Long
Private Declare PtrSafe Function ClientToScreen Lib "user32" (ByVal hWnd As Long, lpPoint As tCursor) As Long
Public Declare PtrSafe Function SetCursorPos Lib "user32" (ByVal X As Long, ByVal Y As Long) As Long
Public Const LOGPIXELSX = 88
Public Const LOGPIXELSY = 90
Public Type tCursor
    left As Long
    top As Long
End Type

Sub LeftClick()
    mouse_event MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0
    mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, 0
End Sub

Rem in userform activated event
Rem CenterMouseOver Me, ComboBox1
Public Sub CenterMouseOver(f As Object, c As Object)
    '#INCLUDE PointsPerPixelX
    '#INCLUDE PointsPerPixelY
    Dim p As tCursor
    Dim lngHwnd As Long
    lngHwnd = CLng(FindWindow(vbNullString, f.Caption))
    p.left = (c.left + (c.Width \ 2)) / PointsPerPixelX
    p.top = (c.top + (c.Height \ 2)) / PointsPerPixelY
    ClientToScreen lngHwnd, p
    SetCursorPos p.left, p.top
End Sub

Public Function PointsPerPixelX() As Double
    Dim hdc As Long
    hdc = GetDC(0)
    PointsPerPixelX = 72 / GetDeviceCaps(hdc, LOGPIXELSX)
    ReleaseDC 0, hdc
End Function

Public Function PointsPerPixelY() As Double
    Dim hdc As Long
    hdc = GetDC(0)
    PointsPerPixelY = 72 / GetDeviceCaps(hdc, LOGPIXELSY)
    ReleaseDC 0, hdc
End Function

Public Function WhereIsTheMouseAt() As tCursor
    Dim mPos As tCursor
    GetCursorPos mPos
    WhereIsTheMouseAt = mPos
End Function

Public Function convertMouseToForm() As tCursor
    '#INCLUDE PointsPerPixelX
    '#INCLUDE PointsPerPixelY
    '#INCLUDE WhereIsTheMouseAt
    Dim mPos As tCursor
    mPos = WhereIsTheMouseAt
    mPos.left = PointsPerPixelY * mPos.left
    mPos.top = PointsPerPixelX * mPos.top
    convertMouseToForm = mPos
End Function

Sub ShowFormAtCursor(form As Object)
    '#INCLUDE convertMouseToForm
    form.left = convertMouseToForm.left
    form.top = convertMouseToForm.top
End Sub


'uRangeControl	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uRangeControl
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Private seper As String

Private WithEvents Emitter As EventListenerEmitter

Private Sub CommandButton20_Click()
    If TypeName(Selection) <> "Range" Then Exit Sub
    
    Dim ans As Long
    ans = MsgBox("By column?", vbYesNoCancel)
    If ans = vbCancel Then Exit Sub
    
    Dim columnDataArray, rowDataArray
    Dim mergedData As String
    Dim firstCell As Range, columnRange As Range, rowRange As Range
    Dim columnCounter As Long, rowCounter
    Dim columnCell, rowCell
    Dim vArea
    For Each vArea In Selection.Areas
        If ans = vbYes Then
            For columnCounter = 1 To vArea.Columns.count
                mergedData = ""
                Set columnRange = vArea.Columns(columnCounter)
                columnDataArray = columnRange.Value
                columnRange.Cells.ClearContents
                For Each columnCell In columnDataArray
                    mergedData = IIf(mergedData = "", columnCell, mergedData & vbNewLine & columnCell)
                Next
                Set firstCell = vArea.Columns(columnCounter).Cells(1)
                firstCell.Value = mergedData
                firstCell.EntireRow.AutoFit
            Next
        Else
            For rowCounter = 1 To vArea.rows.count
                mergedData = ""
                Set rowRange = vArea.rows(rowCounter)
                rowDataArray = rowRange.Value
                rowRange.Cells.ClearContents
                For Each rowCell In rowDataArray
                    mergedData = IIf(mergedData = "", rowCell, mergedData & vbNewLine & rowCell)
                Next
                Set firstCell = vArea.rows(rowCounter).Cells(1)
                firstCell.Value = mergedData
                firstCell.EntireRow.AutoFit
            Next
        End If
    Next
End Sub

Private Sub CommandButton21_Click()
    Dim del As String
    Dim cell As Range, rng As Range
    Set rng = Application.InputBox(Prompt:="Select a range:", _
                                   title:="Sort values inside cells", _
                                   Default:=Selection.Address, Type:=8)
    del = InputBox(Prompt:="Delimiting character: (leave empty for newline)", _
                   title:="Sort values in a single cell")
    If del = "" Then del = vbNewLine
    For Each cell In rng
        RotateArray Split(cell.Value, del)
    Next
End Sub

Private Sub CommandButton22_Click()
    ShakeTableWand
End Sub

Private Sub CommandButton23_Click()
    AddReadmeToWorkbook
End Sub

Private Sub UserForm_Initialize()
    seper = vbNewLine
    Me.Width = 300
    Me.Height = 280
    Dim anc As MSForms.control

    For Each c In Me.Controls
        If TypeName(c) = "Frame" Then
            'c.Caption = ""
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                c.visible = False
                If InStr(1, c.Tag, "anchor") > 0 Then
                    On Error Resume Next
                    Set anc = Me.Controls("Anchor" & Mid(c.Tag, InStr(1, c.Tag, "Anchor", vbTextCompare) + Len("Anchor"), 2))
                    If anc Is Nothing Then Stop
                    On Error GoTo 0
                    c.top = anc.top        'Anchor01.Top
                    c.left = anc.left        ' Anchor01.Left
                    Set anc = Nothing
                End If
            End If
        End If
    Next
End Sub

Private Sub UserForm_Activate()
    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll Me
    
    CenterMouseOver Me, Label5
    LeftClick

    'ResizeUserformToFitControls Me

End Sub

Private Sub Emitter_LabelMouseOut(label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then
        If label.BackColor <> &H80B91E Then label.BackColor = &H534848
    End If
End Sub

Private Sub Emitter_LabelMouseOver(label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then
        If label.BackColor <> &H80B91E Then label.BackColor = &H808080
    End If
End Sub

Sub Emitter_LabelClick(ByRef label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then Reframe Me, label
End Sub

Private Sub cAddCol_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call Expand(0, 1)
End Sub

Private Sub cADDrow_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call Expand(1, 0)
End Sub

Private Sub cCenterAcross_Click()
    ConvertMergedCellsToCenterAcross
End Sub

Sub ConvertMergedCellsToCenterAcross()
    Dim c As Range
    Dim mergedRange As Range
    If TypeName(ActiveSheet) <> "Worksheet" Then Exit Sub
    For Each c In ActiveSheet.UsedRange.SpecialCells(xlCellTypeConstants)
        If c.MergeCells = True And c.MergeArea.rows.count = 1 Then
            Set mergedRange = c.MergeArea
            mergedRange.UnMerge
            mergedRange.HorizontalAlignment = xlCenterAcrossSelection
        End If
    Next
End Sub

Private Sub CommandButton1_Click()
    If oFirstblank.Value = True Then
        Call GoToBlankFirstInColumn
    ElseIf oLastblank.Value = True Then
        Call GoToBlankLastWithinColumn
    ElseIf oNextBlank.Value = True Then
        Call GoToBlankNext
    ElseIf oNewRow.Value = True Then
        Call GoToBlankAfterColumn
    End If
End Sub

Private Sub CommandButton10_Click()
    If TypeName(Selection) <> "Range" Then Exit Sub
    Dim cell As Range
    For Each cell In Selection
        cell.TEXT = GreekToLatin(cell.TEXT)
    Next
End Sub

Private Sub CommandButton11_Click()
    CircleBoxADD
End Sub

Private Sub CommandButton12_Click()
    CircleBoxREMOVE
End Sub

Private Sub CommandButton14_Click()
    RemoveArrows
End Sub

Private Sub CommandButton15_Click()
    If TypeName(Selection) <> "Range" Then Exit Sub
    If Selection.Areas.count <> 2 Then Exit Sub
    If Selection.Areas(1).Cells.count <> 1 Then Exit Sub
    If Selection.Areas(2).Cells.count <> 1 Then Exit Sub
    DrawArrows Selection.Areas(1).Cells, Selection.Areas(2).Cells, , Switch(oArrowDouble.Value = True, "DOUBLE", oArrowLine.Value = True, "LINE", oArrowSingle, "SINGLE")
End Sub

Private Sub CommandButton16_Click()
    HideShapes "myArrow"
End Sub

Private Sub CommandButton17_Click()
    ShowShapes "myArrow"
End Sub

Sub HideShapes(shapeName As String)
    For Each shp In ActiveSheet.Shapes
        If UCase(shp.Name) = UCase(shapeName) Then shp.visible = False
    Next shp
End Sub

Sub ShowShapes(shapeName As String)
    For Each shp In ActiveSheet.Shapes
        If UCase(shp.Name) = UCase(shapeName) Then shp.visible = True
    Next shp
End Sub

Private Sub CommandButton18_Click()
    HideShapes "myCircle"
End Sub

Private Sub CommandButton19_Click()
    ShowShapes "myCircle"
End Sub

Private Sub CommandButton2_Click()
    AddBorders
End Sub

Private Sub CommandButton3_Click()
    ClearBorders
End Sub

Private Sub CommandButton4_Click()
    If TypeName(Selection) <> "Range" Then Exit Sub
    Dim rng As Range, i As Long
    Set rng = Selection
    Dim areaCount As Long
    areaCount = rng.Areas.count
    For i = 1 To areaCount
        rng.Areas(i).HorizontalAlignment = xlCenterAcrossSelection
    Next
End Sub

Private Sub CommandButton5_Click()
    CopyWorksheetsIncludingTables
End Sub

Private Sub CommandButton6_Click()
    deleteBlankWorksheets
End Sub

Private Sub CommandButton7_Click()
    SortValuesInCell
End Sub

Private Sub CommandButton8_Click()
    getEmailCollection
End Sub

Private Sub CommandButton9_Click()
    If TypeName(Selection) <> "Range" Then Exit Sub
    Dim cell As Range
    For Each cell In Selection
        cell.Value = LatinToGreek(cell.TEXT)
    Next
End Sub

Private Sub cREMcol_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call Expand(0, -1)
End Sub

Private Sub cREMrow_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call Expand(-1, 0)
End Sub

Private Sub cFlipH_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    FlipHorizontally
End Sub

Private Sub cFlipV_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    FlipVertically
End Sub

Private Sub cSwap_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    SwapSelectedRanges
End Sub

'
'Private Sub cIup_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
'    MoveCell ("up")
'End Sub
'
'Private Sub cIdown_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
'    MoveCell ("down")
'End Sub
'
'Private Sub cIleft_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
'    MoveCell ("left")
'End Sub
'
'Private Sub cIright_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal Y As Single)
'    MoveCell ("right")
'End Sub

Private Sub cSup_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    MoveSelection ("up")
End Sub

Private Sub cSdown_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    MoveSelection ("down")
End Sub

Private Sub cSleft_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    MoveSelection ("left")
End Sub

Private Sub cSright_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    MoveSelection ("right")
End Sub

Private Sub cCopy_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    On Error GoTo eh
    Selection.Copy
eh:                     MsgBox "copy one area only"
End Sub

Private Sub Image2_BeforeDragOver(ByVal Cancel As MSForms.ReturnBoolean, ByVal Data As MSForms.DataObject, ByVal X As Single, ByVal Y As Single, ByVal DragState As MSForms.fmDragState, ByVal Effect As MSForms.ReturnEffect, ByVal Shift As Integer)
    uDEV.Show
End Sub

Private Sub Image3_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call MergeCustom
End Sub

Private Sub Image4_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call UnmergeCustom
End Sub

Private Sub Image5_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call SelectAllMergedCells
End Sub

Private Sub Image6_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If TypeName(Selection) <> "Range" Then
        MsgBox "Select a range"
        Exit Sub
    End If
    If oAppend.Value = False And oPretend.Value = False And oReplace.Value = False Then
        MsgBox "Select an option"
        Exit Sub
    End If
    Application.ScreenUpdating = False
    Dim str As String
    str = tString
    Dim cell As Range
    Dim rng As Range
    Set rng = Selection.SpecialCells(xlCellTypeVisible)
    If oReplace.Value = True Then
        If Selection.count = 1 Then
            ActiveCell.Value = str
        ElseIf Selection.count > 1 Then
            rng.Value = str
        End If
    ElseIf oPretend.Value = True Then
        For Each cell In rng
            cell.Value = str & cell.Value
        Next cell
    ElseIf oAppend.Value = True Then
        For Each cell In rng
            cell.Value = cell.Value & str
        Next cell
    End If
    Application.ScreenUpdating = True
End Sub

Private Sub tCol_Change()
    If tCol.TEXT = vbNullString Or Not IsNumeric(tCol.TEXT) Then tCol.TEXT = "1"
    If CInt(tCol.TEXT) <= 0 Then tCol.TEXT = "1"
    ResizeByTextbox 0, CInt(tCol.TEXT)
End Sub

Private Sub tMergeLink_Change()
    seper = IIf(tMergeLink.TEXT <> "", tMergeLink.TEXT, vbNewLine)
End Sub

Private Sub tRow_Change()
    If tRow.TEXT = vbNullString Or Not IsNumeric(tRow.TEXT) Then tRow.TEXT = "1"
    If CInt(tRow.TEXT) <= 0 Then tRow.TEXT = "1"
    ResizeByTextbox CInt(tRow.TEXT), 0
End Sub

Sub AddBorders()
    If chTop.Value = True Then Selection.BORDERS(xlEdgeTop).LineStyle = xlContinuous
    If chBottom.Value = True Then Selection.BORDERS(xlEdgeBottom).LineStyle = xlContinuous
    If chLeft.Value = True Then Selection.BORDERS(xlEdgeLeft).LineStyle = xlContinuous
    If chRight.Value = True Then Selection.BORDERS(xlEdgeRight).LineStyle = xlContinuous
    If chHorizontal.Value = True Then Selection.BORDERS(xlInsideHorizontal).LineStyle = xlContinuous
    If chVertical.Value = True Then Selection.BORDERS(xlInsideVertical).LineStyle = xlContinuous
End Sub

Sub ClearBorders()
    Dim myBorders() As Variant, item As Variant
    myBorders = Array(xlEdgeLeft, xlEdgeTop, xlEdgeBottom, xlEdgeRight, xlInsideVertical, xlInsideHorizontal, xlInsideVertical)
    For Each item In myBorders
        With Selection.BORDERS(item)
            .LineStyle = xlNone
        End With
    Next
End Sub

Sub getEmailCollection()
    Dim output As Collection
    Set output = New Collection
    Dim i As Long
    Dim str As String
    Dim rng As Range
    Set rng = Selection.SpecialCells(xlCellTypeVisible)
    Call ExtractEmailCollection(rng, output)
    For i = 1 To output.count
        If str = vbNullString Then
            str = output(i)
        Else
            str = str & vbNewLine & output(i)
        End If
    Next i
    CLIP str
    Set output = Nothing
    MsgBox "Copied to clipboard"
End Sub

Sub ExtractEmailCollection(rng As Range, output As Collection)
    Dim aEmails               As Variant
    Dim i                     As Long
    Dim cell As Range
    For Each cell In rng
        aEmails = ExtractEmailAddresses(cell.Value)
        If IsNull(aEmails) = False Then
            For i = 0 To UBound(aEmails)
                output.Add aEmails(i)
            Next i
        End If
    Next cell
End Sub

Public Function ExtractEmailAddresses(ByVal sInput As Variant) As Variant
    On Error GoTo Error_Handler
    Dim oRegEx                As Object
    Dim oMatches              As Object
    Dim oMatch                As Object
    Dim sEmail                As String
    If Not IsNull(sInput) Then
        Set oRegEx = CreateObject("vbscript.regexp")
        With oRegEx
            .Pattern = "([a-zA-ZF0-9\u00C0-\u017F._-]+@[a-zA-Z0-9\u00C0-\u017F._-]+\.[a-zA-Z0-9\u00C0-\u017F_-]+)"
            .Global = True
            .IgnoreCase = True
            .MultiLine = True
            Set oMatches = .Execute(sInput)
        End With
        For Each oMatch In oMatches
            sEmail = oMatch.Value & "," & sEmail
        Next oMatch
        If Right(sEmail, 1) = "," Then sEmail = left(sEmail, Len(sEmail) - 1)
        ExtractEmailAddresses = Split(sEmail, ",")
    Else
        ExtractEmailAddresses = Null
    End If
Error_Handler_Exit:
    On Error Resume Next
    If Not oMatch Is Nothing Then Set oMatch = Nothing
    If Not oMatches Is Nothing Then Set oMatches = Nothing
    If Not oRegEx Is Nothing Then Set oRegEx = Nothing
    Exit Function
Error_Handler:
    MsgBox "The following error has occured" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: ExtractEmailAddresses" & vbCrLf & _
           "Error Description: " & err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occured!"
    Resume Error_Handler_Exit
End Function

Sub SwapSelectedRanges()
    Dim rng As Range
    Dim tempRng As Variant
    Dim areaCount As Long
    Dim areaRows As Long
    Dim areaCols As Long
    Dim i As Integer
    Dim j As Integer
    Set rng = Selection
    areaCount = rng.Areas.count
    If areaCount < 2 Then
        MsgBox "Please select atleast two ranges."
        Exit Sub
    End If
    areaRows = rng.Areas(1).rows.count
    areaCols = rng.Areas(1).Columns.count
    For i = 2 To areaCount
        If rng.Areas(i).rows.count <> areaRows Or _
                                   rng.Areas(i).Columns.count <> areaCols Then
            MsgBox "All ranges must have the same number of rows and columns."
            Exit Sub
        End If
    Next i
    For j = 1 To areaCount - 1
        For i = 1 + j To areaCount
            If Not Intersect(rng.Areas(i), rng.Areas(j)) Is Nothing Then
                MsgBox "Selected areas must not overlap."
            End If
        Next i
    Next j
    tempRng = rng.Areas(areaCount).Cells.Formula
    For i = areaCount To 2 Step -1
        rng.Areas(i).Cells.Formula = rng.Areas(i - 1).Cells.Formula
    Next i
    rng.Areas(1).Cells.Formula = tempRng
End Sub

Sub FlipHorizontally()
    Dim rng As Range
    Dim WorkRng As Range
    Dim arr As Variant
    Dim i As Integer, j As Integer, k As Integer
    On Error Resume Next
    xTitleId = "Flip Data Horizontally"
    Set WorkRng = Application.Selection
    arr = WorkRng.Formula
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    For i = 1 To UBound(arr, 1)
        k = UBound(arr, 2)
        For j = 1 To UBound(arr, 2) / 2
            xTemp = arr(i, j)
            arr(i, j) = arr(i, k)
            arr(i, k) = xTemp
            k = k - 1
        Next
    Next
    WorkRng.Formula = arr
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
End Sub

Sub FlipVertically()
    Dim rng As Range
    Dim WorkRng As Range
    Dim arr As Variant
    Dim i As Integer, j As Integer, k As Integer
    On Error Resume Next
    xTitleId = "Flip columns vertically"
    Set WorkRng = Application.Selection
    arr = WorkRng.Formula
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    For j = 1 To UBound(arr, 2)
        k = UBound(arr, 1)
        For i = 1 To UBound(arr, 1) / 2
            xTemp = arr(i, j)
            arr(i, j) = arr(k, j)
            arr(k, j) = xTemp
            k = k - 1
        Next
    Next
    WorkRng.Formula = arr
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
End Sub

Sub MergeCustom()
    If TypeName(Selection) <> "Range" Then Exit Sub
    If seper = "" Then seper = Chr(10)
    Dim sRange As Range
    Dim cell As Range
    Dim TmpStr As String
    Set sRange = Selection
    Dim element As Variant
    For Each element In sRange.Areas
        If element.MergeCells = True Then GoTo Skip
        For Each cell In element.Cells
            TmpStr = TmpStr & seper & CStr(cell.Value)
        Next cell
        TmpStr = Mid(TmpStr, Len(seper) + 1)
        Application.DisplayAlerts = False
        With element
            .ClearContents
            .MERGE
            .Value = TmpStr
            .VerticalAlignment = xlCenter
            .HorizontalAlignment = xlCenter
        End With
        TmpStr = ""
Skip:
    Next
    Application.DisplayAlerts = True
End Sub

Sub UnmergeCustom()
    If seper = "" Then seper = Chr(10)
    Dim sRange As Range
    Dim cell As Range
    Dim rmpStr As String
    Dim counter As Long
    Dim arr() As String
    Set sRange = Selection
    Dim element As Variant
    For Each element In sRange.Areas
        If element.MergeCells = False Then GoTo Skip
        TmpStr = CStr(element.Cells(1).Value)
        arr = Split(TmpStr, seper)
        element.ClearContents
        element.MergeCells = False
        counter = 0
        On Error Resume Next
        For Each cell In element.Cells
            cell.Value = CStr(arr(counter))
            counter = counter + 1
        Next cell
Skip:
        TmpStr = ""
    Next
    On Error GoTo 0
End Sub

Sub SelectAllMergedCells()
    Dim c As Range
    Dim mergedCells As Range
    Dim fullRange As Range
    Dim rangeDescription As String
    Dim rng As Range

    If Selection.Cells.count > 1 Then
        Set fullRange = Selection
        rangeDescription = "selected cells"
    Else
        Set fullRange = ActiveSheet.UsedRange
        rangeDescription = "active range"
    End If
    For Each c In fullRange
        If c.MergeCells = True Then
            If mergedCells Is Nothing Then
                Set mergedCells = c
            Else
                Set mergedCells = Union(mergedCells, c)
            End If
        End If
    Next
    If Not mergedCells Is Nothing Then
        mergedCells.Select
    Else
        MsgBox "There are no merged cells in the " _
             & rangeDescription & ": " & fullRange.Address
    End If
End Sub

Sub MoveSelection(Direction As String)
    On Error GoTo eh
    Dim myRange As Range
    Set myRange = Selection
    Select Case Direction
        Case Is = "up"
            myRange.OFFSET(-1, 0).Select
        Case Is = "down"
            myRange.OFFSET(1, 0).Select
        Case Is = "left"
            myRange.OFFSET(0, -1).Select
        Case Is = "right"
            myRange.OFFSET(0, 1).Select
    End Select
eh:
End Sub

Sub GoToBlankFirstInColumn()
    If TypeName(Selection) <> "Range" Or _
                           Selection.Cells.count > 1 Then
        MsgBox "Choose 1 cell"
        Exit Sub
    End If
    Dim sourceCol As Integer, rowCount As Integer, currentRow As Integer
    Dim currentRowValue As String
    sourceCol = ActiveCell.Column
    rowCount = Cells(rows.count, sourceCol).End(xlUp).row
    For currentRow = 1 To rowCount + 1
        currentRowValue = Cells(currentRow, sourceCol).Value
        If IsEmpty(currentRowValue) Or currentRowValue = "" Then
            Cells(currentRow, sourceCol).Select
            Exit Sub
        End If
    Next
End Sub

Sub GoToBlankNext()
    If TypeName(Selection) <> "Range" Or _
                           Selection.Cells.count > 1 Then
        MsgBox "Choose 1 cell"
        Exit Sub
    End If
    Dim sourceCol As Integer, rowCount As Integer, currentRow As Integer
    Dim currentRowValue As String
    sourceCol = ActiveCell.Column
    rowCount = Cells(rows.count, sourceCol).End(xlUp).row
    For currentRow = ActiveCell.row + 1 To rowCount + 1
        currentRowValue = Cells(currentRow, sourceCol).Value
        If IsEmpty(currentRowValue) Or currentRowValue = "" Then
            Cells(currentRow, sourceCol).Select
            Exit Sub
        End If
    Next
End Sub

Sub GoToBlankLastWithinColumn()
    If TypeName(Selection) <> "Range" Or _
                           Selection.Cells.count > 1 Then
        MsgBox "Choose 1 cell"
        Exit Sub
    End If
    Dim sourceCol As Integer, rowCount As Integer, currentRow As Integer
    Dim currentRowValue As String
    sourceCol = ActiveCell.Column
    rowCount = Cells(rows.count, sourceCol).End(xlUp).row
    For currentRow = rowCount To 1 Step -1
        currentRowValue = Cells(currentRow, sourceCol).Value
        If IsEmpty(currentRowValue) Or currentRowValue = "" Then
            Cells(currentRow, sourceCol).Select
            Exit Sub
        End If
    Next
End Sub

Sub GoToBlankAfterColumn()
    Application.ScreenUpdating = False
    If TypeName(Selection) <> "Range" Or _
                           Selection.Cells.count > 1 Then
        MsgBox "Choose 1 cell"
        Exit Sub
    End If
    Dim LastRow As Long
    LastRow = Cells(rows.count, ActiveCell.Column).End(xlUp).row
    Cells(LastRow, ActiveCell.Column).OFFSET(1, 0).Select
    With ActiveCell.OFFSET(-1)
        If .TEXT = "" Then .Select
    End With
    Application.ScreenUpdating = True
End Sub

Sub Expand(ByVal ExpandRows As Double, ByVal ExpandColumns As Double)
    Application.ScreenUpdating = False
    Dim r As Range
    Dim i As Long
    Dim RowSize As Long
    Dim ColSize As Long
    For i = 1 To Selection.Areas.count
        ColSize = Selection.Areas(i).Columns.count
        RowSize = Selection.Areas(i).rows.count
        If ValidExpand(RowSize + ExpandRows, ColSize + ExpandColumns) Then
            If r Is Nothing Then
                Set r = Range(Selection.Areas(i).RESIZE(RowSize + ExpandRows, ColSize + ExpandColumns).Address)
            Else
                Set r = Application.Union(r, Range(Selection.Areas(i).RESIZE(RowSize + ExpandRows, ColSize + ExpandColumns).Address))
            End If
        End If
    Next i
    If Not r Is Nothing Then
        ActiveWorkbook.ActiveSheet.Range("A1").Select
        r.Select
    End If
    Application.ScreenUpdating = True
End Sub

Function ValidExpand(Optional a As Long, Optional b As Long) As Boolean
    If a >= 1 And b >= 1 Then ValidExpand = True
End Function

Sub ADDcol()
    Call Expand(0, 1)
End Sub

Sub ADDrow()
    Call Expand(1, 0)
End Sub

Sub REMcol()
    Call Expand(0, -1)
End Sub

Sub REMrow()
    Call Expand(-1, 0)
End Sub

Sub ResizeByTextbox(Optional ExpandRows As Long, Optional ExpandColumns As Long)
    Application.ScreenUpdating = False
    Dim r As Range
    Dim i As Long
    Dim RowSize As Long
    Dim ColSize As Long
    For i = 1 To Selection.Areas.count
        If ExpandRows = 0 Then
            ExpandRows = Selection.Areas(i).rows.count
        End If
        If ExpandColumns = 0 Then
            ExpandColumns = Selection.Areas(i).Columns.count
        End If
        If ValidExpand(ExpandRows, ExpandColumns) Then
            If r Is Nothing Then
                Set r = Range(Selection.Areas(i).RESIZE(ExpandRows, ExpandColumns).Address)
            Else
                Set r = Application.Union(r, Range(Selection.Areas(i).RESIZE(ExpandRows, ExpandColumns).Address))
            End If
        End If
    Next i
    If Not r Is Nothing Then
        ActiveWorkbook.ActiveSheet.Range("A1").Select
        r.Select
    End If
    Application.ScreenUpdating = True
End Sub

Sub deleteBlankWorksheets()
    Dim ws As Worksheet
    On Error Resume Next
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    For Each ws In Application.Worksheets
        If Application.WorksheetFunction.CountA(ws.UsedRange) = 0 Then
            ws.Delete
        End If
    Next
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
End Sub

Sub CopyWorksheetsIncludingTables()
    Dim TheActiveWindow As Window
    Dim TempWindow As Window

    With ActiveWorkbook
        Set TheActiveWindow = ActiveWindow
        Set TempWindow = .NewWindow
        '.Sheets(Array("Sheet1", "sheet2")).Copy
        '///If you want to copy the selected sheets use
        TheActiveWindow.SelectedSheets.Copy
    End With
    TempWindow.Close
End Sub

Sub SortValuesInCell()
    Dim rng As Range
    Dim cell As Range
    Dim del As String
    Dim arr As Variant

    On Error Resume Next
    Set rng = Application.InputBox(Prompt:="Select a range:", _
                                   title:="Sort values inside cells", _
                                   Default:=Selection.Address, Type:=8)
    del = InputBox(Prompt:="Delimiting character: (leave empty for newline)", _
                   title:="Sort values in a single cell")
    On Error GoTo 0
    If del = "" Then del = vbNewLine
    For Each cell In rng
        arr = Split(cell, del)
        SelectionSort arr
        cell = Join(arr, del)
    Next cell

End Sub

Sub SelectionSort(tempArray As Variant)
    'use in sub

    Dim MaxVal As Variant
    Dim MaxIndex As Integer
    Dim i As Integer, j As Integer

    ' Step through the elements in the array starting with the
    ' last element in the array.
    For i = UBound(tempArray) To 0 Step -1

        ' Set MaxVal to the element in the array and save the
        ' index of this element as MaxIndex.
        MaxVal = tempArray(i)
        MaxIndex = i

        ' Loop through the remaining elements to see if any is
        ' larger than MaxVal. If it is then set this element
        ' to be the new MaxVal.
        For j = 0 To i
            If tempArray(j) > MaxVal Then
                MaxVal = tempArray(j)
                MaxIndex = j
            End If
        Next j

        ' If the index of the largest element is not i, then
        ' exchange this element with element i.
        If MaxIndex < i Then
            tempArray(MaxIndex) = tempArray(i)
            tempArray(i) = MaxVal
        End If
    Next i

End Sub

Public Function LatinToGreek(TEXT4TRANS As String) As String
    'Convert characters to Greek
    Dim strFromLetter, strToLetter As String
    Dim intLetterPosition, intGreekLetterPosition As Long
    strFromLetter = "abgdezhuiklmnjoprstyfxcvABGDEZHUIKLMNJOPRSTYFXCV"
    'strToLetter = "áâãäåæçèéêëìíîïðñóôõö÷øùÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÓÔÕÖ×ØÙ"
    strToLetter = "ÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÓÔÕÖ×ØÙÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÓÔÕÖ×ØÙ"

    For intLetterPosition = 1 To Len(TEXT4TRANS)
        intGreekLetterPosition = InStr(1, strFromLetter, Mid(TEXT4TRANS, intLetterPosition, 1))
        If intGreekLetterPosition > 0 Then
            Mid(TEXT4TRANS, intLetterPosition, 1) = Mid(strToLetter, intGreekLetterPosition, 1)
        End If
    Next
    LatinToGreek = TEXT4TRANS
End Function

Function GreekToLatin(keimeno As String) As String
    'https://varlamis.wordpress.com/2011/05/31/word_GreekToLatin/
    '    Application.Volatile True
    Dim varr As Variant
    Dim inchar As Variant
    Dim exchar As Variant
    Dim pl As Integer, gr As Integer, lu As Integer
    Dim gramma As String
    pl = Len(keimeno)
 
    inchar = Array("Á", "Â", "Ã", "Ä", "Å", "Æ", "Ç", "È", "É", "Ê", "Ë", _
                   "Ì", "Í", "Î", "Ï", "Ð", "Ñ", "Ó", "Ô", "Õ", "Ö", "×", "Ø", "Ù", _
                   "¢", "¸", "¹", "º", "¼", "¾", "¿", "Ú", "Û", "À", "à", "ò")

    exchar = Array("A", "B", "G", "D", "E", "Z", "H", "8", "I", "K", "L", _
                   "M", "N", "KS", "O", "P", "R", "S", "T", "Y", "F", "X", "PS", "W", _
                   "A", "E", "H", "I", "O", "Y", "W", "I", "Y", "I", "Y", "S")
 
    ReDim varr(pl - 1)
    For gr = 1 To pl
        gramma = Mid(keimeno, gr, 1)
        For lu = LBound(inchar) To UBound(inchar)
            If UCase(gramma) = inchar(lu) Then gramma = exchar(lu): Exit For
        Next
        varr(gr - 1) = gramma
    Next
    GreekToLatin = Join(varr, "")

End Function

Function GetColorText(pRange As Range) As String
    Dim xOut As String
    Dim xValue As String
    Dim i As Long
    xValue = pRange.TEXT
    For i = 1 To VBA.Len(xValue)
        'If pRange.Characters(i, 1).Font.Color = vbRed Then
        'If pRange.Characters(i, 1).Font.Bold = true Then
        If pRange.Characters(i, 1).Font.color <> vbBlack Then
            xOut = xOut & VBA.Mid(xValue, i, 1)
        End If
    Next
    GetColorText = xOut
End Function

Function RemoveCharacters(TEXT As String, Remove As String) As String
    Dim X As Long
    RemoveCharacters = TEXT
    For X = 1 To Len(Remove)
        RemoveCharacters = Replace(RemoveCharacters, Mid(Remove, X, 1), "")
    Next
End Function

Private Sub DrawArrows(FromRange As Range, ToRange As Range, Optional RGBcolor As Long, Optional LineType As String)
    '---------------------------------------------------------------------------------------------------
    '---Script: DrawArrows------------------------------------------------------------------------------
    '---Created by: Ryan Wells -------------------------------------------------------------------------
    '---Date: 10/2015-----------------------------------------------------------------------------------
    '---Description: This macro draws arrows or lines from the middle of one cell to the middle --------
    '----------------of another. Custom endpoints and shape colors are suppported ----------------------
    '---------------------------------------------------------------------------------------------------

    Dim dleft1 As Double, dleft2 As Double
    Dim dtop1 As Double, dtop2 As Double
    Dim dheight1 As Double, dheight2 As Double
    Dim dwidth1 As Double, dwidth2 As Double
    dleft1 = FromRange.left
    dleft2 = ToRange.left
    dtop1 = FromRange.top
    dtop2 = ToRange.top
    dheight1 = FromRange.Height
    dheight2 = ToRange.Height
    dwidth1 = FromRange.Width
    dwidth2 = ToRange.Width
 
    ActiveSheet.Shapes.AddConnector(msoConnectorStraight, dleft1 + dwidth1 / 2, dtop1 + dheight1 / 2, dleft2 + dwidth2 / 2, dtop2 + dheight2 / 2).Select
    'format line
    Selection.Name = "myArrow"
    With Selection.ShapeRange.line
        .BeginArrowheadStyle = msoArrowheadNone
        .EndArrowheadStyle = msoArrowheadOpen
        .Weight = 1.75
        .Transparency = 0.5
        If UCase(LineType) = "DOUBLE" Then        'double arrows
            .BeginArrowheadStyle = msoArrowheadOpen
        ElseIf UCase(LineType) = "LINE" Then        'Line (no arows)
            .EndArrowheadStyle = msoArrowheadNone
        Else        'single arrow
            'defaults to an arrow with one head
        End If
        'color arrow
        If RGBcolor <> 0 Then
            .ForeColor.RGB = RGBcolor        'custom color
        Else
            .ForeColor.RGB = vbRed        'RGB(228, 108, 10)   'orange (DEFAULT)
        End If
    End With

End Sub

Sub RemoveArrows()
    Dim shp As Shape
    For Each shp In ActiveSheet.Shapes
        If shp.Name = "myArrow" Then
            shp.Delete
        End If
    Next
End Sub

Sub CircleBoxADD()
    If TypeName(Selection) <> "Range" Then
        MsgBox "Please select 1 or more ranges before running the macro."
        Exit Sub
    End If
    Dim MyOval As Shape
    Dim cell As Range
    Dim i As Long
    If oToCells.Value = True Then
        For Each cell In Selection
            addCircle cell
        Next
    Else
        For i = 1 To Selection.Areas.count
            addCircle Selection.Areas(i).Cells
        Next
    End If
End Sub

Sub addCircle(cell As Range)
    On Error GoTo cellisarea
    t = cell.MergeArea.top
    l = cell.MergeArea.left
    h = cell.MergeArea.Height
    w = cell.MergeArea.Width
    GoTo PASS
cellisarea:
    t = cell.top
    l = cell.left
    h = cell.Height
    w = cell.Width
PASS:
    On Error GoTo 0
    Set MyOval = ActiveSheet.Shapes.AddShape(msoShapeOval, l + 2, t + 2, w - 4, h - 4)
    With MyOval
        .Name = "myCircle"
        .Fill.visible = msoFalse
        .line.visible = msoTrue
        .line.ForeColor.RGB = RGB(255, 0, 0)
        .line.Transparency = 0
        .line.visible = msoTrue
        .line.Weight = 0.5
    End With
End Sub

Sub CircleBoxREMOVE()
    Dim shp As Shape
    For Each shp In ActiveSheet.Shapes
        If shp.Name = "myCircle" Then
            shp.Delete
        End If
    Next
End Sub

Sub SquareRange(rng As Range)
    Dim i As Integer
    If rng Is Nothing Then
        If TypeName(Selection) = "Range" Then
            Set rng = Selection
        Else
            Exit Sub
        End If
    End If
    For i = 1 To 4
        With rng
            .Columns.ColumnWidth = _
                                 .Columns("A").ColumnWidth / .Columns("A").Width * _
                                 .rows(1).Height
        End With
    Next
End Sub



'uImageControl	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uImageControl
'* Created    : 06-10-2022 10:38
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private MainPath As String
Private Shrink As Double
Private eTime As Variant

Private WithEvents Emitter As EventListenerEmitter

Private Sub UserForm_Activate()
    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll Me
End Sub

Private Sub UserForm_Initialize()
    Dim anc As MSForms.control

    For Each c In Me.Controls
        If TypeName(c) = "Frame" Then
            'c.Caption = ""
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                c.visible = False
                If InStr(1, c.Tag, "anchor") > 0 Then
                    On Error Resume Next
                    Set anc = Me.Controls("Anchor" & Mid(c.Tag, InStr(1, c.Tag, "Anchor", vbTextCompare) + Len("Anchor"), 2))
                    If anc Is Nothing Then Stop
                    On Error GoTo 0
                    c.top = anc.top        'Anchor01.Top
                    c.left = anc.left        ' Anchor01.Left
                    Set anc = Nothing
                End If
            End If
        End If
    Next
    
    Dim MainPath As String
    MainPath = Environ$("USERPROFILE") & "\My Documents\vbArc\ExportedImages\"
    FoldersCreate MainPath
    ComboBox1.list = Array("GIF", "JPG", "ICO", "BMP", "CUR", "WMF")
    ComboBox1.ListIndex = 0
    Shrink = CInt(lbShrink.Caption) * 0.1
    
    Me.Height = 259
    Me.Width = 166
End Sub

Private Sub bExportRange_Click()
    ExportAsImage
End Sub

Private Sub bFitToText_Click()
    TextBoxResizeTB
End Sub

Private Sub bExportShapes_Click()
    ExportShapeAsPicture
End Sub

Private Sub bSelectByRange_Click()
    SelectShapesWithinSelectedRange
End Sub

Private Sub bOB_Click()
    ShapesOutsideVisibleRange
End Sub

Private Sub bSelectByName_Click()
    SelectShapesByName
End Sub

Private Sub bInsertToRange_Click()
    InsertPictures
End Sub

Private Sub bInsertToComment_Click()
    InsertImageInActivecellComment
End Sub

Private Sub bPastePicture_Click()
    PasteAsPicture
End Sub

Private Sub bPasteLinked_Click()
    PasteAsLinkedPicture
End Sub

Private Sub bAlignHorizontal_Click()
    GridHorizontal
End Sub

Private Sub bAlignVertical_Click()
    GridVertical
End Sub

Private Sub bFitCell_Click()
    PicturesFitCenter
End Sub

Private Sub bSelectByText_Click()
    SelectShapesByText
End Sub

Private Sub Emitter_LabelMouseOut(label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then
        If label.BackColor <> &H80B91E Then label.BackColor = &H534848
    End If
End Sub

Private Sub Emitter_LabelMouseOver(label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then
        If label.BackColor <> &H80B91E Then label.BackColor = &H808080
    End If
End Sub

Sub Emitter_LabelClick(ByRef label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then Reframe label
End Sub

Private Sub Reframe(control As MSForms.control)
    For Each c In Me.Controls
        If TypeName(c) = "Frame" Then
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                If c.Name <> control.parent.parent.Name Then c.visible = False
            End If
        End If
    Next
    Me.Controls(control.Caption).visible = True
    For Each c In Me.Controls
        If TypeName(c) = "Label" Then
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                c.BackColor = &H534848
                'c.SpecialEffect = fmSpecialEffectFlat
            End If
        End If
    Next
    control.BackColor = &H80B91E
    'Control.SpecialEffect = fmSpecialEffectRaised

End Sub

Private Sub iFolder_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    FollowLink MainPath
End Sub

Private Sub Image2_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Sub FollowLink(FolderPath As String)
    Dim oShell As Object
    Dim Wnd As Object
    Set oShell = CreateObject("Shell.Application")
    For Each Wnd In oShell.Windows
        If Wnd.Name = "File Explorer" Then
            If Wnd.document.Folder.Self.Path = FolderPath Then Exit Sub
        End If
    Next Wnd
    Application.ThisWorkbook.FollowHyperlink Address:=FolderPath, NewWindow:=True
End Sub

Private Sub SpinButton1_Change()
    lbShrink.Caption = SpinButton1.Value
    Shrink = CInt(lbShrink.Caption) * 0.1
End Sub

Sub GridVertical()
    Dim shp As Shape
    Dim lCnt As Long
    Dim dTop As Double
    Dim dLeft As Double
    Dim dHeight As Double
    Dim dWidth As Double
    Dim dSPACE As Variant
    Dim lRowCnt As Variant
    Dim dStart As Double
    Dim dMaxHeight As Double
    If TypeName(Selection) = "Range" Then
        MsgBox "Please select shapes before running the macro."
        Exit Sub
    End If
    lRowCnt = Application.InputBox("Enter the number of columns for the vertical shape grid.", "Vertical Shape Grid", Type:=1)
    If lRowCnt <= 0 Or lRowCnt = False Then
        Exit Sub
    End If
    dSPACE = Application.InputBox("Enter the space between shapes in points.", "Vertical Shape Grid", Type:=1)
    If TypeName(dSPACE) = "Boolean" Then
        Exit Sub
    End If
    lCnt = 1
    For Each shp In Selection.ShapeRange
        With shp
            If lCnt = 1 Then
                dStart = .left
            Else
                If lCnt Mod lRowCnt = 1 Or lRowCnt = 1 Then
                    .top = dTop + dMaxHeight + dSPACE
                    .left = dStart
                    dMaxHeight = .Height
                Else
                    .top = dTop
                    .left = dLeft + dWidth + dSPACE
                End If
            End If
            dTop = .top
            dLeft = .left
            dHeight = .Height
            dWidth = .Width
            dMaxHeight = WorksheetFunction.Max(dMaxHeight, .Height)
        End With
        lCnt = lCnt + 1
    Next shp
End Sub

Sub GridHorizontal()
    Dim shp As Shape
    Dim lCnt As Long
    Dim dTop As Double
    Dim dLeft As Double
    Dim dHeight As Double
    Dim dWidth As Double
    Dim dSPACE As Variant
    Dim lColCnt As Variant
    Dim lCol As Long
    Dim dStart As Double
    Dim lRow As Double
    Dim dMaxWidth As Double
    If TypeName(Selection) = "Range" Then
        MsgBox "Please select shapes before running the macro."
        Exit Sub
    End If
    lColCnt = Application.InputBox("Enter the number of rows for the horizontal shape grid.", "Horizontal Shape Grid", Type:=1)
    If lColCnt <= 0 Or lColCnt = False Then
        Exit Sub
    End If
    dSPACE = Application.InputBox("Enter the space between shapes in points.", "Horizontal Shape Grid", Type:=1)
    If TypeName(dSPACE) = "Boolean" Then
        Exit Sub
    End If
    lCnt = 1
    For Each shp In Selection.ShapeRange
        With shp
            If lCnt = 1 Then
                dStart = .top
            Else
                If lCnt Mod lColCnt = 1 Or lColCnt = 1 Then
                    .top = dStart
                    .left = dLeft + dMaxWidth + dSPACE
                    dMaxWidth = .Width
                Else
                    .top = dTop + dHeight + dSPACE
                    .left = dLeft
                End If
            End If
            dTop = .top
            dLeft = .left
            dHeight = .Height
            dWidth = .Width
            dMaxWidth = WorksheetFunction.Max(dMaxWidth, .Width)
        End With
        lCnt = lCnt + 1
    Next shp
End Sub

Sub ExportShapeAsPicture()
    Dim cht As ChartObject
    Dim ActiveShape As Shape
    Dim EXT As String
    EXT = uImageControl.ComboBox1.TEXT
    If TypeName(Selection) = "Range" Then GoTo NoShapeSelected
    For Each ActiveShape In Selection.ShapeRange
        Set cht = ActiveSheet.ChartObjects.Add( _
                  left:=ActiveCell.left, _
                  Width:=ActiveShape.Width, _
                  top:=ActiveCell.top, _
                  Height:=ActiveShape.Height)
        cht.ShapeRange.Fill.visible = msoFalse
        cht.ShapeRange.line.visible = msoFalse
        ActiveShape.Copy
        cht.Activate
        ActiveChart.Paste
        cht.Chart.Export MainPath & ActiveShape.Name & "." & EXT
        cht.Delete
        ActiveShape.Select
    Next ActiveShape
    Exit Sub
NoShapeSelected:
    MsgBox "Please select shapes before running the macro."
    Exit Sub
End Sub

Sub ExportAsImage()
    If Not TypeName(Selection) = "Range" Then
        MsgBox "Please select shapes before running the macro."
        Exit Sub
    End If
    Dim cell As Range
    Dim EXT As String
    EXT = uImageControl.ComboBox1.TEXT
    Dim action As Long
    action = MsgBox("(YES) = for each area in selection" & Chr(10) & _
                    "(NO) = for each cell in selection", vbYesNoCancel)
    If action = vbCancel Then Exit Sub
    On Error Resume Next
    Application.DisplayAlerts = False
    Select Case action
        Case Is = vbNo
            For Each cell In Selection
                Call ExportRangeAsImage(ActiveSheet, cell, MainPath, cell.Value, EXT)
                Application.Wait (Now + TimeValue("0:00:01"))
            Next cell
        Case Is = vbYes
            Dim result As String
            For i = 1 To Selection.Areas.count
                result = ""
                result = InputBox("name for image of area: " & Selection.Areas(i).Address)
                If CStr(result) = "" Then result = Format(Now, "hhmmss")
                Call ExportRangeAsImage(ActiveSheet, Selection.Areas(i), MainPath, result, EXT)
                Application.Wait (Now + TimeValue("0:00:01"))
            Next i
    End Select
    Application.DisplayAlerts = True
    Shell "explorer.exe" & " " & MainPath, vbNormalFocus
End Sub

' Procedure : ExportRangeAsImage
' Author    : Daniel Pineault, CARDA Consultants Inc.
' Website   : http://www.cardaconsultants.com
' Purpose   : Capture a picture of a worksheet range and save it to disk
'               Returns True if the operation is successful
' Note      : *** Overwrites files, if already exists, without any warning! ***
' Copyright : The following is release as Attribution-ShareAlike 4.0 International
'             (CC BY-SA 4.0) - https://creativecommons.org/licenses/by-sa/4.0/
' Req'd Refs: Uses Late Binding, so none required
'
' Input Variables:
' ~~~~~~~~~~~~~~~~
' ws            : Worksheet to capture the image of the range from
' rng           : Range to capture an image of
' sPath         : Fully qualified path where to export the image to
' sFileName     : filename to save the image to WITHOUT the extension, just the name
' sImgExtension : The image file extension, commonly: JPG, GIF, PNG, BMP
'                   If omitted will be JPG format
'
' Usage:
' ~~~~~~
' ? ExportRangeAsImage(Sheets("Sheet1"), Range("A1"), "C:\Temp\Charts\", "test01". "JPG")
' ? ExportRangeAsImage(Sheets("Products"), Range("D5:F23"), "C:\Temp\Charts", "test02")
' ? ExportRangeAsImage(Sheets("Sheet1"), Range("A1"), "C:\Temp\Charts\", "test01", "PNG")
'
' Revision History:
' Rev       Date(yyyy/mm/dd)        Description
' **************************************************************************************
' 1         2020-04-06              Initial Release
'---------------------------------------------------------------------------------------
Function ExportRangeAsImage(ws As Worksheet, _
                            rng As Range, _
                            sPath As String, _
                            sFilename As String, _
                            Optional sImgExtension As String = "JPG") As Boolean
    Dim oChart                As ChartObject
    On Error GoTo Error_Handler
    If Right(sPath, 1) <> "\" Then sPath = sPath & "\"
    Application.ScreenUpdating = False
    ws.Activate
    rng.CopyPicture xlScreen, xlPicture        'Copy Range Content
    Set oChart = ws.ChartObjects.Add(0, 0, rng.Width, rng.Height)        'Add chart
    oChart.Activate
    With oChart.Chart
        .Paste        'Paste our Range
        .Export sPath & sFilename & "." & LCase(sImgExtension), sImgExtension        'Export the chart as an image
    End With
    oChart.Delete        'Delete the chart
    ExportRangeAsImage = True
Error_Handler_Exit:
    On Error Resume Next
    Application.ScreenUpdating = True
    If Not oChart Is Nothing Then Set oChart = Nothing
    Exit Function
Error_Handler:
    '76 - Path not found
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: ExportRangeAsImage" & vbCrLf & _
           "Error Description: " & err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Function

Sub InsertPictures()
    Dim PicList() As Variant
    Dim PicFormat As String
    Dim rng As Range
    Dim sShape As Shape
    On Error Resume Next
    PicList = Application.GetOpenFilename(PicFormat, multiSelect:=True)
    xColIndex = Application.ActiveCell.Column
    If IsArray(PicList) Then
        xRowIndex = Application.ActiveCell.row
        For lLoop = LBound(PicList) To UBound(PicList)
            Set rng = Cells(xRowIndex, xColIndex)
            Set sShape = ActiveSheet.Shapes.AddPicture(PicList(lLoop), msoFalse, msoCTrue, _
                                                       rng.left, rng.top, -1, -1)
            With sShape
                .LockAspectRatio = msoTrue
                If .Height > .Width Then
                    .Height = rng.Height - (rng.Height * Shrink)
                Else
                    .Width = rng.Width - (rng.Width * Shrink)
                End If
                .top = rng.MergeArea.top + (rng.MergeArea.Height - .Height) / 2
                .left = rng.MergeArea.left + (rng.MergeArea.Width - .Width) / 2
            End With
            xRowIndex = xRowIndex + 1
        Next
    End If
End Sub

Sub InsertImageInActivecellComment()
    If TypeName(Selection) <> "Range" Then
        MsgBox "Please select a cell before running the macro."
        Exit Sub
    End If
    Dim cell As Range
    Dim cmt As Comment
    Dim PicPath As String
    Dim str As String
    Dim myObj As Object
    Dim myDirString As String
    Set myObj = Application.FileDialog(msoFileDialogFilePicker)
    With myObj
        .initialFileName = "C:\Users\" & Environ$("Username") & "\Pictures"
        .Filters.Add "Images", "*.png, *jpeg, *.jpg, *.gif, *.ico, *.cur, *.wmf"
        .FilterIndex = 2
        If .Show = False Then MsgBox "No picture selected", vbExclamation: Exit Sub
        PicPath = .SelectedItems(1)
    End With
    On Error Resume Next
    Set cell = Selection.MergeArea
    With cell
        If .Comment Is Nothing Then
            Set cmt = .AddComment
            str = cmt.TEXT
        Else
            Set cmt = .Comment
            str = cmt.TEXT
        End If
    End With
    With cmt
        .TEXT ((Replace(str, Application.UserName & ":", "")))
        .Shape.Fill.UserPicture PicPath
        .visible = False
    End With
End Sub

Sub ScreenRefresh()
    Dim s As Shape
    For Each s In Workbooks("").SHEETS("Sheet1")
        s.top = ThisWorkbook.Windows(1).VisibleRange.top
    Next s
End Sub

Sub StartTimedRefresh()
    Call ScreenRefresh
    eTime = Now + TimeValue("00:00:01")
    Application.OnTime eTime, "StartTimedRefresh"
End Sub

Sub StopTimer()
    Application.OnTime eTime, "StartTimedRefresh", , False
End Sub

Sub TextBoxResizeTB()
    Dim xShape As Shape
    Dim xSht As Worksheet
    On Error Resume Next
    For Each xSht In ActiveWorkbook.Worksheets
        For Each xShape In xSht.Shapes
            xShape.TextFrame2.AutoSize = msoAutoSizeShapeToFitText
            xShape.TextFrame2.WordWrap = False
        Next
    Next
End Sub

Sub PicturesFitCenter()
    If TypeName(Selection) = "Range" Then
        MsgBox "Please select shapes before running the macro."
        Exit Sub
    End If
    Dim ans As Long
    ans = MsgBox("Lock Aspect Ratio?", vbYesNoCancel)
    If ans = vbCancel Then Exit Sub
    Dim p As Shape
    For Each p In Selection.ShapeRange
        Dim cell As Range: Set cell = Cells(p.TopLeftCell.row, p.TopLeftCell.Column)
        With p
            If ans = vbYes Then
                .LockAspectRatio = True
                If .Height > .Width Then
                    .Height = cell.Height - (cell.Height * Shrink)
                Else
                    .Width = cell.Width - (cell.Width * Shrink)
                End If
            Else
                .LockAspectRatio = False
                If .Height > .Width Then
                    .Width = cell.Width - (cell.Width * Shrink)
                    .Height = cell.Height - (cell.Height * Shrink)
                Else
                    .Height = cell.Height - (cell.Height * Shrink)
                    .Width = cell.Width - (cell.Width * Shrink)
                End If
            End If
            .top = cell.MergeArea.top + (cell.MergeArea.Height - .Height) / 2
            .left = cell.MergeArea.left + (cell.MergeArea.Width - .Width) / 2
        End With
    Next
End Sub

Sub ShapesOutsideVisibleRange()
    If ActiveSheet.Shapes.count = 0 Then
        MsgBox "No shapes in active sheet"
        Exit Sub
    End If
    Dim s As Shape
    Dim rngholder As String
    For Each s In ActiveSheet.Shapes
        If Range(s.BottomRightCell.Address).row > ActiveWindow.VisibleRange.rows.count Then
            rngholder = _
                      rngholder & Chr(10) & s.BottomRightCell.Address
        End If
    Next s
    If rngholder = "" Then
        MsgBox "No shape out of range"
        Exit Sub
    End If
    Dim arr
    arr = Split(rngholder, Chr(10))
    Dim lastSposition As String
    lastSposition = arr(UBound(arr))
    If Range(lastSposition).row > ActiveWindow.VisibleRange.rows.count Then
        MsgBox "There are shapes after the last visible row." _
             & Chr(10) & "Their BottomRight cells span the following ranges: " _
             & rngholder
    Else
        MsgBox "All shapes positioned inside visible range"
    End If
End Sub

Sub PasteAsPicture()
    If TypeName(Selection) <> "Range" Then
        MsgBox "Please select a range before running the macro."
        Exit Sub
    End If
    For i = 1 To Selection.Areas.count
        Application.CutCopyMode = False
        Selection.Areas(i).Copy
        ActiveSheet.Pictures.Paste
    Next
    Application.CutCopyMode = False
End Sub

Sub PasteAsLinkedPicture()
    If TypeName(Selection) <> "Range" Then
        MsgBox "Please select a range before running the macro."
        Exit Sub
    End If
    Dim coll As New Collection
    For i = 1 To Selection.Areas.count
        coll.Add Selection.Areas(i).Address
    Next
    Dim element As Variant
    Range(coll(1)).Select
    For Each element In coll
        Application.CutCopyMode = False
        Range(element).Copy
        ActiveSheet.Pictures.Paste link:=True
    Next
    Application.CutCopyMode = False
End Sub

Sub SelectShapesWithinSelectedRange()
    On Error Resume Next
    If TypeName(Selection) <> "Range" Then
        MsgBox "Select a range first"
        Exit Sub
    End If
    Dim shp As Shape
    Dim r As Range
    Set r = Selection
    For Each shp In ActiveSheet.Shapes
        If Not Intersect(Range(shp.TopLeftCell, shp.BottomRightCell), r) Is Nothing Then
            shp.Select Replace:=False
        End If
    Next shp
End Sub

Sub SelectShapesByName()
    On Error Resume Next
    Dim shp As Shape
    ActiveSheet.Range("A1").Select
    Dim str As String
    str = InputBox("contains in NAME?")
    For Each shp In ActiveSheet.Shapes
        If InStr(shp.Name, str) Then
            shp.Select Replace:=False
        End If
    Next shp
End Sub

Sub SelectShapesByText()
    Dim shp As Shape
    Dim str As String
    str = InputBox("contains in TEXT?")
    ActiveSheet.Range("A1").Select
    On Error GoTo nxt
    For Each shp In ActiveWorkbook.ActiveSheet.Shapes
        If shp.Type <> 13 Then
            With shp.TextFrame.Characters
                If InStr(1, .TEXT, str) Then
                    shp.Select Replace:=False
                End If
            End With
        End If
nxt:
    Next shp
End Sub

Private Sub ResizeUserformToFitControls(form As Object)
    form.Width = 0
    form.Height = 0
    Dim ctr As MSForms.control
    Dim myWidth
    myWidth = form.InsideWidth
    For Each ctr In form.Controls
        If ctr.visible = True Then
            If ctr.left + ctr.Width > myWidth Then myWidth = ctr.left + ctr.Width
        End If
    Next
    form.Width = myWidth + form.Width - form.InsideWidth + 10
    Dim myHeight
    myHeight = form.InsideHeight
    For Each ctr In form.Controls
        If ctr.visible = True Then
            If ctr.top + ctr.Height > myHeight Then myHeight = ctr.top + ctr.Height
        End If
    Next
    form.Height = myHeight + (form.Height - form.InsideHeight) + 10
End Sub



'M_DataEntry	1

Rem @Folder DataEntry
Sub ShakeTableWand()
    If SetControlRange("TableControl" & "_" & ActiveSheet.Name, _
                       "Range selection", _
                       "Select table controller RANGE" & vbNewLine & vbNewLine & _
                       "Include cells with text (label) and empty cells to the right (input field)") = False Then Exit Sub
    '#INCLUDE CopyModule
    '#INCLUDE addVBEreference
    '#INCLUDE SetControlRange
    '#INCLUDE setControlInputFields
    '#INCLUDE SetTableHeadersRange
    '#INCLUDE CreateTable
    '#INCLUDE setLoadedRow
    '#INCLUDE SetMappingRange
    '#INCLUDE TableWorksheetCode
    '#INCLUDE CreateControlShapes
    Application.ScreenUpdating = False
    Call setControlInputFields
    Call SetTableHeadersRange("TableHeaderRange" & "_" & ActiveSheet.Name, 2)
    Call CreateTable(ActiveSheet.Range("TableHeaderRange" & "_" & ActiveSheet.Name).Worksheet, _
                     ActiveSheet.Range("TableHeaderRange" & "_" & ActiveSheet.Name), _
                     "DynamicTable" & "_" & ActiveSheet.Name)
    Call setLoadedRow(0)
    Call SetMappingRange("MappingRange" & "_" & ActiveSheet.Name)
    Call CreateControlShapes
    CopyModule "mTableWand", ThisWorkbook, ActiveWorkbook, False
    addVBEreference
    Call TableWorksheetCode
    ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).Cells(1, 2).Select
    Application.ScreenUpdating = True
End Sub

Sub addVBEreference()
    On Error Resume Next
    ActiveWorkbook.VBProject.REFERENCES.AddFromGuid _
        GUID:="{0002E157-0000-0000-C000-000000000046}", _
        Major:=5, Minor:=3
    On Error GoTo 0
End Sub

Function SetControlRange(RangeName As String, _
                         Optional sTitle As String, _
                         Optional sPrompt As String) As Boolean
    '#INCLUDE getRangeFromSelection
    '#INCLUDE DuplicateInRange
    '#INCLUDE createNamedRange
    SetControlRange = True
    Dim SelectedRange As Range
    Set SelectedRange = getRangeFromSelection(sTitle, sPrompt)
    If SelectedRange Is Nothing Then
        MsgBox "The range was cancelled"
        SetControlRange = False
        Exit Function
    Else
        If DuplicateInRange(SelectedRange) = True Then
            MsgBox ("Duplicates found in chosen range.")
            SetControlRange = False
            Exit Function
        ElseIf Application.WorksheetFunction.CountA(SelectedRange) = 0 Then
            MsgBox ("No Control labels found")
            SetControlRange = False
            Exit Function
        Else
            If SelectedRange.Column = 1 Then
                SelectedRange.Cells(1, 1).EntireColumn.Insert
            End If
            Call createNamedRange(RangeName, _
                                  SelectedRange.Worksheet, _
                                  SelectedRange)
        End If
    End If
    With SelectedRange.SpecialCells(xlCellTypeConstants).BORDERS
        .LineStyle = xlContinuous
        .color = vbBlack
        .Weight = xlThin
    End With
    With SelectedRange.SpecialCells(xlCellTypeConstants)
        .Interior.ColorIndex = 23
        .Characters.Font.color = vbWhite
        .Characters.Font.Bold = True
    End With
End Function

Function getRangeFromSelection(Optional sTitle As String, _
                               Optional sPrompt As String) As Range
    On Error Resume Next
    Set getRangeFromSelection = _
                              Application.InputBox(title:=sTitle, _
                                                   Prompt:=sPrompt, _
                                                   Type:=8, _
                                                   Default:=IIf(TypeName(Selection) = "Range", Selection.Address, ""))
    On Error GoTo 0
End Function

Function DuplicateInRange(r As Range) As Boolean
    Dim cell As Range
    Dim scr As Object
    Set scr = CreateObject("scripting.dictionary")
    With scr
        For Each cell In Selection.SpecialCells(xlCellTypeConstants)
            If cell.TEXT <> "" Then
                Debug.Print cell.Address & vbTab & cell.TEXT
                If Not .Exists(cell.Value) Then
                    .Add cell.Value, Nothing
                Else
                    DuplicateInRange = True
                    Set scr = Nothing
                    Exit Function
                End If
            End If
        Next cell
    End With
    Set scr = Nothing
End Function

Sub createNamedRange(RangeName As String, _
                     Worksheet As Worksheet, _
                     NamedRange As Variant)
    ActiveWorkbook.Names.Add Name:=RangeName, RefersTo:=NamedRange
End Sub

Sub setControlInputFields()
    '#INCLUDE createNamedRange
    Dim SelectedRange As Range
    Dim cell As Range
    For Each cell In ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).SpecialCells(xlCellTypeConstants)
        If SelectedRange Is Nothing Then
            Set SelectedRange = cell.MergeArea.OFFSET(0, 1).MergeArea
        Else
            Set SelectedRange = Union(SelectedRange, cell.MergeArea.OFFSET(0, 1).MergeArea)
        End If
    Next
    Call createNamedRange("ControlInputFields" & "_" & ActiveSheet.Name, _
                          SelectedRange.parent, _
                          SelectedRange)
    For Each cell In SelectedRange
        cell.MergeArea.BorderAround xlContinuous, xlThin
    Next
End Sub

Sub SetTableHeadersRange(RangeName As String, _
                         Optional offsetRows As Long = 3)
    '#INCLUDE createNamedRange
    '#INCLUDE getTableLastRow
    If offsetRows < 3 Then offsetRows = 3
    Dim cell As Range
    Dim coll As New Collection
    Dim txt As String
    On Error Resume Next
    For Each cell In ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).SpecialCells(xlCellTypeConstants)
        txt = WorksheetFunction.Concat(cell.MergeArea)
        coll.Add txt, txt
    Next cell
    On Error GoTo 0
    Dim SelectedRange As Range
    Set SelectedRange = ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).Worksheet.Cells( _
        getTableLastRow(ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name)), _
        ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).Column) _
        .OFFSET(offsetRows, 0). _
        RESIZE(1, coll.count)
    Call createNamedRange(RangeName, _
                          SelectedRange.Worksheet, _
                          SelectedRange)
    Dim i As Long
    For i = 1 To coll.count
        SelectedRange.Cells(1, i).Value = coll(i)
    Next i
End Sub

Function getTableLastRow(TableRange As Range) As Long
    getTableLastRow = TableRange.row + TableRange.rows.count - 1
End Function

Sub CreateTable(myWorksheet As Worksheet, _
                myRange As Range, _
                TableName As String)
    Dim MyTable As ListObject
    myWorksheet.ListObjects.Add _
        (xlSrcRange, myRange, , xlYes) _
        .Name = TableName
End Sub

Function setLoadedRow(LoadedTableRow As Long)
    Call createNamedRange("LoadedRow" & "_" & ActiveSheet.Name, _
                          ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).parent, _
                          LoadedTableRow)
    '#INCLUDE createNamedRange
End Function

Sub SetMappingRange(RangeName As String)
    '#INCLUDE createNamedRange
    '#INCLUDE RangeOfValueTableWand
    Dim cell As Range
    For Each cell In ActiveSheet.Range("TableHeaderRange" & "_" & ActiveSheet.Name)
        cell.OFFSET(-1, 0).Value = RangeOfValueTableWand(cell.Value, ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name), 0, 1).Address
    Next cell
    Call createNamedRange(RangeName, _
                          ActiveSheet.Range("TableHeaderRange" & "_" & ActiveSheet.Name).parent, _
                          ActiveSheet.Range("TableHeaderRange" & "_" & ActiveSheet.Name).OFFSET(-1, 0))
End Sub

Function RangeOfValueTableWand(findWhat As String, _
                               findWhere As Range, _
                               Optional offsetRow As Long = 0, _
                               Optional offsetCol As Long = 0) As Range
    For Each cell In findWhere
        If cell.Value = findWhat Then
            Set RangeOfValueTableWand = cell.MergeArea.OFFSET(offsetRow, offsetCol)
            Exit Function
        End If
    Next
End Function

Sub TableWorksheetCode()
    '#INCLUDE setLoadedRow
    '#INCLUDE PopulateTableControl
    '#INCLUDE WorksheetOfDynamicTable
    Dim CodeText As String
    CodeText = CodeText & "Private Sub Worksheet_SelectionChange(ByVal Target As Range)" & vbNewLine
    CodeText = CodeText & "    If Selection.ListObject Is Nothing Then Exit Sub" & vbNewLine
    CodeText = CodeText & "    If Selection.Cells.Count <> 1 Then Exit Sub" & vbNewLine
    CodeText = CodeText & "    If Selection.Row - Selection.ListObject.Range.Row = ActiveWorkbook.Names(""LoadedRow"" & ""_"" & ActiveSheet.Name) Then Exit Sub" & vbNewLine
    CodeText = CodeText & "    If Not Intersect(Target, ActiveSheet.Range(""DynamicTable"" & ""_"" & ActiveSheet.Name)) Is Nothing Then" & vbNewLine
    CodeText = CodeText & "        PopulateTableControl ActiveSheet.Range(""DynamicTable"" & ""_"" & ActiveSheet.Name).ListObject" & vbNewLine
    CodeText = CodeText & "        setLoadedRow Selection.Row - Selection.ListObject.Range.Row" & vbNewLine
    CodeText = CodeText & "    End If" & vbNewLine
    CodeText = CodeText & "End Sub"
    With WorksheetOfDynamicTable.CodeModule
        .AddFromString CodeText
    End With
End Sub

Function TableActiveRow() As Long
    On Error Resume Next
    Dim ActiveTableRow As Long
    TableActiveRow = Selection.row - Selection.ListObject.Range.row
End Function

Sub PopulateTableControl(MyTable As ListObject)
    '#INCLUDE TableActiveRow
    Application.ScreenUpdating = False
    Dim cell As Range
    Dim ws As Worksheet
    Set ws = MyTable.parent
    Dim mapRow As Long
    Dim map As Range
    On Error GoTo eh
    For Each cell In MyTable.ListRows(TableActiveRow).Range
        Set map = Cells(ActiveSheet.Range("MappingRange" & "_" & ActiveSheet.Name).row, cell.Column)
        ws.Range(map.Value).Value = cell.Value
    Next cell
eh:
    Application.ScreenUpdating = True
End Sub

Function WorksheetOfDynamicTable() As VBComponent
    Dim vbProj As VBProject
    Set vbProj = ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).parent.parent.VBProject
    Set WorksheetOfDynamicTable = vbProj.VBComponents(ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).parent.Name)
End Function

Sub CreateControlShapes()
    '#INCLUDE CreateShape
    '#INCLUDE ShapesFill
    '#INCLUDE MoveShapes
    '#INCLUDE TableSave
    '#INCLUDE TableDeleteLoaded
    '#INCLUDE TableDeleteMultiple
    '#INCLUDE InputStartNew
    '#INCLUDE TableReset
    Call CreateShape("InputStartNew", "NEW ENTRY")
    Call CreateShape("TableSave", "SAVE / UPDATE")
    Call CreateShape("TableDeleteLoaded", "DELETE LOADED")
    Call CreateShape("TableDeleteMultiple", "DELETE MULTIPLE")
    Call CreateShape("TableReset", "RESET EVERYTHING")
    Call ShapesFill
    Call MoveShapes
End Sub

Sub CreateShape(OnActionText As String, ShapeText As String)
    '#INCLUDE ShapeFactory
    '#INCLUDE ShapeLeftAfterLastColumn
    Dim LoopShape As Shape
    Dim LastShape As Shape
    Dim ShapesCount As Long
    Dim myShapeControl As Shape
    Select Case ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).parent.Shapes.count
        Case Is = 0
            Call ShapeFactory(OnActionText, _
                              ShapeText, _
                              ShapeLeftAfterLastColumn(ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name)), _
                              ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).top)
        Case Else
            For Each LoopShape In ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).parent.Shapes
                If LoopShape.AutoShapeType = msoShapeRoundedRectangle Then
                    Set LastShape = LoopShape
                    ShapesCount = ShapesCount + 1
                End If
            Next LoopShape
            If ShapesCount = 0 Then
                Call ShapeFactory(OnActionText, _
                                  ShapeText, _
                                  ShapeLeftAfterLastColumn(ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name)), _
                                  ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).top)
            Else
                Call ShapeFactory(OnActionText, _
                                  ShapeText, _
                                  LastShape.left, _
                                  LastShape.top + LastShape.Height + 10)
            End If
    End Select
End Sub

Function ShapeFactory(ShapeOnAction As String, _
                      ShapeText As String, _
                      ShapeLeft As Long, _
                      ShapeTop As Long) _
        As Shape
    Set ShapeFactory = ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).parent.Shapes.AddShape( _
        msoShapeRoundedRectangle, _
        ShapeLeft, _
        ShapeTop, 50, 50)
    '#INCLUDE AddShape
    With ShapeFactory
        .OnAction = ShapeOnAction
        .Fill.BackColor.RGB = vbBlue
        With .ThreeD
            .BevelTopType = msoBevelCircle
            .BevelTopInset = 6
            .BevelTopDepth = 6
        End With
        With .TextFrame
            .Characters.TEXT = ShapeText
            .AutoSize = True
            .HorizontalAlignment = xlHAlignCenter
            .VerticalAlignment = xlVAlignCenter
            .Characters.Font.color = vbWhite
            .Characters.Font.Bold = True
            .Characters.Font.Size = 12
        End With
        .left = ShapeLeft
        .top = ShapeTop
        .Placement = xlFreeFloating
    End With
End Function

Function ShapeLeftAfterLastColumn(rng As Range) As Long
    ShapeLeftAfterLastColumn = rng.OFFSET(0, rng.Columns.count).left + 50
End Function

Sub ShapesFill()
    On Error GoTo 0
    Dim shp As Shape
    For Each shp In ActiveSheet.Shapes
        If shp.AutoShapeType = msoShapeRoundedRectangle Then
            With shp.Fill
                .visible = msoTrue
                .Transparency = 0
                .Solid
                If shp.TextFrame.Characters.TEXT Like "*DELETE*" Then
                    .ForeColor.RGB = RGB(128, 0, 0)
                ElseIf shp.TextFrame.Characters.TEXT Like "*SAVE*" Then
                    .ForeColor.RGB = RGB(0, 128, 0)
                ElseIf shp.TextFrame.Characters.TEXT Like "*RESET*" Then
                    .ForeColor.RGB = vbBlack
                ElseIf shp.TextFrame.Characters.TEXT Like "*NEW*" Then
                    .ForeColor.RGB = RGB(0, 0, 128)
                Else
                    .ForeColor.RGB = RGB(0, 0, 128)
                End If
            End With
        End If
    Next
End Sub

Sub MoveShapes()
    '#INCLUDE LargestShapeWidth
    LargestShapeWidth
    Dim GroupedShapes
    ActiveSheet.Shapes.SelectAll
    Set GroupedShapes = Selection.Group
    GroupedShapes.Name = "ControlGroup" & "_" & ActiveSheet.Name
    ActiveSheet.Shapes("ControlGroup" & "_" & ActiveSheet.Name).Placement = xlFreeFloating
    ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).Cells(1, 1).OFFSET(0, -1).ColumnWidth = _
                                                                                                     ActiveSheet.Shapes("ControlGroup" & "_" & ActiveSheet.Name).Width * 0.2
    ActiveSheet.Shapes("ControlGroup" & "_" & ActiveSheet.Name).left = _
                                                                     ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).Cells(1, 1).OFFSET(0, -1).left + 5
End Sub

Function LargestShapeWidth() As Long
    Dim shp As Shape
    For i = 1 To ActiveSheet.Shapes.count
        If i = 1 Then
            LargestShapeWidth = ActiveSheet.Shapes(i).Width
        ElseIf ActiveSheet.Shapes(i).Width > ActiveSheet.Shapes(i - 1).Width Then
            LargestShapeWidth = ActiveSheet.Shapes(i).Width
        End If
    Next i
    For Each shp In ActiveSheet.Shapes
        shp.Width = LargestShapeWidth
    Next shp
End Function

Sub TableSave()
    '#INCLUDE InputStartNew
    Application.ScreenUpdating = False
    Dim tbl As ListObject
    Set tbl = ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).ListObject
    Dim newRow As ListRow
    Dim RowLoaded As Variant
    RowLoaded = ActiveWorkbook.Names("LoadedRow" & "_" & ActiveSheet.Name)
    If RowLoaded = "=0" Then
        Set newRow = tbl.ListRows.Add
    Else
        Dim numOfNameRow As Long
        numOfNameRow = Mid(RowLoaded, 2)
        Set newRow = tbl.ListRows(numOfNameRow)
    End If
    Dim cell As Range
    For Each cell In newRow.Range
        cell.Value = Range(Cells(ActiveSheet.Range("MappingRange" & "_" & ActiveSheet.Name).row, cell.Column).Value).Value
    Next cell
    Call InputStartNew
    Application.ScreenUpdating = True
End Sub

Sub TableDeleteLoaded()
    '#INCLUDE InputStartNew
    Dim ws As Worksheet
    Set ws = ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).parent
    If ActiveWorkbook.Names("LoadedRow" & "_" & ActiveSheet.Name) = "=0" Then Exit Sub
    Dim tbl As ListObject
    Set tbl = ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).ListObject
    tbl.Range.AutoFilter
    ws.rows.Hidden = False
    tbl.ListRows(Mid(ActiveWorkbook.Names("LoadedRow" & "_" & ActiveSheet.Name), 2)).Delete
    Call InputStartNew
    tbl.Range.AutoFilter
End Sub

Sub TableDeleteMultiple()
    '#INCLUDE TableAutofilterRemove
    '#INCLUDE QuickSort
    '#INCLUDE TableSelectedRows
    '#INCLUDE InputStartNew
    Call TableAutofilterRemove
    Dim arr
    arr = TableSelectedRows
    If IsEmpty(arr) Then Exit Sub
    Call QuickSort(arr)
    Dim i As Long
    For i = UBound(arr) To LBound(arr) Step -1
        ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).ListObject.ListRows(arr(i)).Delete
    Next
    Call InputStartNew
End Sub

Sub TableAutofilterRemove()
    ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).ListObject.Range.AutoFilter
End Sub

Public Sub QuickSort(ByRef SortArray As Variant, Optional lngMin As Long = -1, Optional lngMax As Long = -1)
    '#INCLUDE SortArray
    On Error Resume Next
    Dim i As Long
    Dim j As Long
    Dim varMid As Variant
    Dim varX As Variant
    If IsEmpty(SortArray) Then
        Exit Sub
    End If
    If InStr(TypeName(SortArray), "()") < 1 Then
        Exit Sub
    End If
    If lngMin = -1 Then
        lngMin = LBound(SortArray)
    End If
    If lngMax = -1 Then
        lngMax = UBound(SortArray)
    End If
    If lngMin >= lngMax Then
        Exit Sub
    End If
    i = lngMin
    j = lngMax
    varMid = Empty
    varMid = SortArray((lngMin + lngMax) \ 2)
    If IsObject(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf IsEmpty(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf IsNull(varMid) Then
        i = lngMax
        j = lngMin
    ElseIf varMid = "" Then
        i = lngMax
        j = lngMin
    ElseIf VarType(varMid) = vbError Then
        i = lngMax
        j = lngMin
    ElseIf VarType(varMid) > 17 Then
        i = lngMax
        j = lngMin
    End If
    While i <= j
        While SortArray(i) < varMid And i < lngMax
            i = i + 1
        Wend
        While varMid < SortArray(j) And j > lngMin
            j = j - 1
        Wend
        If i <= j Then
            varX = SortArray(i)
            SortArray(i) = SortArray(j)
            SortArray(j) = varX
            i = i + 1
            j = j - 1
        End If
    Wend
    If (lngMin < j) Then Call QuickSort(SortArray, lngMin, j)
    If (i < lngMax) Then Call QuickSort(SortArray, i, lngMax)
End Sub

Sub TableShowAll()
    ActiveSheet.rows.Hidden = False
End Sub

Function TableSelectedRows() As Variant
    If TypeName(Selection) <> "Range" Then Exit Function
    Dim MyTable As ListObject
    Set MyTable = ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).ListObject
    If Intersect(Selection, MyTable.DataBodyRange) Is Nothing Then Exit Function
    On Error GoTo eh
    Dim arr()
    If Selection.Cells.count = 1 Then
        ReDim Preserve arr(0)
        arr(0) = ActiveCell.row - ActiveCell.ListObject.Range.row
        TableSelectedRows = arr
        Exit Function
    End If
    Dim i As Long
    Dim cell As Range
    Dim SelectedRange As Range
    Set SelectedRange = Selection.SpecialCells(xlCellTypeVisible)
    Dim coll As New Collection
    i = 0
    On Error Resume Next
    For Each cell In SelectedRange
        If Not Intersect(cell, MyTable.DataBodyRange) Is Nothing Then
            coll.Add cell.row - cell.ListObject.Range.row, CStr(cell.row)
            ReDim Preserve arr(i)
            arr(i) = coll(i + 1)
            i = i + 1
        End If
    Next cell
    On Error GoTo 0
    TableSelectedRows = arr
eh:
End Function

Sub InputStartNew()
    '#INCLUDE createNamedRange
    Application.ScreenUpdating = False
    Call createNamedRange("LoadedRow" & "_" & ActiveSheet.Name, _
                          ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).parent, 0)
    ActiveSheet.Range("ControlInputFields" & "_" & ActiveSheet.Name).ClearContents
    ActiveSheet.Range("TableControl" & "_" & ActiveSheet.Name).Cells(1, 2).Select
    Application.ScreenUpdating = True
End Sub

Sub TableReset()
    '#INCLUDE DeleteNames
    '#INCLUDE DeleteShapes
    '#INCLUDE DeleteActiveSheetCodemodule
    Call DeleteActiveSheetCodemodule
    ActiveSheet.Range("DynamicTable" & "_" & ActiveSheet.Name).ListObject.Unlist
    ActiveSheet.Cells.ClearContents
    Call DeleteShapes
    Call DeleteNames
End Sub

Sub DeleteNames()
    Dim xName As Variant
    For Each xName In Array("ControlInputFields" & "_" & ActiveSheet.Name, _
                            "LoadedRow" & "_" & ActiveSheet.Name, _
                            "MappingRange" & "_" & ActiveSheet.Name, _
                            "TableControl" & "_" & ActiveSheet.Name, _
                            "TableHeaderRange" & "_" & ActiveSheet.Name)
        ActiveWorkbook.Names(xName).Delete
    Next xName
End Sub

Sub DeleteShapes()
    Dim shp As Shape
    For Each shp In ActiveSheet.Shapes
        shp.Delete
    Next
End Sub

Sub DeleteActiveSheetCodemodule()
    '#INCLUDE WorksheetOfDynamicTable
    With WorksheetOfDynamicTable.CodeModule
        .DeleteLines 1, .CountOfLines
    End With
End Sub

Sub TableSort(MyTable As ListObject, _
              myKey1 As Range, _
              Optional myKey2 As Range, _
              Optional myKey3 As Range)
    With MyTable.Sort
        .header = xlYes
        .SortFields.clear
        .SortFields.Add key:=myKey1, SortOn:=xlSortOnValues
        If Not myKey2 Is Nothing Then
            .SortFields.Add key:=myKey2, SortOn:=xlSortOnValues
        End If
        If Not myKey3 Is Nothing Then
            .SortFields.Add key:=myKey3, SortOn:=xlSortOnValues
        End If
        .Apply
    End With
End Sub



'uFileManager	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uFileManager
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub CommandButton10_Click()
    OleVbaRun ListboxSelectedValues(ListBox1)
    MsgBox "Done"
End Sub

Private Sub CommandButton11_Click()
    Dim out As New Collection
    Set out = ListboxSelectedValues(ListBox1)
    Dim element
    For Each element In out
        SplitATextFileintoIndividualOnes element
    Next
    MsgBox "Done"
End Sub

Private Sub CommandButton12_Click()
    Dim out As New Collection
    Set out = ListboxSelectedValues(ListBox1)
    Dim element
    For Each element In out
        TxtRemoveComments element
    Next
    MsgBox "Done"
End Sub

Private Sub CommandButton3_Click()
    ListboxToRangeSelect ListBox1
End Sub

Private Sub CommandButton4_Click()
    '    TextBox1.TEXT = ""
    SelectDeselectAll ListBox1, True
End Sub

Private Sub CommandButton5_Click()
    '    TextBox1.TEXT = ""
    SelectDeselectAll ListBox1, False
End Sub

Private Sub CommandButton6_Click()
    Dim out As New Collection
    Set out = ListboxSelectedValues(ListBox1)
    Dim Path As String
    Path = Environ$("USERPROFILE") & "\Documents\vbArc\MergedTXT\"
    FoldersCreate Path
    MergeFileText out, Path & "Merged " & Format(Now, "YY-MM-DD HHNN") & ".txt"
    
    MsgBox "Done"
    FollowLink Path
    
End Sub

Private Sub CommandButton7_Click()
    Dim element As Variant
    For Each element In ListboxSelectedValues(ListBox1)
        PretendListOfContainedProceduresInTXT CStr(element)
    Next
    MsgBox "Done"
End Sub

Private Sub CommandButton8_Click()
    Dim out As New Collection
    Set out = ListboxSelectedValues(ListBox1)
    Dim element
    For Each element In out
        TxtRemoveBlankLines element
    Next
    MsgBox "Done"
End Sub

Private Sub CommandButton9_Click()

End Sub

Private Sub ListViewControl_OLEDragDrop(Data As MSComctlLib.DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
    Dim dbBefore As Long: dbBefore = ListBox1.ListCount
    Dim FileFullPath As String
    Dim fileItem As Long
    Dim objFSO As Scripting.FileSystemObject
    Dim objTopFolder As Scripting.Folder
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Dim var As Variant, element As Variant
    For fileItem = 1 To Data.Files.count
        FileFullPath = Data.Files(fileItem)
        If oLogFiles = True Then
            If LCase(isFDU(FileFullPath)) = "f" Then
                var = Split(TextBox2.TEXT, ",")
                On Error Resume Next
                If left(Mid(FileFullPath, InStrRev(FileFullPath, "\") + 1), 1) <> "~" And (var(0) = "*" Or var(0) = "") Then GoTo PASS
                For Each element In var
                    If InStr(1, FileFullPath, element, vbTextCompare) > 0 And left(Mid(FileFullPath, InStrRev(FileFullPath, "\") + 1), 1) <> "~" Then
PASS:
                        If ListboxContains(ListBox1, FileFullPath) = False Then
                            AddToListBox ListBox1, FileFullPath
                        End If
                    End If
                Next
            Else        'if drag dropped folder
                Set objTopFolder = objFSO.getFolder(FileFullPath)
                FileRecursive objTopFolder, oSearchInSubfolders.Value
            End If
        End If
        If oLogFolders = True Then
            If UCase(isFDU(FileFullPath)) = "D" Then
                Set objTopFolder = objFSO.getFolder(FileFullPath)
                If ListboxContains(ListBox1, objTopFolder.Path & "\") = False Then
                    AddToListBox ListBox1, objTopFolder.Path
                End If
                FolderRecursive objTopFolder, oSearchInSubfolders.Value
            End If
        End If
    Next fileItem
    
    If ListBox1.ListCount - dbBefore > 0 Then ListboxToDatabaseSheet
    
    Set objFSO = Nothing
    Set objTopFolder = Nothing
End Sub

Private Sub ListboxToDatabaseSheet()
    Dim rng As Range
    Set rng = ThisWorkbook.SHEETS("FileManager_DB").Range("A1")
    rng.CurrentRegion.Cells.clear
    ListboxToRange ListBox1, rng
End Sub

Sub AddToListBox(lBox As MSForms.ListBox, FileOrFolderPath As String)
    If UCase(isFDU(FileOrFolderPath)) = "F" Then
        lBox.AddItem
        lBox.list(ListBox1.ListCount - 1, 0) = Mid(FileOrFolderPath, InStrRev(FileOrFolderPath, "\") + 1)
        lBox.list(ListBox1.ListCount - 1, 1) = FileOrFolderPath
    Else
        lBox.AddItem
        lBox.list(ListBox1.ListCount - 1, 0) = UCase(Mid(FileOrFolderPath, InStrRev(FileOrFolderPath, "\") + 1)) & "\"
        lBox.list(ListBox1.ListCount - 1, 1) = FileOrFolderPath
    End If
End Sub

Private Function FileRecursive(objFolder As Scripting.Folder, IncludeSubFolders As Boolean)
    Dim objFile As Scripting.file
    Dim objSubFolder As Scripting.Folder
    Dim var As Variant
    Dim element As Variant
    Dim FileFullPath As String
    For Each objFile In objFolder.Files
        FileFullPath = objFile.Path
        'If objFile.DateCreated > Range("afterdate") Then
        var = Split(TextBox2.TEXT, ",")
        On Error Resume Next
        If left(Mid(FileFullPath, InStrRev(FileFullPath, "\") + 1), 1) <> "~" And (var(0) = "*" Or var(0) = "") Then GoTo PASS
        For Each element In var
            If InStr(1, FileFullPath, element) > 0 And left(Mid(FileFullPath, InStrRev(FileFullPath, "\") + 1), 1) <> "~" Then
PASS:
                If ListboxContains(ListBox1, FileFullPath) = False Then
                    AddToListBox ListBox1, FileFullPath
                End If
            End If
        Next
    Next objFile
    If IncludeSubFolders Then
        For Each objSubFolder In objFolder.SubFolders
            Call FileRecursive(objSubFolder, True)
        Next objSubFolder
    End If
End Function

Private Function FolderRecursive(objFolder As Scripting.Folder, IncludeSubFolders As Boolean)
 
    Dim objSubFolder As Scripting.Folder
    Dim var As Variant
    Dim element As Variant
    Dim FileFullPath As String

    For Each objSubFolder In objFolder.SubFolders
        FileFullPath = objSubFolder.Path
        var = Split(TextBox2.TEXT, ",")
        On Error Resume Next
        If left(Mid(FileFullPath, InStrRev(FileFullPath, "\") + 1), 1) <> "~" And (var(0) = "*" Or var(0) = "") Then GoTo PASS
        For Each element In var
            If InStr(1, FileFullPath, element) > 0 And left(Mid(FileFullPath, InStrRev(FileFullPath, "\") + 1), 1) <> "~" Then
PASS:
                If ListboxContains(ListBox1, FileFullPath & "\") = False Then
                    AddToListBox ListBox1, FileFullPath
                End If
            End If
        Next
    Next objSubFolder
    If IncludeSubFolders Then
        For Each objSubFolder In objFolder.SubFolders
            Call FolderRecursive(objSubFolder, True)
        Next objSubFolder
    End If
End Function

Private Sub TextBox1_Change()
    '    SelectControItemsByFilter ListBox1, TextBox1.TEXT
    LoadListbox
    FilterListboxByColumn ListBox1, TextBox1.TEXT, 0
End Sub

Private Sub UserForm_Activate()
    ResizeUserformToFitControls Me
End Sub

Private Sub UserForm_Initialize()
    '    MakeFormChildOfNothing
    '    UserformOnTop Me
    LoadListbox
End Sub

Private Sub LoadListbox()
    ListBox1.clear
    Dim rng As Range
    Set rng = ThisWorkbook.SHEETS("FileManager_DB").Range("A1")
    If rng.Value = "" Then Exit Sub
    Dim var As Variant
    var = rng.CurrentRegion
    ListBox1.list = var
End Sub

Private Sub CommandButton1_Click()
    Dim element As Variant
    For Each element In ListboxSelectedValues(ListBox1)
        If CStr(element) Like "*.zip" Then
            UnzipToOwnFolder CStr(element), oDeleteExistingFolder, oDeleteZip
        End If
    Next
    MsgBox "Done"
End Sub

Private Sub CommandButton2_Click()
    RemoveItems
End Sub

Private Sub RemoveItems()
    Dim i As Long
    Dim rng As Range

    For i = ListBox1.ListCount - 1 To 0 Step -1
        Dim lookInRng As Range
        Set lookInRng = ThisWorkbook.SHEETS("FileManager_DB").Columns(1)
        If ListBox1.SELECTED(i) = True Then
            If rng Is Nothing Then
                Set rng = lookInRng.Find(ListBox1.list(i), LookIn:=xlValues)
            Else
                Set rng = Union(rng, lookInRng.Find(ListBox1.list(i), LookIn:=xlValues))
            End If
            ListBox1.RemoveItem (i)
        End If
    Next i
    rng.EntireRow.Delete
End Sub

Sub RemoveSelectedFromListbox(lBox As MSForms.ListBox)
    Dim i As Long
    Dim coll As New Collection
    Set coll = ListboxSelectedIndexes(lBox)
    For i = coll.count To 1 Step -1
        lBox.RemoveItem coll(i)
    Next
End Sub

Private Sub info_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Rem file convert
Private Sub oExcelFiles_Click()
    WordOutput.visible = False
    ExcelOutput.visible = True
End Sub

Private Sub oWordFiles_Click()
    WordOutput.visible = True
    WordOutput.left = fFileType.left
    ExcelOutput.visible = False
End Sub

Private Sub Convert_Click()
    Dim element As Variant
    For Each element In ListboxSelectedValues(ListBox1)
        UnzipToOwnFolder CStr(element), oDeleteExistingFolder, oDeleteZip
    Next
End Sub

Sub convertFile(vPath As String)
    If oExcelFiles.Value = True Then
        If vPath Like "*.xl*" Then
            Select Case UCase(whichOption(Me.ExcelOutput, "OptionButton").Caption)
                Case "XLSB"
                    XLS_ConvertFileFormat vPath, xlExcel12, Me.oDelete
                Case "XLSM"
                    XLS_ConvertFileFormat vPath, xlOpenXMLWorkbookMacroEnabled, Me.oDelete
                Case "XLSX"
                    XLS_ConvertFileFormat vPath, xlWorkbookDefault, Me.oDelete
                Case "CSV"
                    XLS_ConvertFileFormat vPath, xlCSV, Me.oDelete
                Case "XLAM"
                    XLS_ConvertFileFormat vPath, xlOpenXMLAddIn, Me.oDelete
                Case "PDF"
                    ExcelToPDF vPath, cSeparateSheets.Value, True
            End Select
        End If
    Else
        If vPath Like "*.doc*" Then
            Select Case whichOption(Me.WordOutput, "OptionButton").Caption
                Case "DOCX"
                    Word_ConvertFileFormat vPath, wdFormatDocumentDefault, Me.oDelete
                Case "TXT"
                    Word_ConvertFileFormat vPath, wdFormatText, Me.oDelete
                Case "DOCM"
                    Word_ConvertFileFormat vPath, wdFormatXMLDocumentMacroEnabled, Me.oDelete
                Case "PDF"
                    Word_ConvertFileFormat vPath, wdFormatPDF, Me.oDelete
            End Select
        End If
    End If
End Sub


'Sheet12	100



'uSessions	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uSessions
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Function GetOpenFolders() As Collection
    Dim coll As Collection
    Set coll = New Collection
    Dim oShell As Object
    Dim Wnd As Object
    Set oShell = CreateObject("Shell.Application")
    For Each Wnd In oShell.Windows
        If Wnd.Name = "File Explorer" Then
            Debug.Print Wnd.document.Folder.Self.Path
            coll.Add Wnd.document.Folder.Self.Path
        End If
    Next Wnd
    Set GetOpenFolders = coll
    Set coll = Nothing
End Function

Private Sub chIncludeWorkbooks_Click()
    If chIncludeWorkbooks.Value = True Then
        chClose.visible = True
        chClose.Value = False
    Else
        chClose.visible = False
        chClose.Value = False
    End If
End Sub

Private Sub cInfo_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub UserForm_Initialize()
    cbSessionName.AddItem "LAST SESSION"
    cbSessionName.ListIndex = -1
    cbSessionName.TEXT = "<SESSION NAME>"
    PopulateSessions
End Sub

Private Sub cDELETE_Click()
    If LSessions.list(LSessions.ListIndex) = "LAST SESSION" Then
        MsgBox "You can overwrite Last Session but not delete it"
    Else
        SessionDelete
    End If
    ThisWorkbook.Save
End Sub

Private Sub cDeleteItems_Click()
    RemoveItemFromSessionBooks
End Sub

Private Sub cLOAD_Click()
    If LSessions.ListIndex = -1 Then Exit Sub
    SessionOpen
End Sub

Private Sub cSAVE_Click()
    Dim newSessionName As String
    newSessionName = cbSessionName.TEXT
    If newSessionName = vbNullString Or newSessionName = "<SESSION NAME>" Then cbSessionName.ListIndex = 0
    SessionSave
    ThisWorkbook.Save
End Sub

Private Sub LSessions_Click()
    PopulateSessionBooks
    cbSessionName.TEXT = LSessions.list(LSessions.ListIndex)
End Sub

Sub RemoveItemFromSessionBooks()
    Dim r As Long, c As Long
    Dim i As Long
    c = ThisWorkbook.SHEETS("uSessions").rows(1).Find(uSessions.LSessions.list(uSessions.LSessions.ListIndex), LookAt:=xlWhole).Column
    For r = uSessions.LSessionBooks.ListCount - 1 To 0 Step -1
        If uSessions.LSessionBooks.SELECTED(r) Then
            ThisWorkbook.SHEETS("uSessions").Cells(r + 2, c).Delete Shift:=xlUp
            uSessions.LSessionBooks.RemoveItem r
        End If
    Next r
    ThisWorkbook.Save
End Sub

Sub SessionSave()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("uSessions")
    Dim foundRange As Range
    Dim listCol As Long
    Set foundRange = ws.rows(1).Find(uSessions.cbSessionName.TEXT, LookAt:=xlWhole)
    If foundRange Is Nothing Then
        listCol = ws.Cells(1, 1).CurrentRegion.Columns.count + 1
        ws.Cells(1, listCol).Value = uSessions.cbSessionName.TEXT
    Else
        listCol = foundRange.Column
        If Application.WorksheetFunction.CountA(ws.Columns(listCol)) > 1 Then
            Dim LastRow As Long
            LastRow = ws.Cells(rows.count, listCol).End(xlUp).row
            ws.Range(ws.Cells(2, listCol), ws.Cells(LastRow, listCol)).ClearContents
        End If
    End If
    Dim RowNum As Long
    RowNum = 1
    Dim counterFolders As Long
    Dim counterFiles As Long
    If chIncludeWorkbooks.Value = True Then
        Dim wbO As Workbook
        For Each wbO In Application.Workbooks
            counterFiles = counterFiles + 1
            RowNum = RowNum + 1
            ws.Cells(RowNum, listCol).Value = wbO.FullName
            If uSessions.chClose.Value = True Then
                If wbO.Name <> ActiveWorkbook.Name Then
                    wbO.Close savechanges:=True
                End If
            End If
        Next wbO
    End If
    If uSessions.chIncludeFolders.Value = True Then
        Dim element As Variant
        For Each element In GetOpenFolders
            counterFolders = counterFolders + 1
            RowNum = RowNum + 1
            ws.Cells(RowNum, listCol).Value = element
        Next element
    End If
    If counterFiles + counterFolders > 0 Then
        If uSessions.cbSessionName.TEXT <> "LAST SESSION" Then
            uSessions.LSessions.AddItem uSessions.cbSessionName.TEXT
        End If
        If uSessions.LSessions.ListCount = 1 Then
            uSessions.LSessions.ListIndex = -1
            uSessions.LSessions.ListIndex = 0
        End If
        MsgPOP "Session " & UCase(uSessions.cbSessionName.TEXT) & " saved with" & vbNewLine & _
                                                                counterFiles & " Workbooks and " & counterFolders & " Folders", 2
    Else
        MsgPOP "Only folders option: No open folders found"
    End If
End Sub

Sub SessionOpen()
    Dim element As Variant
    If ListboxSelectedCount(uSessions.LSessionBooks) = 0 Then
        Dim i As Long
        For i = 0 To uSessions.LSessionBooks.ListCount - 1
            FollowLink (uSessions.LSessionBooks.list(i))
        Next i
    Else
        For Each element In ListboxSelectedValues(uSessions.LSessionBooks)
            FollowLink (element)
        Next element
    End If
    ThisWorkbook.Activate
    MsgPOP "Selected session items loaded"
End Sub

Sub SessionDelete()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("uSessions")
    Dim foundRange As Range
    Set foundRange = ws.rows(1).Find(uSessions.cbSessionName.TEXT, LookAt:=xlWhole)
    foundRange.EntireColumn.Delete
    uSessions.LSessions.RemoveItem (uSessions.LSessions.ListIndex)
    MsgPOP "Session " & UCase(uSessions.cbSessionName.TEXT) & " deleted"
End Sub

Sub PopulateSessions()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("uSessions")
    Dim listCol As Long
    For listCol = 1 To ws.Cells(1, 1).CurrentRegion.Columns.count
        uSessions.LSessions.AddItem ws.Cells(1, listCol).TEXT
    Next listCol
End Sub

Sub PopulateSessionBooks()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.SHEETS("uSessions")
    Dim foundRange As Range
    Dim listCol As Long
    Set foundRange = ws.rows(1).Find(uSessions.LSessions.list(uSessions.LSessions.ListIndex), LookAt:=xlWhole)
    listCol = foundRange.Column
    Dim i As Long
    Dim LastRow As Long
    LastRow = ws.Cells(ws.rows.count, listCol).End(xlUp).row
    uSessions.LSessionBooks.clear
    For i = 2 To LastRow
        uSessions.LSessionBooks.AddItem ws.Cells(i, listCol).Value
    Next i
End Sub



'M_UserformFrameMenu	1

Rem @Folder UserformFrameMenu
Rem -----------------------------------
Rem Put in userform:
Rem -----------------------------------
Rem Private WithEvents Emitter As EventListenerEmitter
Rem
Rem Sub startFrameForm(FORM As Object)
Rem     Dim anc As MSForms.Control
Rem
Rem     For Each c In FORM.Controls
Rem         If TypeName(c) = "Frame" Then
Rem             rem c.Caption = ""
Rem             If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
Rem                 c.Visible = False
Rem                 If InStr(1, c.Tag, "anchor") > 0 Then
Rem                     On Error Resume Next
Rem                     Set anc = Me.Controls(c.Tag)
Rem                     If anc Is Nothing Then Stop
Rem                     On Error GoTo 0
Rem                     c.top = anc.top rem Anchor01.Top
Rem                     c.left = anc.left rem  Anchor01.Left
Rem                     Set anc = Nothing
Rem                 End If
Rem             End If
Rem         End If
Rem     Next
Rem     Set Emitter = New EventListenerEmitter
Rem     Emitter.AddEventListenerAll Me
Rem End Sub
Rem
Rem Private Sub Emitter_LabelMouseOut(Label As MSForms.Label)
Rem     If InStr(1, Label.Tag, "reframe", vbTextCompare) > 0 Then
Rem         If Label.BackColor <> &H80B91E Then Label.BackColor = &H534848
Rem     End If
Rem End Sub
Rem
Rem Private Sub Emitter_LabelMouseOver(Label As MSForms.Label)
Rem     If InStr(1, Label.Tag, "reframe", vbTextCompare) > 0 Then
Rem         If Label.BackColor <> &H80B91E Then Label.BackColor = &H808080
Rem     End If
Rem End Sub
Rem
Rem Sub Emitter_LabelClick(ByRef Label As MSForms.Label)
Rem     If InStr(1, Label.Tag, "reframe", vbTextCompare) > 0 Then Reframe Me, Label
Rem End Sub
Rem

Rem Private Sub UserForm_Initialize()
Rem     startFrameForm Me
Rem End Sub
Sub addFrameFormCode(Module As VBComponent)
    '#INCLUDE CopyTemplateFromSheet
    '#INCLUDE dp
    '#INCLUDE Reframe
    '#INCLUDE GetModuleText
    '#INCLUDE CLIP
    If Module.Type <> vbext_ct_MSForm Then
        MsgBox "This is intended for a userform"
        Exit Sub
    End If
    Dim s As String
    s = CopyTemplateFromSheet("FrameForm")
    If InStr(1, GetModuleText(Module), Module.Name & "_Initialize") Then
        MsgBox "Threre is already _Initialize_ code in this form. Code will be put in cilpboard and immediate window."
        dp s
        CLIP s
    Else
        Module.CodeModule.AddFromString s
    End If
End Sub

Sub CreateFrameMenu(Optional Module As Object)
    '#INCLUDE SelectedControl
    '#INCLUDE SelectedControls
    '#INCLUDE ActiveModule
    '#INCLUDE addFrameSidebar
    If ActiveModule.Type <> vbext_ct_MSForm Then Exit Sub
    If SelectedControls.count = 0 Then
        ActiveModule.Designer.BackColor = 4208182
        addFrameSidebar ActiveModule
    Else
        addFrameSidebar SelectedControl
    End If
End Sub

Sub addFrameSidebar(form As Object, Optional dockRight As Boolean)
    '#INCLUDE askFormMenuElements
    '#INCLUDE UnderlineFrameName
    '#INCLUDE CreateOrSetFrame
    Dim f As MSForms.control
    Dim l As MSForms.control
    Set f = CreateOrSetFrame(form, "SideBar" & form.Name)
    f.Tag = "skip"
    f.BackColor = 5457992
    f.ForeColor = vbWhite
    f.BorderStyle = 1
    f.BorderStyle = 0
    f.Width = 80
    If TypeName(form) = "VBComponent" Then
        f.Height = 800
    Else
        f.Height = form.Height
    End If
    dockRight = IIf(TypeName(form) = "VBComponent", False, True)
    If dockRight = True Then
        f.left = form.Width - f.Width
    Else
        f.left = 0
    End If
    UnderlineFrameName form, f
    If TypeName(form) = "VBComponent" Then
        Set l = form.Designer.Controls.Add(ControlIDLabel, "Anchor" & form.Name)
    Else
        Set l = form.Controls.Add(ControlIDLabel, "Anchor" & form.Name)
    End If
    l.visible = False
    l.left = IIf(TypeName(form) = "VBComponent", f.left + f.Width + 9, 1)
    l.top = 12
    l.Width = 1
    l.BackColor = vbWhite
    l.visible = False
    askFormMenuElements form
End Sub

Sub askFormMenuElements(form As Object)
    '#INCLUDE InputboxString
    '#INCLUDE addFrameMenu
    Dim FormElements As String
    FormElements = InputboxString("Form Menus", "Type comma delimited menu names")
    If FormElements = "" Then Exit Sub
    Dim var
    var = Split(FormElements, ",")
    Dim i As Long
    For i = LBound(var) To UBound(var)
        var(i) = Trim(var(i))
    Next
    Dim coll As New Collection
    Dim element
    On Error Resume Next
    For Each element In var
        If Not IsNumeric(left(element, 1)) _
        And InStr(1, element, " ") = 0 Then
            coll.Add CStr(element), CStr(element)
        End If
    Next
    On Error GoTo 0
    For Each element In coll
        addFrameMenu form, CStr(element)
    Next
End Sub

Sub addFrameMenu(form As Object, FrameCaptionNoSpace As String)
    '#INCLUDE Reframe
    '#INCLUDE UnderlineFrameName
    '#INCLUDE CreateOrSetFrame
    '#INCLUDE AvailableFormOrFrameRow
    '#INCLUDE AvailableFormOrFrameColumn
    Dim f As MSForms.control
    Dim l As MSForms.control
    Dim Module As VBComponent
    If TypeName(form) = "VBComponent" Then
        Set Module = form
        Set f = Module.Designer.Controls.Add(ControlIDFrame, FrameCaptionNoSpace)
    Else
        Set Module = ThisWorkbook.VBProject.VBComponents(form.parent.Name)
        Set f = CreateOrSetFrame(Module.Designer.Controls(form.Name), FrameCaptionNoSpace)
    End If
    f.Tag = "anchor" & form.Name
    f.Caption = FrameCaptionNoSpace
    f.ForeColor = vbWhite
    f.visible = False
    If TypeName(form) = "VBComponent" Then
        f.left = AvailableFormOrFrameColumn(form.Designer)
    Else
        f.left = 0
    End If
    f.visible = True
    f.BorderStyle = 1
    f.BorderStyle = 0
    f.top = 12
    f.Width = 100
    UnderlineFrameName form, f
    If TypeName(form) = "VBComponent" Then
        Set l = Module.Designer.Controls("SideBar" & form.Name).Controls.Add(ControlIDLabel)
    Else
        Set l = Module.Designer.Controls("SideBar" & form.Name).Add(ControlIDLabel)
    End If
    l.Caption = FrameCaptionNoSpace
    l.ForeColor = vbWhite
    l.visible = False
    l.top = AvailableFormOrFrameRow(Module.Designer.Controls("SideBar" & form.Name))
    l.left = l.left + 3
    l.visible = True
    l.Tag = "reframe"
    l.Width = f.Width
End Sub

Sub AddControlsToFrame(isSubFrame As Boolean)
    '#INCLUDE SelectedControl
    '#INCLUDE SelectedControls
    '#INCLUDE SelectedFrameControl
    '#INCLUDE ActiveModule
    '#INCLUDE InputboxString
    If ActiveModule.Type <> vbext_ct_MSForm Then Exit Sub
    If SelectedControls.count <> 1 Then Exit Sub
    If TypeName(SelectedControl) <> "Frame" Then Exit Sub
    Dim Module As VBComponent
    Dim TargetFrame As MSForms.control
    If isSubFrame = False Then
        Set TargetFrame = SelectedControl
        Set Module = ActiveModule
    Else
        Set TargetFrame = SelectedFrameControl
        Set Module = ThisWorkbook.VBProject.VBComponents(TargetFrame.parent.parent.Name)
    End If
    Dim ControlNames As String
    ControlNames = InputboxString("Form Menus", "Type comma delimited menu names")
    If ControlNames = "" Then Exit Sub
    Dim var
    var = Split(ControlNames, ",")
    Dim i As Long
    For i = LBound(var) To UBound(var)
        var(i) = Trim(var(i))
    Next
    Dim coll As New Collection
    Dim element
    On Error Resume Next
    For Each element In var
        If Not IsNumeric(left(element, 1)) _
        And InStr(1, element, " ") = 0 Then
            coll.Add CStr(element), CStr(element)
        End If
    Next
    On Error GoTo 0
    Dim l As MSForms.control
    For Each element In coll
        Set l = Module.Designer.Controls(TargetFrame.Name).Controls.Add(ControlIDCommandButton, element)
        l.top = 7 + ((TargetFrame.Controls.count - 1) * l.Height)
        l.BackColor = vbWhite
    Next
End Sub

Sub UnderlineFrameName(form As Object, f As MSForms.control)
    If TypeName(form) = "VBComponent" Then
        Set Module = form
    Else
        Set Module = ThisWorkbook.VBProject.VBComponents(form.parent.Name)
    End If
    Set l = Module.Designer.Controls(f.Name).Controls.Add(ControlIDLabel)
    l.top = 6
    l.Height = 1
    l.Width = 100
    l.BackColor = vbWhite
    l.Tag = "skip"
End Sub



'M_UserformAnimations	1

Rem @Folder UserformAnimations Declarations
Rem Author:Todar
Option Explicit
Option Compare Text
Option Private Module

#If VBA7 And Win64 Then
    Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
    Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If
#If VBA7 Then

    Private Declare PtrSafe Function getFrequency Lib "kernel32" Alias "QueryPerformanceFrequency" (cyFrequency As Currency) As Long
    Private Declare PtrSafe Function getTickCount Lib "kernel32" Alias "QueryPerformanceCounter" (cyTickCount As Currency) As Long
#Else
    Private Declare Function getFrequency Lib "kernel32" Alias "QueryPerformanceFrequency" (cyFrequency As Currency) As Long
    Private Declare Function getTickCount Lib "kernel32" Alias "QueryPerformanceCounter" (cyTickCount As Currency) As Long
#End If
Rem Effect(box, "Top", Me.InsideHeight - box.Height, 1000) _
, Effect(box2, "Top", 0, 100) _
, Effect(GoButton, "fontsize", 12, 1000) _
, Effect(Me, "Top", 20, 2000)

Rem @Folder UserformAnimations
Public Sub Transition(ParamArray Elements() As Variant)
    '#INCLUDE MicroTimer
    '#INCLUDE AllTransitionsComplete
    '#INCLUDE IncrementElement
    If IsArray(Elements(LBound(Elements, 1))) Then
        Dim temp As Variant
        temp = Elements(LBound(Elements, 1))
        Elements = temp
    End If
    Dim form As MSForms.UserForm
    Set form = Elements(LBound(Elements, 1))("form")
    MicroTimer True
    Do
        Dim index As Integer
        For index = LBound(Elements, 1) To UBound(Elements, 1)
            IncrementElement Elements(index), MicroTimer
        Next index
        Sleep 40
        form.Repaint
    Loop Until AllTransitionsComplete(CVar(Elements))
End Sub

Public Function Effect(obj As Object, property As String, Destination As Double, MilSecs As Double) As Scripting.Dictionary
    Dim temp As New Scripting.Dictionary
    Set temp("obj") = obj
    temp("property") = property
    temp("startValue") = CallByName(obj, property, VbGet)
    temp("destination") = Destination
    temp("travel") = Destination - temp("startValue")
    temp("milSec") = MilSecs
    temp("complete") = False
    On Error GoTo catch:
    Set temp("form") = obj.parent
    Set Effect = temp
    Exit Function
catch:
    Set temp("form") = obj
    Resume Next
End Function

Public Function MicroTimer(Optional StartTime As Boolean = False) As Double
    Static dTime As Double
    Dim cyTicks1 As Currency
    Dim cyTicks2 As Currency
    Static cyFrequency As Currency
    MicroTimer = 0
    If cyFrequency = 0 Then getFrequency cyFrequency
    getTickCount cyTicks1
    getTickCount cyTicks2
    If cyTicks2 < cyTicks1 Then cyTicks2 = cyTicks1
    If cyFrequency Then MicroTimer = cyTicks2 / cyFrequency
    If StartTime = True Then
        dTime = MicroTimer
        MicroTimer = 0
    Else
        MicroTimer = (MicroTimer - dTime) * 1000
    End If
End Function

Private Function AllTransitionsComplete(Elements As Variant) As Boolean
    '#INCLUDE TransitionComplete
    Dim el As Object
    Dim index As Integer
    For index = LBound(Elements, 1) To UBound(Elements, 1)
        Set el = Elements(index)
        If Not TransitionComplete(el) Then
            AllTransitionsComplete = False
            Exit Function
        End If
    Next index
    AllTransitionsComplete = True
End Function

Private Function TransitionComplete(ByVal el As Scripting.Dictionary) As Boolean
    If Math.Round(el("destination")) = Math.Round(CallByName(el("obj"), el("property"), VbGet)) Then
        TransitionComplete = True
    End If
End Function

Private Function IncrementElement(ByVal el As Scripting.Dictionary, CurrentTime As Double) As Boolean
    '#INCLUDE TransitionComplete
    '#INCLUDE easeInAndOut
    Dim IncrementValue As Double
    Dim CurrentValue As Double
    If TransitionComplete(el) Then
        Exit Function
    End If
    Dim o As Object
    Dim p As String
    Dim Value As Double
    Dim d As Double
    IncrementValue = easeInAndOut(CurrentTime, el("startValue"), el("travel"), el("milSec"))
    If el("travel") < 0 Then
        If Math.Round(IncrementValue, 4) < el("destination") Then
            CallByName el("obj"), el("property"), VbLet, el("destination")
        Else
            CallByName el("obj"), el("property"), VbLet, IncrementValue
        End If
    Else
        If Math.Round(IncrementValue, 4) > el("destination") Then
            CallByName el("obj"), el("property"), VbLet, el("destination")
        Else
            CallByName el("obj"), el("property"), VbLet, IncrementValue
        End If
    End If
End Function

Private Function easeInAndOut(ByVal t As Double, ByVal b As Double, ByVal c As Double, ByVal d As Double) As Double
    d = d / 2
    t = t / d
    If (t < 1) Then
        easeInAndOut = c / 2 * t * t * t + b
    Else
        t = t - 2
        easeInAndOut = c / 2 * (t * t * t + 2) + b
    End If
End Function



'U_Answers	1


Rem @Folder GetAnswers Declarations
Rem
Rem /*
Rem     Public Function answer( _
rem                             Optional AT As AnswerType = 999, _
rem                             Optional ExtraOptions As Variant, _
rem                             Optional ExtraOptionsPerColumn As Long = 999, _
rem                             Optional extraOptionsFramesVertical As Boolean = True, _
rem                             Optional Caption As String, _
rem                             optional AskInVBE as boolean) _
rem                                                         As Variant
Rem */
Rem /*
Rem If AnswerType=999 then show all AT options
Rem If AnswerType=0 then hide all AT options
Rem If you want to show only specific AT options use it like: call uAnswer.answer (argTrueFalse + argYesNo)
Rem */
Rem /*
Rem If you allow only one option then after you call uanswer.anser you can do
Rem
Rem dim myRespone
Rem     myResponse=SelectedOptionsCollection(1)
Rem If myRespone = ...
Rem
Rem Otherwise you can call uanswer.anser and loop all answers: For Each element In SelectedOptionsCollection
    Rem */
    Rem AskInVBE=True will show the userform in VBE window, no need to go back and forth to sheet
    Rem /*
    Rem ExtraOptions is passed as Array(ControlID1,Array(choice1,choice2...),ControlID2,Array(choiceX,choiceY...)
    Rem */
    Rem
    Public SelectedOptionsCollection As Collection

    Rem @Folder GetAnswers
Sub TestGetAnswer()
    '#INCLUDE PrintSelectedOptions
    Dim element
    Call uAnswer.answer(argInput, , , , , True)
    Debug.Print "You said: "
    PrintSelectedOptions
    Stop
    uAnswer.answer argDate, , , , "select start date"
    Debug.Print "Start date: "
    PrintSelectedOptions
    Stop
    Call uAnswer.answer(, Array(ControlIDToggleButton, Array(1, 2, 3, 4)), 2)
    Debug.Print "You selected toggles:"
    PrintSelectedOptions
    Stop
    Call uAnswer.answer(0, Array(ControlIDOptionButton, Array(1, 2, 3, 4), _
                                 ControlIDCheckBox, Array(5, 6, 7, 8), _
                                 ControlIDToggleButton, Array("a", "b", "c", "d")), _
                        2, False)
    PrintSelectedOptions
End Sub

Sub PrintSelectedOptions()
    If TypeName(SelectedOptionsCollection) <> "Nothing" Then
        If SelectedOptionsCollection.count > 0 Then
            For Each element In SelectedOptionsCollection: Debug.Print element: Next
        End If
    End If
End Sub

Sub GetSelectedOptions(Frame As Variant)
    Dim ctr As MSForms.control
    Dim out As New Collection
    For Each ctr In Frame.Controls
        If ctr.visible = True Then
            Select Case UCase(TypeName(ctr))
                Case UCase("CheckBox"), UCase("OptionButton"), UCase("ToggleButton")
                    If ctr.Value = True Then
                        If ctr.Name = "oInput" Then
                            SelectedOptionsCollection.Add Frame.Controls("Textbox1").Value
                        Else
                            SelectedOptionsCollection.Add ctr.Caption
                        End If
                    End If
            End Select
        End If
    Next
End Sub

Function CreateOrSetFrame(form As Object, Optional FrameName As String, Optional LTWH As Variant) As MSForms.Frame
    Dim cFrame As MSForms.Frame
    On Error Resume Next
    Set cFrame = form.Controls(FrameName)
    On Error GoTo 0
    If cFrame Is Nothing Then
        If TypeName(form) = "VBComponent" Then
            Set cFrame = form.Designer.Controls.Add("Forms.Frame.1")
        Else
            Set cFrame = form.Controls.Add("Forms.Frame.1")
        End If
    End If
    If Not IsMissing(FrameName) Then cFrame.Name = FrameName
    If Not IsMissing(LTWH) Then
        cFrame.left = LTWH(0)
        cFrame.top = LTWH(1)
        cFrame.Width = LTWH(2)
        cFrame.Height = LTWH(3)
    End If
    Set CreateOrSetFrame = cFrame
End Function

Function AvailableFormOrFrameRow(FormOrFrame As Object, Optional AfterWidth As Long = 0, Optional AfterHeight As Long = 0) As Long
    Dim ctr As MSForms.control
    Dim myHeight
    For Each ctr In FormOrFrame.Controls
        If ctr.visible = True Then
            If ctr.left >= AfterWidth And ctr.top >= AfterHeight Then
                If ctr.top + ctr.Height > myHeight Then myHeight = ctr.top + ctr.Height
            End If
        End If
    Next
    AvailableFormOrFrameRow = myHeight + 6
End Function

Function AvailableFormOrFrameColumn(FormOrFrame As Object, Optional AfterWidth As Long = 0, Optional AfterHeight As Long = 0) As Long
    Dim ctr As MSForms.control
    Dim myWidth
    For Each ctr In FormOrFrame.Controls
        If ctr.visible = True Then
            If ctr.left >= AfterWidth And ctr.top >= AfterHeight Then
                If ctr.left + ctr.Width > myWidth Then myWidth = ctr.left + ctr.Width
            End If
        End If
    Next
    AvailableFormOrFrameColumn = myWidth + 6
End Function



'uAnswer	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uAnswer
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Rem @TODO replace old calendar method with new calendar uDatePicker
Rem         for new arguments StartDate and EndDate

Dim columnControls As Long
Dim ExtraOptionColumn As Long
Dim ExtraOptionRow As Long
Dim ctrType As String
Dim optionCaption As String
Dim c As MSForms.control
Dim cFrame As MSForms.Frame
Dim FrameControlColumn As Long
Dim FrameControlRow As Long
Dim cFrameTop As Long
Dim cFrameLeft As Long
Dim PreviousRow As Long

Private WithEvents Calendar1 As cCalendar
Private ans As Variant
Const ControlIDCheckBox = "Forms.CheckBox.1"
Const ControlIDComboBox = "Forms.ComboBox.1"
Const ControlIDCommandButton = "Forms.CommandButton.1"
Const ControlIDFrame = "Forms.Frame.1"
Const ControlIDImage = "Forms.Image.1"
Const ControlIDLabel = "Forms.Label.1"
Const ControlIDListBox = "Forms.ListBox.1"
Const ControlIDMultiPage = "Forms.MultiPage.1"
Const ControlIDOptionButton = "Forms.OptionButton.1"
Const ControlIDScrollBar = "Forms.ScrollBar.1"
Const ControlIDSpinButton = "Forms.SpinButton.1"
Const ControlIDTabStrip = "Forms.TabStrip.1"
Const ControlIDTextBox = "Forms.TextBox.1"
Const ControlIDToggleButton = "Forms.ToggleButton.1"
Enum AnswerType
    argInput = 2
    argYesNo = 4
    argCancel = 8
    argTrueFalse = 16
    argDate = 32
    argRange = 64
End Enum

Private msFontName As String
Private mafChrWid(32 To 127) As Double

Private Sub oDate_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.ActiveControl.Value = False
    Cancel = True
End Sub

Private Sub oFalse_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.ActiveControl.Value = False
    Cancel = True
End Sub

Private Sub oInput_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.ActiveControl.Value = False
    Cancel = True
End Sub

Private Sub oNo_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.ActiveControl.Value = False
    Cancel = True
End Sub

Private Sub oRange_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.ActiveControl.Value = False
    Cancel = True
End Sub

Private Sub oTrue_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.ActiveControl.Value = False
    Cancel = True
End Sub

Private Sub oYes_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Me.ActiveControl.Value = False
    Cancel = True
End Sub

Private Sub UserForm_Initialize()
    Set Calendar1 = New cCalendar
    With Calendar1
        .Add_Calendar_into_Frame Me.Frame1
        .UseDefaultBackColors = True
        .DayLength = 3
        .MonthLength = mlENShort
    End With
    Frame1.visible = False
    Dim ctr As MSForms.control
    For Each ctr In Frame1.Controls
        ctr.visible = Frame1.visible
    Next
End Sub

Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    If KeyCode = 13 Then cmdOK_Click
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    Set Calendar1 = Nothing
End Sub

Public Function answer( _
       Optional AT As AnswerType = 999, _
       Optional ExtraOptions As Variant, _
       Optional ExtraOptionsPerColumn As Long = 999, _
       Optional extraOptionsFramesVertical As Boolean = True, _
       Optional Caption As String, _
       Optional AskInVBE As Boolean) _
        As Variant
    '#INCLUDE LargestLength
    '#INCLUDE ResizeUserformToFitControls
    '#INCLUDE AddAnswerControlToFrame
    '#INCLUDE StrWidth
    '#INCLUDE MakeUserFormChildOfVBEditor
    '#INCLUDE CreateOrSetFrame
    '#INCLUDE AvailableFormOrFrameRow
    '#INCLUDE AvailableFormOrFrameColumn

                                                    
    Rem example in immediate window:
    Rem uanswer.answer(,Array(array("Forms.OptionButton.1",1,2,3,4,5,6)),2)
    Rem call uanswer.answer(0,array(ControlIDOptionButton,array(1,2,3,4),ControlIDCheckBox,array(5,6,7,8),ControlIDOptionButton,array("a","b","c","d")),2)

    Rem if AT = 0 then don

    If AT = 999 Then AT = argDate + argInput + argRange + argTrueFalse + argYesNo + argCancel
    If AT And argDate Then oDate.visible = True: oDate.Value = True
    If AT And argInput Then oInput.visible = True: TextBox1.visible = True
    If AT And argRange Then oRange.visible = True
    If AT And argTrueFalse Then oTrue.visible = True: oFalse.visible = True
    If AT And argYesNo Then oYes.visible = True: oNo.visible = True
    If AT And argCancel Then oCancel.visible = True
    
    If Not IsMissing(ExtraOptions) Then
        If IsArray(ExtraOptions) Then
            Dim ExtraOptionsGroupCount
            ExtraOptionsGroupCount = UBound(ExtraOptions)
            
            Dim counter As Long
            Dim i As Long
            Dim X As Long
            
            Dim groupCounter As Long
            Dim ControlsCount As Long
    
            ExtraOptionColumn = 186
            Dim ExtraColumnWidth As Long
            
            Dim arrayRow As Long
            
            cFrameTop = 0
            cFrameLeft = ExtraOptionColumn
            
            For X = LBound(ExtraOptions) To UBound(ExtraOptions)
                If Not IsArray(ExtraOptions(X)) Then
                    ctrType = ExtraOptions(X)
                    Set cFrame = CreateOrSetFrame(Me, "myFrame" & X)
                    cFrame.left = cFrameLeft
                    cFrame.top = cFrameTop
                    arrayRow = ExtraOptionRow
                    If IsArray(ExtraOptions(X + 1)) Then
                        ExtraColumnWidth = LargestLength(ExtraOptions(X + 1)) * StrWidth("A", oDate.Font.Name, oDate.Font.Size)
                        For i = 0 To UBound(ExtraOptions(X + 1))
                            ControlsCount = Me.Controls.count
                            optionCaption = ExtraOptions(X + 1)(i)
                            AddAnswerControlToFrame Me, "myFrame" & X
                                
                            If columnControls = ExtraOptionsPerColumn Then
                                columnControls = 0
                                PreviousRow = 0
                                ExtraOptionColumn = ExtraOptionColumn + c.Width + ExtraColumnWidth
                                FrameControlColumn = FrameControlColumn + c.Width + ExtraColumnWidth
                            Else
                            End If
                             
                        Next i
                    Else
                    End If
                    
                End If
                ExtraOptionColumn = 186
                If Not cFrame Is Nothing Then
                    ExtraOptionRow = cFrame.top + cFrame.Height + 6
                Else
                    ExtraOptionRow = AvailableFormOrFrameRow(Me, 185)
                End If
                If Not cFrame Is Nothing Then
                    cFrameTop = cFrame.top + cFrame.Height + 6
                    If extraOptionsFramesVertical = False Then cFrameLeft = cFrame.left + cFrame.Width + 6
                End If
                FrameControlColumn = 0
                Set cFrame = Nothing
            Next X
        End If

    End If
    
    Dim ctr As MSForms.control
    If Not IsMissing(ExtraOptions) Then
        If extraOptionsFramesVertical = True Then
            For X = LBound(ExtraOptions) To UBound(ExtraOptions)
                If WorksheetFunction.IsEven(X) Then Me.Controls("myFrame" & X).visible = False
            Next
            anchorcolumn = IIf(AT = 0, cmdOK.left + cmdOK.Width + 6, AvailableFormOrFrameColumn(Me, cmdOK.left + cmdOK.Width))
            For X = LBound(ExtraOptions) To UBound(ExtraOptions)
                If WorksheetFunction.IsEven(X) Then
                    Me.Controls("myFrame" & X).visible = True
                    Me.Controls("myFrame" & X).left = anchorcolumn
                End If
            Next
        Else
            For X = LBound(ExtraOptions) To UBound(ExtraOptions)
                If WorksheetFunction.IsEven(X) Then
                    Me.Controls("myFrame" & X).top = 6
                End If
            Next
            For X = LBound(ExtraOptions) To UBound(ExtraOptions)
                If WorksheetFunction.IsEven(X) Then Me.Controls("myFrame" & X).visible = False
            Next
            For X = LBound(ExtraOptions) To UBound(ExtraOptions)
                If WorksheetFunction.IsEven(X) Then
                    Me.Controls("myFrame" & X).left = AvailableFormOrFrameColumn(Me)
                    Me.Controls("myFrame" & X).visible = True
                End If
            Next
        End If
    End If
    
    If Len(Caption) > 0 Then uAnswer.Caption = Caption
    ResizeUserformToFitControls Me
    If AskInVBE = True Then
        Application.VBE.MainWindow.visible = True
        Application.VBE.MainWindow.WindowState = vbext_ws_Normal
        MakeUserFormChildOfVBEditor Me.Caption
    End If
    Me.Show
    If IsObject(ans) Then
        Set answer = ans
    Else
        answer = ans
    End If
    Unload Me
End Function

Sub AddAnswerControlToFrame(form As Object, FrameName As String)
    '#INCLUDE ResizeUserformToFitControls
    '#INCLUDE CreateOrSetFrame
    Set cFrame = CreateOrSetFrame(form, FrameName)
    Set c = cFrame.Controls.Add(ctrType)
        
    c.Font.Name = "Consolas"
    c.Font.Size = 9
    columnControls = columnControls + 1
    FrameControlRow = (columnControls - 1) * c.Height
    c.Caption = optionCaption
    c.AutoSize = True
    c.left = FrameControlColumn
    c.top = FrameControlRow
    ResizeUserformToFitControls Me.Controls(FrameName)
End Sub

Sub BringControlsLeft(FormOrFrame As Object)
    '#INCLUDE AvailableFormOrFrameColumn
    Dim c As MSForms.control
    Dim element
    For Each c In FormOrFrame.Controls
        c.left = AvailableFormOrFrameColumn(FormOrFrame)
    Next
End Sub

Private Sub cmdOK_Click()
    Rem example call uanswer.answer(0,array(ControlIDOptionButton,array(1,2,3,4),ControlIDCheckBox,array(5,6,7,8),ControlIDOptionButton,array("a","b","c","d")),2)
    Rem after this selectedoptionscollection is populated with the options chosen for you to use

    Set SelectedOptionsCollection = New Collection
    GetSelectedOptions Me
    For i = 1 To SelectedOptionsCollection.count
        ans = SelectedOptionsCollection(i)
        
        If ans = "INPUT" Then
            ans = TextBox1.TEXT
        ElseIf ans = "RANGE" Then
            Set ans = InputBoxRange
        ElseIf ans = "vbYES" Then
            ans = vbYes
        ElseIf ans = "vbNO" Then
            ans = vbNo
        ElseIf ans = "vbCancel" Then
            ans = vbCancel
        ElseIf ans = "TRUE" Then
            ans = True
        ElseIf ans = "FALSE" Then
            ans = False
        ElseIf ans = "DATE" Then
            ans = Calendar1.Value
        End If
        
        If TypeName(ans) = "Boolean" Then
            ans = CBool(ans)
        ElseIf IsDate(ans) Then
            ans = CDate(ans)
        ElseIf IsNumeric(ans) Then
            ans = CLng(ans)
        ElseIf TypeName(ans) = "String" Then
            ans = CStr(ans)
        End If
        SelectedOptionsCollection.Add ans, , i
        SelectedOptionsCollection.Remove i + 1
    Next
    Me.Hide
End Sub

Private Sub cmdCancel_Click()
    Unload Me
End Sub

Private Function InputBoxRange(Optional sTitle As String, Optional sPrompt As String) As Range
    On Error Resume Next
    Set InputBoxRange = Application.InputBox(title:=sTitle, Prompt:=sPrompt, Type:=8, _
                                             Default:=IIf(TypeName(Selection) = "Range", Selection.Address, ""))
End Function

Private Sub cmdToday_Click()
    Calendar1.Year = Format(Date, "YYYY")
    Calendar1.Month = Format(Date, "MM")
    Calendar1.Day = Format(Date, "DD")
End Sub

Private Sub oDate_Change()
    Dim ctr As MSForms.control
    For Each ctr In Frame1.Controls
        ctr.visible = oDate.Value
    Next
    cmdToday.visible = oDate.Value
    Frame1.visible = oDate.Value
    ResizeUserformToFitControls Me
End Sub

Private Function StrWidth(s As String, sFontName As String, fFontSize As Double) As Double
    '#INCLUDE InitChrWidths
    Dim i As Long
    Dim j As Long

    If sFontName <> msFontName Then
        If Not InitChrWidths(sFontName) Then
            Exit Function
        End If
    End If
    For i = 1 To Len(s)
        j = Asc(Mid(s, i, 1))
        If j >= 32 Then
            StrWidth = StrWidth + fFontSize * mafChrWid(j)
        End If
    Next i
End Function

Private Function InitChrWidths(sFontName As String) As Boolean
    '#INCLUDE StrWidth
    Dim i As Long
    Select Case sFontName
        Case "Consolas"
            For i = 32 To 127
                Select Case i
                    Case 32 To 127
                        mafChrWid(i) = 0.5634
                End Select
            Next i
        Case "Arial"
            For i = 32 To 127
                Select Case i
                    Case 39, 106, 108
                        mafChrWid(i) = 0.1902
                    Case 105, 116
                        mafChrWid(i) = 0.2526
                    Case 32, 33, 44, 46, 47, 58, 59, 73, 91 To 93, 102, 124
                        mafChrWid(i) = 0.3144
                    Case 34, 40, 41, 45, 96, 114, 123, 125
                        mafChrWid(i) = 0.3768
                    Case 42, 94, 118, 120
                        mafChrWid(i) = 0.4392
                    Case 107, 115, 122
                        mafChrWid(i) = 0.501
                    Case 35, 36, 48 To 57, 63, 74, 76, 84, 90, 95, 97 To 101, 103, 104, 110 To 113, 117, 121
                        mafChrWid(i) = 0.5634
                    Case 43, 60 To 62, 70, 126
                        mafChrWid(i) = 0.6252
                    Case 38, 65, 66, 69, 72, 75, 78, 80, 82, 83, 85, 86, 88, 89, 119
                        mafChrWid(i) = 0.6876
                    Case 67, 68, 71, 79, 81
                        mafChrWid(i) = 0.7494
                    Case 77, 109, 127
                        mafChrWid(i) = 0.8118
                    Case 37
                        mafChrWid(i) = 0.936
                    Case 64, 87
                        mafChrWid(i) = 1.0602
                End Select
            Next i
        Case "Calibri"
            For i = 32 To 127
                Select Case i
                    Case 32, 39, 44, 46, 73, 105, 106, 108
                        mafChrWid(i) = 0.2526
                    Case 40, 41, 45, 58, 59, 74, 91, 93, 96, 102, 123, 125
                        mafChrWid(i) = 0.3144
                    Case 33, 114, 116
                        mafChrWid(i) = 0.3768
                    Case 34, 47, 76, 92, 99, 115, 120, 122
                        mafChrWid(i) = 0.4392
                    Case 35, 42, 43, 60 To 63, 69, 70, 83, 84, 89, 90, 94, 95, 97, 101, 103, 107, 118, 121, 124, 126
                        mafChrWid(i) = 0.501
                    Case 36, 48 To 57, 66, 67, 75, 80, 82, 88, 98, 100, 104, 110 To 113, 117, 127
                        mafChrWid(i) = 0.5634
                    Case 65, 68, 86
                        mafChrWid(i) = 0.6252
                    Case 71, 72, 78, 79, 81, 85
                        mafChrWid(i) = 0.6876
                    Case 37, 38, 119
                        mafChrWid(i) = 0.7494
                    Case 109
                        mafChrWid(i) = 0.8742
                    Case 64, 77, 87
                        mafChrWid(i) = 0.936
                End Select
            Next i
        Case "Tahoma"
            For i = 32 To 127
                Select Case i
                    Case 39, 105, 108
                        mafChrWid(i) = 0.2526
                    Case 32, 44, 46, 102, 106
                        mafChrWid(i) = 0.3144
                    Case 33, 45, 58, 59, 73, 114, 116
                        mafChrWid(i) = 0.3768
                    Case 34, 40, 41, 47, 74, 91 To 93, 124
                        mafChrWid(i) = 0.4392
                    Case 63, 76, 99, 107, 115, 118, 120 To 123, 125
                        mafChrWid(i) = 0.501
                    Case 36, 42, 48 To 57, 70, 80, 83, 95 To 98, 100, 101, 103, 104, 110 To 113, 117
                        mafChrWid(i) = 0.5634
                    Case 66, 67, 69, 75, 84, 86, 88, 89, 90
                        mafChrWid(i) = 0.6252
                    Case 38, 65, 71, 72, 78, 82, 85
                        mafChrWid(i) = 0.6876
                    Case 35, 43, 60 To 62, 68, 79, 81, 94, 126
                        mafChrWid(i) = 0.7494
                    Case 77, 119
                        mafChrWid(i) = 0.8118
                    Case 109
                        mafChrWid(i) = 0.8742
                    Case 64, 87
                        mafChrWid(i) = 0.936
                    Case 37, 127
                        mafChrWid(i) = 1.0602
                End Select
            Next i
        Case "Lucida Console"
            For i = 32 To 127
                Select Case i
                    Case 32 To 127
                        mafChrWid(i) = 0.6252
                End Select
            Next i
        Case "Times New Roman"
            For i = 32 To 127
                Select Case i
                    Case 39, 124
                        mafChrWid(i) = 0.1902
                    Case 32, 44, 46, 59
                        mafChrWid(i) = 0.2526
                    Case 33, 34, 47, 58, 73, 91 To 93, 105, 106, 108, 116
                        mafChrWid(i) = 0.3144
                    Case 40, 41, 45, 96, 102, 114
                        mafChrWid(i) = 0.3768
                    Case 63, 74, 97, 115, 118, 122
                        mafChrWid(i) = 0.4392
                    Case 94, 98 To 101, 103, 104, 107, 110, 112, 113, 117, 120, 121, 123, 125
                        mafChrWid(i) = 0.501
                    Case 35, 36, 42, 48 To 57, 70, 83, 84, 95, 111, 126
                        mafChrWid(i) = 0.5634
                    Case 43, 60 To 62, 69, 76, 80, 90
                        mafChrWid(i) = 0.6252
                    Case 65 To 67, 82, 86, 89, 119
                        mafChrWid(i) = 0.6876
                    Case 68, 71, 72, 75, 78, 79, 81, 85, 88
                        mafChrWid(i) = 0.7494
                    Case 38, 109, 127
                        mafChrWid(i) = 0.8118
                    Case 37
                        mafChrWid(i) = 0.8742
                    Case 64, 77
                        mafChrWid(i) = 0.936
                    Case 87
                        mafChrWid(i) = 0.9984
                End Select
            Next i
        Case Else
            MsgBox "Font name """ & sFontName & """ not available!", vbCritical, "StrWidth"
            Exit Function
    End Select
    msFontName = sFontName
    InitChrWidths = True
End Function



'uSkeleton	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uSkeleton
'* Created    : 06-10-2022 10:40
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Dim wb As Workbook
Dim vbProj As VBProject
Dim vbComp As VBComponent
Dim comp As String
Dim proc

Private Sub exportDeclarationsAndCalls_Click()
    setUp
    Dim var As Variant
    Dim collections As New Collection
    Set collections = FindCalls(wb)
    If collections(1).count > 0 Then
        var = CollectionsToArrayTable(collections)
        ArrayToRange2D var, dataToSheet(wb, "exportCalls", "A2")
        With wb.SHEETS("exportCalls").Range("A1:B1")
            .Value = Array("Procedure", "Calls")
            .Font.Bold = True
            .Font.Size = 14
        End With
        With wb.SHEETS("exportCalls").Cells
            .WrapText = False
            .Columns.AutoFit
            .WrapText = True
            .Columns.AutoFit
            .VerticalAlignment = xlVAlignCenter
        End With
    End If
    Set collections = getDeclarations(wb, True, True, True, True, True, True)
    If collections(1).count > 0 Then
        var = CollectionsToArrayTable(collections)
        ArrayToRange2D var, dataToSheet(wb, "exportDeclarations", "A2")
        With wb.SHEETS("exportDeclarations").Range("A1:F1")
            .Value = Array("Component Type", "Component Name", "Declaration Scope", "Declaration Type", "Declaration Keyword", "Declaration Code")
            .Font.Bold = True
            .Font.Size = 14
        End With
        With wb.SHEETS("exportDeclarations").Cells
            .WrapText = False
            .Columns.AutoFit
            .WrapText = True
            .Columns.AutoFit
            .VerticalAlignment = xlVAlignCenter
        End With
    End If
End Sub

Function GetCallsOfProcedureSkeleton(wb As Workbook, vbComp As VBComponent, procName As String) As Collection
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE GetProcText
    Dim coll As Collection: Set coll = New Collection
    Dim WorkbookProcedure As Variant
    Dim AllProcs As Collection: Set AllProcs = ProceduresOfWorkbook(wb)
    Dim procText As String:    procText = GetProcText(vbComp, procName)
    For Each WorkbookProcedure In AllProcs
        If CStr(WorkbookProcedure) <> procName Then
            If InStr(1, procText, CStr(WorkbookProcedure)) Then
                coll.Add CStr(WorkbookProcedure)
            End If
        End If
    Next WorkbookProcedure
    Set GetCallsOfProcedureSkeleton = coll
End Function

Private Sub Image1_click()
    uDEV.Show
End Sub

Private Sub UserForm_Initialize()
    loadProjects
End Sub

Sub loadProjects()
    '#INCLUDE ProtectedVBProject
    For Each wb In Workbooks
        If Not ProtectedVBProject(wb) Then LProjects.AddItem wb.Name
    Next
    On Error Resume Next
    For Each ad In AddIns
        If Not ProtectedVBProject(Workbooks(ad.Name)) Then
            If err = 0 Then LProjects.AddItem ad.Name
            err.clear
        End If
    Next
End Sub

Private Sub LProjects_Click()
    loadComponents
End Sub

Sub loadComponents()
    '#INCLUDE ComponentTypeToString
    '#INCLUDE SortListboxOnColumn
    '#INCLUDE setUp
    '#INCLUDE ReleaseMe
    '#INCLUDE ControlsResizeColumns
    LComponents.clear: LProcedures.clear: TPROCS.TEXT = "": LCalls.clear: TCalls.TEXT = "": LDeclarations.clear: TDeclarations.TEXT = "":
    setUp
    For Each vbComp In vbProj.VBComponents
        LComponents.AddItem
        LComponents.list(LComponents.ListCount - 1, 0) = ComponentTypeToString(vbComp.Type)
        LComponents.list(LComponents.ListCount - 1, 1) = vbComp.Name
    Next
    ReleaseMe
    SortListboxOnColumn LComponents, 0
    ControlsResizeColumns LComponents
End Sub

Private Sub LComponents_Click()
    LProcedures.clear: TPROCS.TEXT = "": LCalls.clear: TCalls.TEXT = "": LDeclarations.clear: TDeclarations.TEXT = "":
    setUp
    For Each proc In ProcList(vbComp)
        LProcedures.AddItem proc
    Next proc
    TComps.TEXT = GetModuleText(vbComp)
    SortListboxOnColumn LProcedures, 0
End Sub

Private Sub LProcedures_Click()
    LCalls.clear: TCalls.TEXT = "": LDeclarations.clear: TDeclarations.TEXT = "":
    setUp
    TPROCS.TEXT = GetProcText(vbComp, CStr(proc))
    Do While InStr(1, TPROCS.TEXT, "  ") > 0
        TPROCS.TEXT = Replace(TPROCS.TEXT, "  ", " ")
    Loop
    Dim element
    For Each element In GetCallsOfProcedureSkeleton(wb, ModuleOfProcedure(wb, CStr(proc)), CStr(proc))
        LCalls.AddItem element
    Next
    SortListboxOnColumn LCalls, 1
    'test
    Dim coll As Collection:     Set coll = getDeclarations(wb, True, True, True, True, True, True)
    Dim keyCol As Collection:   Set keyCol = coll.item(5)
    Dim decCol As Collection:   Set decCol = coll.item(6)
    Dim i As Long
    Dim tmp As String
    For i = 1 To keyCol.count
        'if the DECLARATION keyword exists inside the procedure
        If InStr(1, TPROCS.TEXT, keyCol.item(i)) > 0 Then
            'and if it is not a VARIABLE inside the procedure
            If InStr(1, TPROCS.TEXT, keyCol.item(i) & " As") = 0 Then
                'avoid duplicates
                If ListboxContains(LDeclarations, keyCol.item(i)) = False Then
                    LDeclarations.AddItem keyCol.item(i)
                End If
            End If
        End If
    Next i
    SortListboxOnColumn LDeclarations, 0
    SortListboxOnColumn LCalls, 0
    ReleaseMe
End Sub

Private Sub LCalls_Click()
    setUp
    proc = LCalls.list(LCalls.ListIndex)
    Set vbComp = ModuleOfProcedure(wb, CStr(proc))
    TCalls.TEXT = GetProcText(vbComp, CStr(proc))
    ReleaseMe
End Sub

Private Sub LDeclarations_Click()
    setUp
    Dim coll As Collection:     Set coll = getDeclarations(wb, True, True, True, True, True, True)
    Dim keyCol As Collection:   Set keyCol = coll.item(5)
    Dim decCol As Collection:   Set decCol = coll.item(6)
    Dim i As Long
    For i = 1 To keyCol.count
        If keyCol.item(i) = LDeclarations.list(LDeclarations.ListIndex) Then
            TDeclarations.TEXT = decCol.item(i)
        End If
    Next i
End Sub

Sub setUp()
    On Error Resume Next
    Set wb = Workbooks(LProjects.list(LProjects.ListIndex))
    Set vbProj = wb.VBProject
    comp = LComponents.list(LComponents.ListIndex, 1)
    Set vbComp = vbProj.VBComponents(comp)
    proc = LProcedures.list(LProcedures.ListIndex)
End Sub

Sub ReleaseMe()
    Set vbProj = Nothing
    Set vbComp = Nothing
    comp = ""
    Set wb = Nothing
End Sub

Function FindCalls(wb As Workbook) As Collection
    '#INCLUDE ProceduresOfWorkbook
    '#INCLUDE ModuleOfProcedure
    '#INCLUDE CollectionToArray
    '#INCLUDE GetCallsOfProcedureSkeleton
    Dim Procedure As Variant
    Dim output As New Collection
    Dim procedures As New Collection
    Dim calls As New Collection
    Dim element As Variant
    Dim tmp As New Collection
    For Each Procedure In ProceduresOfWorkbook(wb)
        Set tmp = GetCallsOfProcedureSkeleton(wb, ModuleOfProcedure(wb, CStr(Procedure)), CStr(Procedure))
        If tmp.count > 0 Then
            procedures.Add Procedure
            calls.Add Join(CollectionToArray(tmp), vbNewLine)
        End If
    Next
    output.Add procedures
    output.Add calls
    Set FindCalls = output
End Function

Function dataToSheet(Optional wb As Workbook, Optional wsName As String, Optional rngAddress As String, Optional confirmClear As Boolean) As Range
    '#INCLUDE answer
    '#INCLUDE sheetExists
    If wb Is Nothing Then Set wb = Workbooks.Add
    Dim ws As Worksheet
    If sheetExists(wsName, wb) Then
        If confirmClear = True Then
            Dim answer As Integer
            answer = MsgBox("Sheet " & wsName & " already exists. Cells will be cleared. Proceed?", vbYesNo)
            If answer = vbNo Then Exit Function
        End If
        Set ws = wb.SHEETS(wsName)
        ws.Cells.clear
    Else
        If wsName = "" Then
            Set ws = wb.SHEETS(1)
        Else
            Set ws = wb.SHEETS.Add
            ws.Name = wsName
        End If
    End If
    If rngAddress <> "" Then
        Set dataToSheet = ws.Range(rngAddress)
    Else
        Set dataToSheet = ws.Range("A1")
    End If
End Function

Function ProcList(vbComp As VBComponent) As Collection
    Dim CodeMod As CodeModule
    Set CodeMod = vbComp.CodeModule
    Dim coll As Collection
    Set coll = New Collection
    Dim LineNum As Long
    Dim NumLines As Long
    Dim procName As String
    Dim ProcKind As VBIDE.vbext_ProcKind
    LineNum = CodeMod.CountOfDeclarationLines + 1
    Do Until LineNum >= CodeMod.CountOfLines
        procName = CodeMod.ProcOfLine(LineNum, ProcKind)
        coll.Add procName
        LineNum = CodeMod.ProcStartLine(procName, ProcKind) + CodeMod.ProcCountLines(procName, ProcKind) + 1
    Loop
    Set ProcList = coll
End Function

Function ControlsResizeColumns(lBox As MSForms.control, Optional ResizeListbox As Boolean)
    '#INCLUDE sheetExists
    If lBox.ListCount = 0 Then Exit Function
    Application.ScreenUpdating = False
    Dim ws As Worksheet
    If sheetExists("ListboxColumnWidth", ThisWorkbook) = False Then
        Set ws = ThisWorkbook.Worksheets.Add
        ws.Name = "ListboxColumnwidth"
    Else
        Set ws = ThisWorkbook.Worksheets("ListboxColumnwidth")
        ws.Cells.clear
    End If
    ws.Cells.Font.Size = 12
    ws.Cells.Font.Name = "Calibri"
    '---Listbox to range-----
    Dim rng As Range
    Set rng = ThisWorkbook.SHEETS("ListboxColumnwidth").Range("A1")
    Set rng = rng.RESIZE(UBound(lBox.list) + 1, lBox.columnCount)
    rng = lBox.list
    '---Get ColumnWidths------
    rng.Columns.AutoFit
    Dim sWidth As String
    Dim vR() As Variant
    Dim n As Integer
    Dim cell As Range
    For Each cell In rng.RESIZE(1)
        n = n + 1
        ReDim Preserve vR(1 To n)
        vR(n) = cell.EntireColumn.Width
    Next cell
    sWidth = Join(vR, ";")
    'Debug.Print sWidth
    '---assign ColumnWidths----
    With lBox
        .ColumnWidths = sWidth
        '.RowSource = "A1:A3"
        .BorderStyle = fmBorderStyleSingle
    End With
    'remove worksheet
    Application.DisplayAlerts = False
    ws.Delete
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    '----Resize Listbox--------
    If ResizeListbox = False Then Exit Function
    Dim w As Long
    For i = LBound(vR) To UBound(vR)
        w = w + vR(i)
    Next
    DoEvents
    lBox.Width = w + 10
End Function

Function sheetExists(sheetToFind As String, Optional InWorkbook As Workbook) As Boolean
    If InWorkbook Is Nothing Then Set InWorkbook = ThisWorkbook
    On Error Resume Next
    sheetExists = Not InWorkbook.SHEETS(sheetToFind) Is Nothing
End Function


'M_Notify	1

Rem @Folder Notify References
Private Declare PtrSafe Function Shell_NotifyIconW Lib "shell32.dll" (ByVal dwMessage As Long, ByRef nfIconData As NOTIFYICONDATAW) As Long
Private Declare PtrSafe Sub CopyMemory Lib "kernel32.dll" Alias "RtlMoveMemory" (ByRef Destination As Any, ByRef source As Any, ByVal Length As Long)
Private Type NOTIFYICONDATAW
    cbSize As Long
    #If Win64 Then
    padding1 As Long
    #End If
    hWnd As LongPtr
    uID As Long
    uFlags As Long
    uCallbackMessage As Long
    #If Win64 Then
    padding2 As Long
    #End If
    hIcon As LongPtr
    szTip(1 To 128 * 2) As Byte
    dwState As Long
    dwStateMask As Long
    szInfo(1 To 256 * 2) As Byte
    uTimeout As Long
    szInfoTitle(1 To 64 * 2) As Byte
    dwInfoFlags As Long
End Type

Private Const NIM_ADD As Long = &H0&
Private Const NIM_MODIFY As Long = &H1&
Private Const NIF_INFO As Long = &H10&

Rem @Folder Notify
Private Function Min(ByVal a As Long, ByVal b As Long) As Long
    If a < b Then Min = a Else Min = b
End Function

Public Sub Toast(Optional ByVal title As String, Optional ByVal info As String, Optional ByVal flag As Long)
    Rem toast "Hello World", "from Excel",1
    Rem https://github.com/rfl808/Notify
    '#INCLUDE Min
    Dim nfIconData As NOTIFYICONDATAW
    info = info & " "
    title = title & " "
    With nfIconData
        .cbSize = Len(nfIconData)
        .uFlags = NIF_INFO
        .dwInfoFlags = flag
        If Len(title) > 0 Then
            CopyMemory ByVal VarPtr(.szInfoTitle(LBound(.szInfoTitle))), ByVal StrPtr(title), Min(Len(title) * 2, UBound(.szInfoTitle) - LBound(.szInfoTitle) + 1 - 2)
        End If
        If Len(info) > 0 Then
            CopyMemory ByVal VarPtr(.szInfo(LBound(.szInfo))), ByVal StrPtr(info), Min(Len(info) * 2, UBound(.szInfo) - LBound(.szInfo) + 1 - 2)
        End If
    End With
    Shell_NotifyIconW NIM_ADD, nfIconData
    Shell_NotifyIconW NIM_MODIFY, nfIconData
End Sub

Rem Flags for the balloon message..
Rem None = 0
Rem Information = 1
Rem Exclamation = 2
Rem Critical = 3

'F_Crack	1

Rem @Folder Crack Declarations
Private Const PAGE_EXECUTE_READWRITE = &H40
Private Declare PtrSafe Sub MoveMemory Lib "kernel32" Alias "RtlMoveMemory" _
(Destination As LongPtr, source As LongPtr, ByVal Length As LongPtr)
Private Declare PtrSafe Function VirtualProtect Lib "kernel32" (lpAddress As LongPtr, _
ByVal dwSize As LongPtr, ByVal flNewProtect As LongPtr, lpflOldProtect As LongPtr) As LongPtr
Private Declare PtrSafe Function GetModuleHandleA Lib "kernel32" (ByVal lpModuleName As String) As LongPtr
Private Declare PtrSafe Function GetProcAddress Lib "kernel32" (ByVal hModule As LongPtr, _
ByVal lpProcName As String) As LongPtr
Private Declare PtrSafe Function DialogBoxParam Lib "user32" Alias "DialogBoxParamA" (ByVal hInstance As LongPtr, _
ByVal pTemplateName As LongPtr, ByVal hwndParent As LongPtr, _
ByVal lpDialogFunc As LongPtr, ByVal dwInitParam As LongPtr) As Integer
Dim HookBytes(0 To 11) As Byte
Dim OriginBytes(0 To 11) As Byte
Dim pFunc As LongPtr
Dim flag As Boolean

Rem @Folder Crack
Sub CrackVBA()
    '#INCLUDE CrackHook
    If CrackHook Then
        MsgBox "VBA Project is unprotected!", vbInformation, "*****"
    End If
End Sub

Private Function GetPtr(ByVal Value As LongPtr) As LongPtr
    GetPtr = Value
End Function

Public Sub RecoverBytes()
    If flag Then MoveMemory ByVal pFunc, ByVal VarPtr(OriginBytes(0)), 12
End Sub

Public Function CrackHook() As Boolean
    '#INCLUDE GetPtr
    '#INCLUDE MyDialogBoxParam
    Dim TmpBytes(0 To 11) As Byte
    Dim p As LongPtr, osi As Byte
    Dim OriginProtect As LongPtr
    CrackHook = False
    #If Win64 Then
        osi = 1
    #Else
        osi = 0
    #End If
    pFunc = GetProcAddress(GetModuleHandleA("user32.dll"), "DialogBoxParamA")
    If VirtualProtect(ByVal pFunc, 12, PAGE_EXECUTE_READWRITE, OriginProtect) <> 0 Then
        MoveMemory ByVal VarPtr(TmpBytes(0)), ByVal pFunc, osi + 1
        If TmpBytes(osi) <> &HB8 Then
            MoveMemory ByVal VarPtr(OriginBytes(0)), ByVal pFunc, 12
            p = GetPtr(AddressOf MyDialogBoxParam)
            If osi Then HookBytes(0) = &H48
            HookBytes(osi) = &HB8
            osi = osi + 1
            MoveMemory ByVal VarPtr(HookBytes(osi)), ByVal VarPtr(p), 4 * osi
            HookBytes(osi + 4 * osi) = &HFF
            HookBytes(osi + 4 * osi + 1) = &HE0
            MoveMemory ByVal pFunc, ByVal VarPtr(HookBytes(0)), 12
            flag = True
            CrackHook = True
        End If
    End If
End Function

Private Function MyDialogBoxParam(ByVal hInstance As LongPtr, _
                                  ByVal pTemplateName As LongPtr, ByVal hwndParent As LongPtr, _
                                  ByVal lpDialogFunc As LongPtr, ByVal dwInitParam As LongPtr) As Integer
    '#INCLUDE RecoverBytes
    '#INCLUDE CrackHook
    If pTemplateName = 4070 Then
        MyDialogBoxParam = 1
    Else
        RecoverBytes
        MyDialogBoxParam = DialogBoxParam(hInstance, pTemplateName, _
                                          hwndParent, lpDialogFunc, dwInitParam)
        CrackHook
    End If
End Function



'uPop	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uPop
'* Created    : 06-10-2022 10:39
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Rem call this form with the function    -   uMSG()
Private Sub UserForm_Initialize()
    MakeFormBorderless Me
    MakeFormTransparent Me
    UserformOnTop Me
End Sub

Sub Init(Optional Caption As Variant = "vbArc", _
         Optional SecondsPerMessage As Long = 3, _
         Optional ImagePath As String, _
         Optional TextSize As Long = 12, _
         Optional FontBold As Boolean = True, _
         Optional TextColor As Long = vbBlack, _
         Optional CounterColor As Long = vbBlack)
    '#INCLUDE CountDown
    SecondsPerMessage = SecondsPerMessage * 100
    Label3.Font.Size = TextSize
    Label3.ForeColor = TextColor
    Label3.Font.Bold = FontBold
    Label2.ForeColor = CounterColor
    If ImagePath <> "" Then
        Image1.Picture = LoadPicture(ImagePath)
        Image1.PictureSizeMode = fmPictureSizeModeStretch
    End If
    Me.Show
    On Error GoTo LoopEnd
    Application.EnableCancelKey = xlErrorHandler
    Dim element As Variant
    If TypeName(Caption) = "String" Then
        Label3.Caption = Caption
        CountDown SecondsPerMessage
    Else
        For Each element In Caption
            Label3.Caption = element
            CountDown SecondsPerMessage
        Next
    End If
LoopEnd:
    Application.EnableCancelKey = xlInterrupt
    Unload Me
End Sub

Sub CountDown(PopSleep As Long)
    '#INCLUDE Pop
    Dim i As Long
    i = 0
    Do While i < PopSleep / 100
        Label2.Caption = Round(PopSleep / 100, 0) - i
        DoEvents
        Sleep 1000
        i = i + 1
    Loop
End Sub



'uFrameMenu	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uFrameMenu
'* Created    : 06-10-2022 10:36
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Rem See the video of at https://youtu.be/l9b6DvCig5E


Rem @TODO create from sheet data

Private WithEvents Emitter As EventListenerEmitter

Private Sub Emitter_LabelMouseOut(label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then
        If label.BackColor <> &H80B91E Then label.BackColor = &H534848
    End If
End Sub

Private Sub Emitter_LabelMouseOver(label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then
        If label.BackColor <> &H80B91E Then label.BackColor = &H808080
    End If
End Sub

Sub Emitter_LabelClick(ByRef label As MSForms.label)
    If InStr(1, label.Tag, "reframe", vbTextCompare) > 0 Then Reframe Me, label
End Sub

Private Sub UserForm_Initialize()
    Dim anc As MSForms.control

    For Each c In Me.Controls
        If TypeName(c) = "Frame" Then
            'c.Caption = ""
            If Not InStr(1, c.Tag, "skip", vbTextCompare) > 0 Then
                c.visible = False
                If InStr(1, c.Tag, "anchor") > 0 Then
                    On Error Resume Next
                    Set anc = Me.Controls("Anchor" & Mid(c.Tag, InStr(1, c.Tag, "Anchor", vbTextCompare) + Len("Anchor"), 2))
                    If anc Is Nothing Then Stop
                    On Error GoTo 0
                    c.top = anc.top        'Anchor01.Top
                    c.left = anc.left        ' Anchor01.Left
                    Set anc = Nothing
                End If
            End If
        End If
    Next
    Set Emitter = New EventListenerEmitter
    Emitter.AddEventListenerAll Me
End Sub


'F_Declararions	1

Rem @Folder Declarations
Sub ListDeclarationsToSheet(TargetWorkbook As Workbook)
    '#INCLUDE ArrayToRange2D
    '#INCLUDE CreateOrSetSheet
    '#INCLUDE CollectionsToArrayTable
    '#INCLUDE getDeclarations
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("DeclarationsList", ActiveWorkbook)
    ArrayToRange2D CollectionsToArrayTable(getDeclarations(TargetWorkbook, True, True, True, True, True, True)), ws.Range("A1")
    ws.Range("A1").CurrentRegion.Sort ws.Range("D1")
End Sub

Sub testGetDeclarations()
    '#INCLUDE CreateOrSetSheet
    '#INCLUDE getDeclarations
    Dim ws As Worksheet
    Set ws = CreateOrSetSheet("DeclarationsTest", ThisWorkbook)
    Dim element As Variant
    Dim subelement As Variant
    Dim r As Long, c As Long
    r = 1
    c = 1
    For Each element In getDeclarations(ThisWorkbook, True, True, True, True, True, True)
        For Each subelement In element
            ws.Cells(r, c) = subelement
            r = r + 1
        Next
        r = 1
        c = c + 1
    Next
End Sub

Function getDeclaredKeywordsOfWorkbook(TargetWorkbook As Workbook) As Variant
    '#INCLUDE CollectionsToArrayTable
    '#INCLUDE getDeclarations
    getDeclaredKeywordsOfWorkbook = WorksheetFunction.Transpose(CollectionsToArrayTable(getDeclarations(TargetWorkbook, , , True)))
End Function

Function getDeclaredEnumOfWorkbook(TargetWorkbook As Workbook) As String
    '#INCLUDE CollectionsToArrayTable
    '#INCLUDE getDeclarations
    Dim out As String
    For Each c In CollectionsToArrayTable(getDeclarations(ThisWorkbook, , , , True))
        If InStr(1, CStr(c), "Enum ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredEnumOfWorkbook = out
End Function

Function getDeclaredTypeOfWorkbook(TargetWorkbook As Workbook) As String
    '#INCLUDE CollectionsToArrayTable
    '#INCLUDE getDeclarations
    Dim out As String
    For Each c In CollectionsToArrayTable(getDeclarations(ThisWorkbook, , , , True))
        If InStr(1, CStr(c), "Type ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredTypeOfWorkbook = out
End Function

Function getDeclaredSubOfWorkbook(TargetWorkbook As Workbook) As String
    '#INCLUDE CollectionsToArrayTable
    '#INCLUDE getDeclarations
    Dim out As String
    For Each c In CollectionsToArrayTable(getDeclarations(ThisWorkbook, , , , True))
        If InStr(1, CStr(c), "Sub ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredSubOfWorkbook = out
End Function

Function getDeclaredFunctionOfWorkbook(TargetWorkbook As Workbook) As String
    '#INCLUDE CollectionsToArrayTable
    '#INCLUDE getDeclarations
    Dim out As String
    For Each c In CollectionsToArrayTable(getDeclarations(ThisWorkbook, , , , True))
        If InStr(1, CStr(c), "Function ") > 0 Then out = IIf(out = "", c, out & vbNewLine & c)
    Next
    getDeclaredFunctionOfWorkbook = out
End Function

Function getDeclarations( _
         wb As Workbook, _
         Optional includeScope As Boolean, _
         Optional includeType As Boolean, _
         Optional includeKeywords As Boolean, _
         Optional includeDeclarations As Boolean, _
         Optional includeComponentName As Boolean, _
         Optional includeComponentType As Boolean) _
        As Collection
    '#INCLUDE ComponentTypeToString
    '#INCLUDE getWord
    Dim output As Collection: Set output = New Collection
    Dim declarationsCollection As Collection: Set declarationsCollection = New Collection
    Dim keywordsCollection As Collection: Set keywordsCollection = New Collection
    Dim vbComp As VBComponent
    Dim CodeMod As CodeModule
    Dim str As Variant
    Dim i As Long
    Dim element As Variant
    Dim originalDeclarations As Variant
    Dim tmp As String
    Dim helper As String
    Dim typeCollection As Collection: Set typeCollection = New Collection
    Dim componentCollection As Collection: Set componentCollection = New Collection
    Dim componentTypeCollection As Collection: Set componentTypeCollection = New Collection
    Dim scopeCollection As Collection: Set scopeCollection = New Collection
    For Each vbComp In wb.VBProject.VBComponents
        If vbComp.Type <> vbext_ct_ClassModule And vbComp.Type <> vbext_ct_Document Then
            Set CodeMod = vbComp.CodeModule
            If CodeMod.CountOfDeclarationLines > 0 Then
                str = CodeMod.Lines(1, CodeMod.CountOfDeclarationLines)
                str = Replace(str, "_" & vbNewLine, "")
                originalDeclarations = str
                tmp = str
                Do While InStr(1, str, "End Type") > 0
                    tmp = Mid(str, InStr(1, str, "Type "), InStr(1, str, "End Type") - InStr(1, str, "Type ") + 8)
                    str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
                Loop
                Do While InStr(1, str, "End Enum") > 0
                    tmp = Mid(str, InStr(1, str, "Enum "), InStr(1, str, "End Enum") - InStr(1, str, "Enum ") + 8)
                    str = Replace(str, tmp, Split(tmp, vbNewLine)(0))
                Loop
                Do While InStr(1, str, "  ") > 0
                    str = Replace(str, "  ", " ")
                Loop
                str = Split(str, vbNewLine)
                tmp = originalDeclarations
                For Each element In str
                    If InStr(1, CStr(element), "Enum ", vbTextCompare) > 0 Then
                        keywordsCollection.Add getWord(CStr(element), " ", "Enum")
                        declarationsCollection.Add getWord(tmp, , "Enum " & keywordsCollection.item(keywordsCollection.count), "End Enum", , , True)
                        typeCollection.Add "Enum"
                        componentCollection.Add vbComp.Name
                        componentTypeCollection.Add ComponentTypeToString(vbComp.Type)
                        scopeCollection.Add IIf(InStr(1, declarationsCollection.item(declarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf InStr(1, CStr(element), "Type ", vbTextCompare) > 0 Then
                        keywordsCollection.Add getWord(CStr(element), " ", "Type")
                        declarationsCollection.Add getWord(tmp, , "Type " & keywordsCollection.item(keywordsCollection.count), "End Type", , , True)
                        typeCollection.Add "Type"
                        componentCollection.Add vbComp.Name
                        componentTypeCollection.Add ComponentTypeToString(vbComp.Type)
                        scopeCollection.Add IIf(InStr(1, declarationsCollection.item(declarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf InStr(1, CStr(element), "Const ", vbTextCompare) > 0 Then
                        keywordsCollection.Add getWord(CStr(element), " ", "Const")
                        declarationsCollection.Add CStr(element)
                        typeCollection.Add "Const"
                        componentCollection.Add vbComp.Name
                        componentTypeCollection.Add ComponentTypeToString(vbComp.Type)
                        scopeCollection.Add IIf(InStr(1, declarationsCollection.item(declarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf InStr(1, CStr(element), "Sub ", vbTextCompare) > 0 Then
                        keywordsCollection.Add getWord(CStr(element), " ", "Sub")
                        declarationsCollection.Add CStr(element)
                        typeCollection.Add "Sub"
                        componentCollection.Add vbComp.Name
                        componentTypeCollection.Add ComponentTypeToString(vbComp.Type)
                        scopeCollection.Add IIf(InStr(1, declarationsCollection.item(declarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf InStr(1, CStr(element), "Function ", vbTextCompare) > 0 Then
                        keywordsCollection.Add getWord(CStr(element), " ", "Function")
                        declarationsCollection.Add CStr(element)
                        typeCollection.Add "Function"
                        componentCollection.Add vbComp.Name
                        componentTypeCollection.Add ComponentTypeToString(vbComp.Type)
                        scopeCollection.Add IIf(InStr(1, declarationsCollection.item(declarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf element Like "*(*) As *" Then
                        helper = left(element, InStr(1, CStr(element), "(") - 1)
                        helper = Mid(helper, InStrRev(helper, " ") + 1)
                        keywordsCollection.Add helper
                        declarationsCollection.Add CStr(element)
                        typeCollection.Add "Other"
                        componentCollection.Add vbComp.Name
                        componentTypeCollection.Add ComponentTypeToString(vbComp.Type)
                        scopeCollection.Add IIf(InStr(1, declarationsCollection.item(declarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                    ElseIf element Like "* As *" Then
                        keywordsCollection.Add getWord(CStr(element), " ", , "As")
                        declarationsCollection.Add CStr(element)
                        typeCollection.Add "Other"
                        componentCollection.Add vbComp.Name
                        componentTypeCollection.Add ComponentTypeToString(vbComp.Type)
                        scopeCollection.Add IIf(InStr(1, declarationsCollection.item(declarationsCollection.count), "Public", vbTextCompare), "Public", "Private")
                    Else
                    End If
                Next element
            End If
        End If
    Next vbComp
    If includeScope = True Then output.Add scopeCollection
    If includeType = True Then output.Add typeCollection
    If includeKeywords = True Then output.Add keywordsCollection
    If includeDeclarations = True Then output.Add declarationsCollection
    If includeComponentType = True Then output.Add componentTypeCollection
    If includeComponentName = True Then output.Add componentCollection
    Set getDeclarations = output
End Function

Function getWord(str As Variant, Optional delim As String _
                                , Optional afterWord As String _
                                 , Optional beforeWord As String _
                                  , Optional counter As Integer _
                                   , Optional outer As Boolean _
                                    , Optional includeWords As Boolean) As String
    Dim i As Long
    If afterWord = "" And beforeWord = "" And counter = 0 Then MsgBox ("Pass at least 1 parameter betweenn -AfterWord- , -BeforeWord- , -counter-"): Exit Function
    If TypeName(str) = "String" Then
        If delim <> "" Then
            str = Split(str, delim)
            If UBound(str) <> 0 Then
                If afterWord = "" And beforeWord = "" And counter <> 0 Then If counter - 1 <= UBound(str) Then getWord = str(counter - 1): Exit Function
                For i = LBound(str) To UBound(str)
                    If afterWord <> "" And beforeWord = "" Then If i <> 0 Then If str(i - 1) = afterWord Then getWord = str(i): Exit Function
                    If afterWord = "" And beforeWord <> "" Then If i <> UBound(str) Then If str(i + 1) = beforeWord Then getWord = str(i): Exit Function
                    If afterWord <> "" And beforeWord <> "" Then If i <> 0 And i <> UBound(str) Then If str(i - 1) = afterWord And str(i + 1) = beforeWord Then getWord = str(i): Exit Function
                Next i
            End If
        Else
            If InStr(1, str, afterWord) > 0 And InStr(1, str, beforeWord) > 0 Then
                If includeWords = False Then
                    getWord = Mid(str, InStr(1, str, afterWord) + Len(afterWord))
                Else
                    getWord = Mid(str, InStr(1, str, afterWord))
                End If
                If outer = True Then
                    If includeWords = False Then
                        getWord = left(getWord, InStrRev(getWord, beforeWord) - 1)
                    Else
                        getWord = left(getWord, InStrRev(getWord, beforeWord) + Len(beforeWord) - 1)
                    End If
                Else
                    If includeWords = False Then
                        getWord = left(getWord, InStr(1, getWord, beforeWord) - 1)
                    Else
                        getWord = left(getWord, InStr(1, getWord, beforeWord) + Len(beforeWord) - 1)
                    End If
                End If
                Exit Function
            End If
        End If
    Else
    End If
    getWord = vbNullString
End Function



'U_Pop	1

Rem @Folder UserformPop
Sub Pop(Optional TextOrArray As Variant = "vbArc", _
        Optional SecondsPerMessage As Long = 5, _
        Optional ImagePath As String, _
        Optional TextSize As Long = 12, _
        Optional FontBold As Boolean = True, _
        Optional TextColor As Long = vbBlack, _
        Optional CounterColor As Long = vbBlack)
    Rem pop array("This is my home town, Rhodes","Have you been here?"),300,"C:\Users\acer\Pictures\sdafs.jpg",24,true,vbwhite
    uPop.Init TextOrArray, SecondsPerMessage, ImagePath, TextSize, FontBold, TextColor, CounterColor
End Sub



'M_AHK	1

Rem @Folder AHK
Sub AHK_vbeMenu()
    '#INCLUDE dp
    '#INCLUDE RunAHKScript
    If Application.VBE.MainWindow.visible = True Then dp "The hotkey will be CTRL + SHIFT + H"
    RunAHKScript "C:\Users\acer\Dropbox\SOFTWARE\AHK\0 EXCEL\vbaMenu\vbaMenu.ahk"
End Sub

Public Function RunAHKScript(AHKFilePath As String, Optional AHKExePath As String = vbNullString) As Long
    '#INCLUDE GetAppPath
    If AHKExePath = vbNullString Then AHKExePath = GetAppPath("AutoHotkey.exe")
    Const QUOTES As String = """"
    RunAHKScript = Shell(AHKExePath & Space(1) & QUOTES & AHKFilePath & QUOTES)
End Function

Public Function GetAppPath(AppName As String) As String
    Dim WshShell As Object
    Set WshShell = CreateObject("WScript.Shell")
    Dim ReadFrom As String
    Const APP_PATH_REG_LOCATION As String = "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\"
    ReadFrom = APP_PATH_REG_LOCATION & AppName & "\"
    On Error Resume Next
    GetAppPath = WshShell.RegRead(ReadFrom)
End Function

Public Sub StopAHKScript()
    Shell "taskkill /pid " & AHKSheet.Range("B2").Value & " /pid " & AHKSheet.Range("B3").Value
End Sub


'ApplicationError	2

Option Explicit
Option Base 1
'
' Application Error Class
' |> Brian J. Satola
' |> https://chejunkie.com
'
'==========================================================================================================================
' This class is an error container.
'==========================================================================================================================
' It can be added to other classes instead of creating separate properties etc. that handle errors in the same way.
'--------------------------------------------------------------------------------------------------------------------------
'
'==========================================================================================================================
' Public Subs, Functions and Properties - oh my!
'==========================================================================================================================
'   |> Get | --- About                  :: Returns description of the class.
'   |> --------- Clear                  :: Clears all error properties.
'   |> --------- Define                 :: Defines an error.
'   |> Get | Set Description            :: Description of an error Number. (NumberDLL description is appended.)
'   |> --------- DisplayMessage         :: Displays error information in a message box.
'   |> --------- HasError
'   |> --------- Initialize
'   |> Get | Set Number
'   |> Get | Set NumberDLL
'   |> Get | --- ParentName
'   |> --------- PrintMessage
'   |> Get | Set Source
'   |> Get | --- Version                :: Returns version string for the class, ##.## (yyyy).
'
'==========================================================================================================================
' Application constants
'==========================================================================================================================
Private Const C_NAME                As String = "ApplicationError.cls"
Private Const C_ERR_NO_ERROR        As Long = 0
'==========================================================================================================================
' Private variables
'==========================================================================================================================
Private m_ErrNumber                 As Long
Private m_ErrNumberDLL              As Long
Private m_ErrSource                 As String
Private m_ErrDescription            As String
Private m_ErrDescriptionDLL         As String
Private m_ParentName                As String
Private m_HasError                  As Boolean
'==========================================================================================================================
' API Constants
'==========================================================================================================================
' GetSystemErrorMessageText
' |> www.cpearson.com/Excel/FormatMessage.aspx
Private Const FORMAT_MESSAGE_ALLOCATE_BUFFER    As Long = &H100
Private Const FORMAT_MESSAGE_ARGUMENT_ARRAY     As Long = &H2000
Private Const FORMAT_MESSAGE_FROM_HMODULE       As Long = &H800
Private Const FORMAT_MESSAGE_FROM_STRING        As Long = &H400
Private Const FORMAT_MESSAGE_FROM_SYSTEM        As Long = &H1000
Private Const FORMAT_MESSAGE_MAX_WIDTH_MASK     As Long = &HFF
Private Const FORMAT_MESSAGE_IGNORE_INSERTS     As Long = &H200
Private Const FORMAT_MESSAGE_TEXT_LEN           As Long = &HA0        ' from VC++ ERRORS.H file
'==========================================================================================================================
' API Declarations
'==========================================================================================================================
' GetSystemErrorMessageText
' |> www.cpearson.com/Excel/FormatMessage.aspx
Private Declare PtrSafe Function FormatMessage Lib "kernel32" _
Alias "FormatMessageA" ( _
ByVal dwFlags As Long, _
ByVal lpSource As Any, _
ByVal dwMessageId As Long, _
ByVal dwLanguageId As Long, _
ByVal lpBuffer As String, _
ByVal nSize As Long, _
ByRef Arguments As Long) As Long
' ToggleTrustAccess
' |> https://wellsr.com/vba/2017/excel/macro-to-enable-trust-access-to-the-VBA-project-object-model/
Private Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

'''
''' Clears all property settings of the error object.
'''
''' The parent name is not cleared since this is often set just once at the
''' beginning i.e. using the Initialize method.
'''
Public Sub clear()
    m_ErrNumber = C_ERR_NO_ERROR
    m_ErrNumberDLL = C_ERR_NO_ERROR
    m_ErrDescription = ""
    m_ErrSource = ""
    m_HasError = False
End Sub

'''
''' Defines an error.
'''
Public Sub Define(errNumber As Long, errDescription As String, Optional errSource As String)
    clear
    Me.Number = errNumber
    m_ErrDescription = errDescription
    m_ErrSource = errSource
End Sub

'''
''' Returns a descriptive string associated with an error.
''' Instead of having a seperate property for DLL errors, I simply append the result.
'''
Public Property Get Description() As String
    Description = m_ErrDescription
End Property

'''
''' Sets a descriptive string associated with an error.
'''
Property Let Description(str As String)
    m_ErrDescription = str
End Property

'''
''' Displays error details in a message-box: error number, description and source (if available).
''' Option to display custom title using [displayTitle]; else, it is automatically generated.
''' Option to append custom message to error text using [appendMessage].
''' Option to define message box behaviour using [iType] using vbMsgBoxStyle enums.
'''
Public Sub DisplayMessage(Optional displayTitle As String, Optional appendMessage As String, Optional msgBoxStyle As VbMsgBoxStyle = vbExclamation)
    If (displayTitle = "") Then        ' define display title
        displayTitle = "--ERROR!--"
        '--If (m_ErrNumber <> C_ERR_NO_ERROR) And (m_ParentName <> "") Then ' parent error title.
        '--    displayTitle = "--ERROR!-- " & m_ParentName
        '--ElseIf (m_ErrNumber <> C_ERR_NO_ERROR) Then ' error object title
        '--    displayTitle = "--ERROR!-- " & C_NAME
        '--ElseIf (m_ParentName <> "") Then ' parent
        '--    displayTitle = m_ParentName
        '--Else ' error object for everything else
        '--    displayTitle = C_NAME
        '--End If
    End If
    '// Display message to user.
    If (appendMessage <> vbNullString) Then        ' append message to error information
        MsgBox GetDescription & VBA.vbCrLf & VBA.vbCrLf & appendMessage, title:=displayTitle, BUTTONS:=msgBoxStyle
    Else
        MsgBox GetDescription, title:=displayTitle, BUTTONS:=msgBoxStyle
    End If
End Sub

'
' Returns a detailed error description: source, number and description (including errors from DLL).
'
Private Function GetDescription() As String
    '// Define detailed error description.
    If (m_ParentName <> "") Then
        GetDescription = "|> Parent: " & m_ParentName & VBA.vbCrLf
    End If
    If (m_ErrSource <> "") Then
        GetDescription = GetDescription & _
                         "|> Source: " & m_ErrSource & VBA.vbCrLf & _
                         "|> Number: " & m_ErrNumber & VBA.vbCrLf & _
                         "|> " & m_ErrDescription
    Else
        GetDescription = GetDescription & _
                         "|> Number: " & m_ErrNumber & VBA.vbCrLf & _
                         "|> " & m_ErrDescription
    End If
    '// Append DLL error information.
    If (m_ErrDescriptionDLL <> "") Then
        GetDescription = GetDescription & VBA.vbCrLf & VBA.vbCrLf & _
                         "----------------------------------------------------------------------------------" & VBA.vbCrLf & _
                         "|> DLL error number: " & m_ErrNumberDLL & VBA.vbCrLf & _
                         "|> " & m_ErrDescription
    End If
End Function

'''
''' Returns a string describing the class.
'''
Public Property Get About() As String
    About = "ChE Junkie VBA Application Error class module, Version " & Me.Version & "." & VBA.vbCrLf & VBA.vbCrLf
    About = About & "For additional details see:" & VBA.vbCrLf & "https://chejunkie.com/knowledge-base/application-error-class-vba"
End Property

'''
''' Returns the name of the class.
'''
Public Property Get Name() As String
    Name = C_NAME
End Property

'''
''' Returns version information for the class.
'''
Public Property Get Version() As String
    ' Contains a list of (historical) changes to the class within the comments of the procedure.
    '--------------------------------------------------------------------------------------------------------------------------
    Version = "Version 1.0 (2017)"        ' Initial (official) release.
End Property

'''
''' Will return True if 'Number' and/or 'NumberDLL' error exists.
'''
Property Get HasError() As Boolean
    HasError = m_HasError
End Property

'''
''' The parent name is something that is typically initialized just one time.
'''
Public Sub Initialize(parentName_ As String)
    clear
    m_ParentName = parentName_
End Sub

'''
''' Returns a numeric value specifying an error.
'''
Public Property Get Number() As Long
    Number = m_ErrNumber
End Property

'''
''' Returns a numeric value specifying a DLL error.
'''
Public Property Get NumberDLL() As Long
    NumberDLL = m_ErrNumberDLL
End Property

'''
''' This function gets the system error message text that corresponds to the error code *errNumber*.
''' This value is the value returned by Err.LastDLLError or by GetLastError, or occasionally as the
''' returned result of a Windows API function.
'''
''' These are NOT the error numbers returned by Err.Number (for these errors, use Err.Description
''' to get the description of the error).
'''
''' In general, you should use Err.LastDllError rather than GetLastError because under some
''' circumstances the value of GetLastError will be reset to 0 before the value is returned to VBA.
''' Err.LastDllError will always reliably return the last error number raised in an API function.
'''
''' The function returns vbNullString is an error occurred or if there is no error text for the
''' specified error number.
'''
Private Function GetSystemErrorMessageText(errNumber As Long) As String
    '#INCLUDE Init
    Dim ErrorText               As String
    Dim textLen                 As Long
    Dim FormatMessageResult     As Long
    Dim langID                  As Long
    ''''''''''''''''''''''''''''''''
    ' Initialize the variables
    ''''''''''''''''''''''''''''''''
    langID = 0&        ' Default language
    ErrorText = VBA.String$(FORMAT_MESSAGE_TEXT_LEN, vbNullChar)
    textLen = FORMAT_MESSAGE_TEXT_LEN
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Call FormatMessage to get the text of the error message text
    ' associated with errNumber.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    FormatMessageResult = FormatMessage( _
                          dwFlags:=FORMAT_MESSAGE_FROM_SYSTEM Or _
                                    FORMAT_MESSAGE_IGNORE_INSERTS, _
                          lpSource:=0&, _
                          dwMessageId:=errNumber, _
                          dwLanguageId:=langID, _
                          lpBuffer:=ErrorText, _
                          nSize:=textLen, _
                          Arguments:=0&)
    If FormatMessageResult = 0& Then
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        ' An error occured. Display the error number, but
        ' don't call GetSystemErrorMessageText to get the
        ' text, which would likely cause the error again,
        ' getting us into a loop.
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        MsgBox "An error occurred with the FormatMessage" & _
               " API function call." & vbCrLf & _
               "Error: " & CStr(err.LastDllError) & _
               " VBA.Hex(" & VBA.Hex(err.LastDllError) & ")."
        GetSystemErrorMessageText = "An internal system error occurred with the" & vbCrLf & _
                                    "FormatMessage API function: " & CStr(err.LastDllError) & ". No futher information" & vbCrLf & _
                                    "is available."
        Exit Function
    End If
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' If FormatMessageResult is not zero, it is the number
    ' of characters placed in the ErrorText variable.
    ' Take the left FormatMessageResult characters and
    ' return that text.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ErrorText = VBA.left$(ErrorText, FormatMessageResult)
    '''''''''''''''''''''''''''''''''''''''''''''
    ' Get rid of the trailing vbCrLf, if present.
    '''''''''''''''''''''''''''''''''''''''''''''
    If VBA.Len(ErrorText) >= 2 Then
        If VBA.Right$(ErrorText, 2) = vbCrLf Then
            ErrorText = VBA.left$(ErrorText, VBA.Len(ErrorText) - 2)
        End If
    End If
    ''''''''''''''''''''''''''''''''
    ' Return the error text as the
    ' result.
    ''''''''''''''''''''''''''''''''
    GetSystemErrorMessageText = ErrorText
End Function

'''
''' Sets a numeric value specifying an error.
'''
Property Let Number(lng As Long)
    If (lng <> C_ERR_NO_ERROR) Then
        m_ErrNumber = lng
        m_HasError = True
    End If
End Property

'''
''' Sets a numeric value specifying a DLL error.
'''
Property Let NumberDLL(lng As Long)
    If (lng <> C_ERR_NO_ERROR) Then
        m_ErrNumberDLL = lng
        m_ErrDescriptionDLL = GetSystemErrorMessageText(lng)
        m_HasError = True
    End If
End Property

'''
''' Returns the name of the parent that the error object belongs to.
'''
Private Property Get ParentName() As String
    ParentName = m_ParentName
End Property

'
' Prints error details to the immediate window: error number, description and source (if available).
'
Public Sub PrintMessage()
    Debug.Print ""
    Debug.Print "=================================================================================="
    Debug.Print " Application Error"
    Debug.Print "=================================================================================="
    Debug.Print GetDescription
End Sub

'''
''' Returns the name of the method, object etc. that originally generated the error.
'''
Public Property Get source() As String
    source = m_ErrSource
End Property

'''
''' Sets the name of the method, object etc. that originally generated the error.
'''
Property Let source(str As String)
    m_ErrSource = str
End Property

Private Sub Class_Initialize()
    Debug.Print "|* Initializing Class:= " & C_NAME
End Sub



'cCalendar	2

Rem Private WithEvents Calendar1 As cCalendar
Rem
Rem     Set Calendar1 = New cCalendar
Rem     With Calendar1
Rem         .Add_Calendar_into_Frame Me.Frame1
Rem         .UseDefaultBackColors = True
Rem         .DayLength = 3
Rem         .MonthLength = mlENShort
Rem     End With
Rem     Frame1.Visible = False
Rem     Dim ctr As MSForms.Control
Rem     For Each ctr In Frame1.Controls
Rem         ctr.Visible = Frame1.Visible
Rem     Next

Option Explicit
Public Event AfterUpdate()
Public Event BeforeUpdate(ByRef Cancel As Integer)
Public Event Click()
Public Event DblClick()
Private WithEvents CBxY As MSForms.ComboBox
Private WithEvents CBxM As MSForms.ComboBox
Private CLb As MSForms.label
Private mDayButtons() As cCalendar
Private mLabelButtons() As cCalendar
Private PTitleNewFont As MSForms.NewFont
Private PDayNewFont As MSForms.NewFont
Private PGridNewFont As MSForms.NewFont
Private WithEvents CmB As MSForms.CommandButton
Private CmBl As MSForms.label
Private CmBlNum As MSForms.label
Private mcMain As cCalendar
Private lPFontSize As Long
Private lPMonthLength As calMonthLength
Private lPDayLength As Long
Private bPYearFirst As Boolean
Private lPTitleFontColor As Long
Private lPGridFontColor As Long
Private lPDayFontColor As Long
Private lPFirstDay As calDayOfWeek
Private dValue As Date
Private lPBackColor As Long
Private lPMonth As Long
Private lPYear As Long
Private lPDay As Long
Private lPHeaderBackColor As Long
Private lPUseDefaultBackColors  As Boolean
Private bPVisible As Boolean
Private sPHeight As Single
Private sPWidth As Single
Private sPTop As Single
Private sPLeft As Single
Private lPSaturdayBackColor As Long
Private lPSundayBackColor As Long
Private sPControlTipText As String
Private bPTabStop As Boolean
Private lPTabIndex As Long
Private sPTag As String
Private bPShowDays As Boolean
Private bPShowTitle As Boolean
Private bPShowDateSelectors As Boolean
Private bPValueIsNull As Boolean
Private Const cDayFontColorSelected As Long = &H80000012
Private Const cDayFontColorInactive As Long = &H80000011
Private Const cBackColorInactive As Long = &H80000011
Private Const cDefaultWidth As Single = 216
Private Const cDefaultHeight As Single = 144
Public Enum calDayOfWeek
    dwMonday = 1
    dwTuesday = 2
    dwWednesday = 3
    dwThursday = 4
    dwFriday = 5
    dwSaturday = 6
    dwSunday = 7
End Enum

Public Enum calMonthLength
    mlLocalLong = 0
    mlLocalShort = 1
    mlENLong = 2
    mlENShort = 3
End Enum

Private Sub AAA__Properties_Blank_for_compatibility()
End Sub

Public Property Get GridCellEffect() As Long
End Property

Public Property Get GridLinesColor() As Long
End Property

Public Property Get ShowHorizontalGrid() As Boolean
End Property

Public Property Get ShowVerticalGrid() As Boolean
End Property

Public Property Get HelpContextID() As Long
End Property

Private Sub AAA__Properties_Book()
End Sub

Public Property Get Tag() As String
    Tag = sPTag
End Property

Public Property Let Tag(sTag As String)
    sPTag = sTag
End Property

Public Property Get parent() As control
    If bInit Then
        Set parent = CBxY.parent.parent
    Else
        Set parent = Nothing
    End If
End Property

Public Property Get ValueIsNull() As Boolean
    ValueIsNull = bPValueIsNull
End Property

Public Property Let ValueIsNull(ByVal bValueIsNull As Boolean)
    bPValueIsNull = bValueIsNull
    If bInit Then
        Value = Value
    End If
End Property

Public Property Get ShowTitle() As Boolean
    ShowTitle = bPShowTitle
End Property

Public Property Let ShowTitle(ByVal bShowTitle As Boolean)
    bPShowTitle = bShowTitle
    If bInit Then
        CLb.visible = bPShowTitle
        Move
    End If
End Property

Public Property Get ShowDays() As Boolean
    ShowDays = bPShowDays
End Property

Public Property Let ShowDays(ByVal bShowDays As Boolean)
    Dim i As Long
    bPShowDays = bShowDays
    If bInit Then
        For i = 0 To 6
            mLabelButtons(i).Obj_CmBl.visible = bShowDays
        Next
        Move
    End If
End Property

Public Property Get ShowDateSelectors() As Boolean
    ShowDateSelectors = bPShowDateSelectors
End Property

Public Property Let ShowDateSelectors(ByVal bShowDateSelectors As Boolean)
    bPShowDateSelectors = bShowDateSelectors
    If bInit Then
        CBxY.visible = bShowDateSelectors
        CBxM.visible = bShowDateSelectors
        Move
    End If
End Property

Public Property Get TabIndex() As Long
    TabIndex = lPTabIndex
End Property

Public Property Let TabIndex(ByVal lTabIndex As Long)
    lPTabIndex = lTabIndex
    If bInit Then
        CBxY.parent.TabIndex = lTabIndex
    End If
End Property

Public Property Get TabStop() As Boolean
    TabStop = bPTabStop
End Property

Public Property Let TabStop(ByVal bTabStop As Boolean)
    bPTabStop = bTabStop
    If bInit Then
        CBxY.parent.TabStop = bTabStop
    End If
End Property

Public Property Get ControlTipText() As String
    ControlTipText = sPControlTipText
End Property

Public Property Let ControlTipText(ByVal sControlTipText As String)
    Dim i As Long
    sPControlTipText = sControlTipText
    If bInit Then
        For i = 0 To 6
            mLabelButtons(i).Obj_CmBl.ControlTipText = sControlTipText
        Next
        For i = 0 To 41
            mDayButtons(i).Obj_Cmb.ControlTipText = sControlTipText
        Next
        CBxM.ControlTipText = sControlTipText
        CBxY.ControlTipText = sControlTipText
        CLb.ControlTipText = sControlTipText
    End If
End Property

Public Property Get GridFont() As MSForms.NewFont
    Set GridFont = PGridNewFont
End Property

Public Property Set GridFont(ByRef clGridNewFont As MSForms.NewFont)
    Set PGridNewFont = clGridNewFont
End Property

Public Property Get DayFont() As MSForms.NewFont
    Set DayFont = PDayNewFont
End Property

Public Property Set DayFont(ByRef clDayNewFont As MSForms.NewFont)
    Set PDayNewFont = clDayNewFont
End Property

Public Property Get TitleFont() As MSForms.NewFont
    Set TitleFont = PTitleNewFont
End Property

Public Property Set TitleFont(ByRef clTitleNewFont As MSForms.NewFont)
    Set PTitleNewFont = clTitleNewFont
End Property

Public Property Get visible() As Boolean
    visible = bPVisible
End Property

Public Property Let visible(ByVal bVisible As Boolean)
    bPVisible = bVisible
    If bInit Then
        CBxY.parent.visible = bVisible
    End If
End Property

Public Property Get left() As Single
    left = sPLeft
End Property

Public Property Let left(ByVal sLeft As Single)
    sPLeft = sLeft
    If bInit Then
        CBxY.parent.left = sLeft
    End If
End Property

Public Property Get top() As Single
    top = sPTop
End Property

Public Property Let top(ByVal ssTop As Single)
    sPTop = ssTop
    If bInit Then
        CBxY.parent.top = ssTop
    End If
End Property

Public Property Get Height() As Single
    Height = sPHeight
End Property

Public Property Let Height(ByVal sHeight As Single)
    sPHeight = sHeight
    If bInit Then
        CBxY.parent.Height = sHeight
        Move
    End If
End Property

Public Property Get Width() As Single
    Width = sPWidth
End Property

Public Property Let Width(ByVal sWidth As Single)
    sPWidth = sWidth
    If bInit Then
        CBxY.parent.Width = sWidth
        Move
    End If
End Property

Public Property Get BackColor() As Long
    BackColor = lPBackColor
End Property

Public Property Let BackColor(ByVal lBackColor As Long)
    lPBackColor = lBackColor
    If bInit Then
        CBxY.parent.BackColor = lBackColor
    End If
End Property

Public Property Get HeaderBackColor() As Long
    HeaderBackColor = lPHeaderBackColor
End Property

Public Property Let HeaderBackColor(ByVal lHeaderBackColor As Long)
    Dim i As Long
    lPHeaderBackColor = lHeaderBackColor
    UseDefaultBackColors = False
End Property

Public Property Get UseDefaultBackColors() As Boolean
    UseDefaultBackColors = lPUseDefaultBackColors
End Property

Public Property Let UseDefaultBackColors(ByVal lUseDefaultBackColors As Boolean)
    lPUseDefaultBackColors = lUseDefaultBackColors
    If bInit Then
        Refresh
    End If
End Property

Public Property Get SaturdayBackColor() As Long
    SaturdayBackColor = lPSaturdayBackColor
End Property

Public Property Let SaturdayBackColor(ByVal lSaturdayBackColor As Long)
    lPSaturdayBackColor = lSaturdayBackColor
    UseDefaultBackColors = False
End Property

Public Property Get SundayBackColor() As Long
    SundayBackColor = lPSundayBackColor
End Property

Public Property Let SundayBackColor(ByVal lSundayBackColor As Long)
    lPSundayBackColor = lSundayBackColor
    UseDefaultBackColors = False
End Property

Public Property Get FirstDay() As calDayOfWeek
    FirstDay = lPFirstDay
End Property

Public Property Let FirstDay(ByVal vbFirstDay As calDayOfWeek)
    Dim i As Long, v
    Select Case vbFirstDay
        Case 1 To 7
        Case Else
            vbFirstDay = 1
    End Select
    lPFirstDay = vbFirstDay
    If bInit Then
        v = fWeekdayName(CInt(lPDayLength))
        For i = 0 To 6
            mLabelButtons(i).Obj_CmBl.Caption = v(((i + vbFirstDay - 1) Mod 7))
        Next
        Refresh
    End If
End Property

Public Property Get DayFontColor() As Long
    DayFontColor = lPDayFontColor
End Property

Public Property Let DayFontColor(ByVal lFontColor As Long)
    Dim i As Long
    lPDayFontColor = lFontColor
    If bInit Then
        For i = 0 To 6
            mLabelButtons(i).Obj_CmBl.ForeColor = lFontColor
        Next
    End If
End Property

Public Property Get GridFontColor() As Long
    GridFontColor = lPGridFontColor
End Property

Public Property Let GridFontColor(ByVal lFontColor As Long)
    Dim i As Long
    lPGridFontColor = lFontColor
    If bInit Then
        Refresh
    End If
End Property

Public Property Let TitleFontColor(ByVal lFontColor As Long)
    lPTitleFontColor = lFontColor
    If bInit Then
        CLb.ForeColor = lFontColor
    End If
End Property

Public Property Get TitleFontColor() As Long
    TitleFontColor = lPTitleFontColor
End Property

Public Property Get Month() As Long
    Month = lPMonth
End Property

Public Property Let Month(ByVal lMonth As Long)
    If lMonth = 0 Then
        Value = Empty
    Else
        If lMonth < 0 Then lMonth = lPMonth
        lMonth = fMin(lMonth, 12)
        Value = SumMonthsToDate(dValue, lMonth - lPMonth)
    End If
    lPMonth = lMonth
End Property

Public Property Get Year() As Long
    Year = lPYear
End Property

Public Property Let Year(ByVal lYear As Long)
    If lYear = 0 Then
        Value = Empty
    Else
        Value = VBA.DateSerial(CheckYear(lYear), VBA.Month(dValue), VBA.Day(dValue))
    End If
    lPYear = lYear
End Property

Public Property Get Day() As Long
    Day = lPDay
End Property

Public Property Let Day(ByVal lDay As Long)
    If lDay = 0 Then
        Value = Empty
    Else
        If lDay < 0 Then lDay = lPDay
        lDay = fMin(lDay, VBA.Day(VBA.DateSerial(VBA.Year(dValue), VBA.Month(dValue) + 1, 0)))
        Value = VBA.DateSerial(VBA.Year(dValue), VBA.Month(dValue), lDay)
    End If
    lPDay = lDay
End Property

Public Property Get Value() As Variant
    If bPValueIsNull Then
        Value = Empty
    Else
        Value = dValue
    End If
End Property

Public Property Let Value(ByVal newDate As Variant)
    Dim Cancel As Integer
    If CheckValue(newDate) = False Then newDate = Empty
    RaiseEvent BeforeUpdate(Cancel)
    If Cancel = 0 Then
        If bInit And Not IsEmpty(newDate) Then
            CBxY.ListIndex = VBA.Year(newDate) - 1904
            CBxM.ListIndex = VBA.Month(newDate) - 1
        End If
        If (bPValueIsNull = IsEmpty(newDate)) Or (newDate <> dValue) Then
            If Not IsEmpty(newDate) Then
                dValue = newDate
            End If
            bPValueIsNull = IsEmpty(newDate)
            If bInit Then
                Refresh
            End If
        End If
        RaiseEvent AfterUpdate
    End If
End Property

Public Property Get DayLength() As calMonthLength
    DayLength = lPDayLength
End Property

Public Property Let DayLength(ByVal bDayLength As calMonthLength)
    Dim i As Long, v
    lPDayLength = bDayLength
    If bInit Then
        v = fWeekdayName(bDayLength)
        For i = 0 To 6
            mLabelButtons(i).Obj_CmBl.Caption = v(((i + lPFirstDay - 1) Mod 7))
        Next
    End If
End Property

Public Property Get MonthLength() As calMonthLength
    MonthLength = lPMonthLength
End Property

Public Property Let MonthLength(ByVal iMonthLength As calMonthLength)
    Dim i As Long, m
    lPMonthLength = iMonthLength
    If bInit Then
        CBxM.list = fMonthName(CLng(iMonthLength))
        Value = Value
    End If
End Property

Public Property Get YearFirst() As Boolean
    YearFirst = bPYearFirst
End Property

Public Property Let YearFirst(ByVal bYearFirst As Boolean)
    bPYearFirst = bYearFirst
    RenderLabel
End Property

Private Sub AAA__Properties_for_Day_button_Book()
End Sub

Public Property Set Main(ByVal theMain As cCalendar)
    Set mcMain = theMain
End Property

Private Property Get Main() As cCalendar
    Set Main = mcMain
End Property

Public Property Get Obj_Cmb() As MSForms.CommandButton
    Set Obj_Cmb = CmB
End Property

Public Property Set Obj_Cmb(ByVal vNewValue As MSForms.CommandButton)
    Set CmB = vNewValue
End Property

Public Property Get Obj_CmBl() As MSForms.label
    Set Obj_CmBl = CmBl
End Property

Public Property Set Obj_CmBl(ByVal vNewValue As MSForms.label)
    Set CmBl = vNewValue
End Property

Public Property Set Obj_CmBlNum(ByVal vNewValue As MSForms.label)
    Set CmBlNum = vNewValue
End Property

Public Property Get Obj_CmBlNum() As MSForms.label
    Set Obj_CmBlNum = CmBlNum
End Property

Private Sub AAA_Methods_Book()
End Sub

Public Sub AboutBox()
    MsgBox "Autori: r, Kris, Gabor"
End Sub

Public Sub Add( _
       ByVal fForm As MSForms.UserForm)
    Dim cFrame As MSForms.Frame
    Set cFrame = fForm.Controls.Add("Forms.Frame.1")
    With cFrame
        .Width = IIf(sPWidth < 0, cDefaultWidth, sPWidth)
        .Height = IIf(sPHeight < 0, cDefaultHeight, sPHeight)
    End With
    Add_Calendar_into_Frame cFrame
End Sub

Public Sub Add_Calendar_into_Frame(ByVal cFrame As MSForms.Frame)
    Dim i As Long
    Dim v(199)
    Dim w
    Dim dTemp As Date
    For i = 0 To 199
        v(i) = CStr(1904 + i)
    Next
    With cFrame
        .BackColor = BackColor
        .Caption = ""
        .SpecialEffect = 0
        .visible = bPVisible
    End With
    Set CLb = cFrame.Controls.Add("Forms.Label.1")
    Set CBxY = cFrame.Controls.Add("Forms.ComboBox.1")
    Set CBxM = cFrame.Controls.Add("Forms.ComboBox.1")
    ReDim mLabelButtons(6)
    ReDim mDayButtons(41)
    w = fWeekdayName(CInt(lPDayLength))
    For i = 0 To 6
        Set mLabelButtons(i) = New cCalendar
        Set mLabelButtons(i).Main = Me
        Set mLabelButtons(i).Obj_CmBl = cFrame.Controls.Add("Forms.Label.1")
        With mLabelButtons(i).Obj_CmBl
            .Caption = w(((i + lPFirstDay - 1) Mod 7))
            .ForeColor = DayFontColor
            .TextAlign = fmTextAlignCenter
            .BorderStyle = fmBorderStyleSingle
            .BorderColor = &H80000010
            If HeaderBackColor = -1 Then
                .BackColor = cBackColorInactive
                .BackStyle = fmBackStyleTransparent
            Else
                .BackColor = HeaderBackColor
                .BackStyle = fmBackStyleOpaque
            End If
        End With
    Next
    For i = 0 To 41
        Set mDayButtons(i) = New cCalendar
        Set mDayButtons(i).Main = Me
        Set mDayButtons(i).Obj_CmBl = cFrame.Controls.Add("Forms.Label.1")
        Set mDayButtons(i).Obj_CmBlNum = cFrame.Controls.Add("Forms.Label.1")
        With mDayButtons(i).Obj_CmBlNum
            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
        End With
        Set mDayButtons(i).Obj_Cmb = cFrame.Controls.Add("Forms.CommandButton.1")
        With mDayButtons(i).Obj_Cmb
            .BackStyle = fmBackStyleTransparent
        End With
    Next
    With CBxY
        .ListRows = 5
        .list = v
        .ListIndex = VBA.Year(dValue) - 1904
        .ShowDropButtonWhen = fmShowDropButtonWhenFocus
        .Font.Bold = True
        .MatchRequired = True
    End With
    With CBxM
        .ListRows = 12
        .list = fMonthName(lPMonthLength)
        .ListIndex = VBA.Month(dValue) - 1
        .ShowDropButtonWhen = fmShowDropButtonWhenFocus
        .Font.Bold = True
        .MatchRequired = True
    End With
    With CLb
        .ForeColor = TitleFontColor
        .TextAlign = fmTextAlignCenter
        .BackStyle = fmBackStyleTransparent
    End With
    ApplyFontChanges
    Refresh_Properities
    Move
End Sub

Private Sub ApplyFontChanges()
    Dim i As Long
    If Not PDayNewFont Is Nothing Then
        For i = 0 To 6
            With mLabelButtons(i).Obj_CmBl
                If .Font.Bold <> DayFont.Bold Then _
                   .Font.Bold = DayFont.Bold
                If .Font.Weight <> DayFont.Weight Then _
                   .Font.Weight = DayFont.Weight
                If .Font.Charset <> DayFont.Charset Then _
                   .Font.Charset = DayFont.Charset
                If .Font.Italic <> DayFont.Italic Then _
                   .Font.Italic = DayFont.Italic
                If .Font.Name <> DayFont.Name Then _
                   .Font.Name = DayFont.Name
                If .Font.Size <> DayFont.Size Then _
                   .Font.Size = DayFont.Size
                If DayFont.Strikethrough Then _
                   .Font.Strikethrough = True
                If DayFont.Underline Then _
                   .Font.Underline = True
            End With
        Next
    End If
    If Not PGridNewFont Is Nothing Then
        For i = 0 To 41
            With mDayButtons(i).Obj_CmBlNum
                If .Font.Bold <> GridFont.Bold Then _
                   .Font.Bold = GridFont.Bold
                If .Font.Weight <> GridFont.Weight Then _
                   .Font.Weight = GridFont.Weight
                If .Font.Charset <> GridFont.Charset Then _
                   .Font.Charset = GridFont.Charset
                If .Font.Italic <> GridFont.Italic Then _
                   .Font.Italic = GridFont.Italic
                If .Font.Name <> GridFont.Name Then _
                   .Font.Name = GridFont.Name
                If .Font.Size <> GridFont.Size Then _
                   .Font.Size = GridFont.Size
                If GridFont.Strikethrough Then _
                   .Font.Strikethrough = True
                If GridFont.Underline Then _
                   .Font.Underline = True
            End With
        Next
    End If
    If Not PTitleNewFont Is Nothing Then
        With CLb
            If .Font.Bold <> TitleFont.Bold Then _
               .Font.Bold = TitleFont.Bold
            If .Font.Weight <> TitleFont.Weight Then _
               .Font.Weight = TitleFont.Weight
            If .Font.Charset <> TitleFont.Charset Then _
               .Font.Charset = TitleFont.Charset
            If .Font.Italic <> TitleFont.Italic Then _
               .Font.Italic = TitleFont.Italic
            If .Font.Name <> TitleFont.Name Then _
               .Font.Name = TitleFont.Name
            If .Font.Size <> TitleFont.Size Then _
               .Font.Size = TitleFont.Size
            If TitleFont.Strikethrough Then _
               .Font.Strikethrough = True
            If TitleFont.Underline Then _
               .Font.Underline = True
        End With
    End If
End Sub

Public Sub Move( _
       Optional vLeft, _
       Optional vTop, _
       Optional vWidth, _
       Optional vHeight, _
       Optional vLayout)
    Dim i As Long, l As Currency, b As Currency, lc As Currency, bc As Currency
    Dim t As Long, b_ym As Currency, b_combo_m As Currency
    Const h_combo As Long = 16
    Const b_combo_y As Long = 42
    b_combo_m = IIf(lPMonthLength = mlENShort Or lPMonthLength = mlLocalShort, 42, 66)
    b_ym = b_combo_y + 2 + b_combo_m
    If bInit Then
        t = IIf(ShowDays, 7, 6)
        With CBxY.parent
            sPTop = IIf(IsMissing(vTop), IIf(top = -1, .top, top), vTop)
            sPLeft = IIf(IsMissing(vLeft), IIf(left = -1, .left, left), vLeft)
            sPHeight = IIf(IsMissing(vHeight), IIf(Height = -1, .Height, Height), vHeight)
            sPWidth = IIf(IsMissing(vWidth), IIf(Width = -1, .Width, Width), vWidth)
            l = Height
            b = Width
            l = Zero_Negative_Value(l - IIf(ShowTitle Or ShowDateSelectors, h_combo, 0) - 1)
            lc = CCur(l / t)
            bc = CCur(b / 7)
            b = bc * 7
            '            Debug.Print bc
            '            Debug.Print lc
            '            Debug.Print b
            '            Debug.Print l
        End With
        If ShowTitle Then
            With CLb
                .Width = Zero_Negative_Value(IIf(ShowDateSelectors, b - b_ym, b))
                .Height = h_combo
                .left = 0
            End With
        End If
        If ShowDateSelectors Then
            With CBxY
                .Width = b_combo_y
                .Height = h_combo
                .left = IIf(ShowTitle, CLb.Width, Int((b - b_ym) / 2)) + _
                                                                       IIf(YearFirst, 0, b_combo_m + 2)
            End With
            With CBxM
                .Width = b_combo_m
                .Height = h_combo
                .left = IIf(ShowTitle, CLb.Width, Int((b - b_ym) / 2)) + _
                                                                       IIf(YearFirst, b_combo_y + 2, 0)
            End With
        End If
        If ShowDays Then
            For i = 0 To 6
                With mLabelButtons(i).Obj_CmBl
                    .top = IIf(ShowTitle Or ShowDateSelectors, h_combo + 2, 0)
                    .left = (i Mod 7) * bc - IIf(i > 0, 1, 0)
                    .Height = lc
                    .Width = bc + IIf(i > 0, 1, 0)
                End With
            Next
        End If
        For i = 0 To 41
            With mDayButtons(i).Obj_Cmb
                .top = Int(i / 7) * lc + _
                                  IIf(ShowTitle Or ShowDateSelectors, h_combo + 2, 0) + _
                                  IIf(ShowDays, lc, 0)
                .left = (i Mod 7) * bc
                .Height = lc
                .Width = bc
            End With
            With mDayButtons(i).Obj_CmBl
                .top = mDayButtons(i).Obj_Cmb.top
                .left = mDayButtons(i).Obj_Cmb.left
                .Height = mDayButtons(i).Obj_Cmb.Height
                .Width = mDayButtons(i).Obj_Cmb.Width
            End With
            With mDayButtons(i).Obj_CmBlNum
                .top = Int(i / 7) * lc + _
                                  IIf(ShowTitle Or ShowDateSelectors, h_combo, 0) + _
                                  IIf(ShowDays, lc, 0) + 6
                .left = (i Mod 7) * bc + 3
                .Height = Zero_Negative_Value(lc - 6)
                .Width = Zero_Negative_Value(bc - 6)
            End With
        Next
    Else
        sPHeight = IIf(IsMissing(Height), cDefaultHeight, Height)
        sPWidth = IIf(IsMissing(Width), cDefaultWidth, Width)
    End If
End Sub

Public Sub NextDay()
    Dim d As Date
    d = dValue + 1
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub NextWeek()
    Dim d As Date
    d = dValue + 7
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub NextMonth()
    Value = SumMonthsToDate(dValue, 1)
End Sub

Public Sub NextYear()
    Dim d As Date
    d = VBA.DateSerial(CheckYear(VBA.Year(dValue) + 1), VBA.Month(dValue), VBA.Day(dValue))
    Value = d
End Sub

Public Sub PreviousDay()
    Dim d As Date
    d = dValue - 1
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub PreviousWeek()
    Dim d As Date
    d = dValue - 7
    d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d))
    Value = d
End Sub

Public Sub PreviousMonth()
    Value = SumMonthsToDate(dValue, -1)
End Sub

Public Sub PreviousYear()
    Dim d As Date
    d = VBA.DateSerial(CheckYear(VBA.Year(dValue) - 1), VBA.Month(dValue), VBA.Day(dValue))
    Value = d
End Sub

Public Sub Today()
    Value = VBA.Date
End Sub

Public Sub Refresh()
    Refresh_Panel VBA.Month(dValue), VBA.Year(dValue)
    ApplyFontChanges
End Sub

Private Sub AAA_Event_Book()
End Sub

Private Sub CBxY_Change()
    RenderLabel
    Refresh_Panel CBxM.ListIndex + 1, CBxY.ListIndex + 1904
End Sub

Private Sub CBxM_Change()
    RenderLabel
    Refresh_Panel CBxM.ListIndex + 1, CBxY.ListIndex + 1904
End Sub

Private Sub CmB_Click()
    Main.Value = dValue
    Main.Event_click = True
End Sub

Private Sub CmB_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    Main.Event_DblClick = True
End Sub

Private Sub CmB_KeyDown( _
        ByVal KeyCode As MSForms.ReturnInteger, _
        ByVal Shift As Integer)
    Dim newDate As Date
    newDate = dValue
    Select Case KeyCode
        Case 37
            newDate = newDate - 1
        Case 39
            newDate = newDate + 1
        Case 38
            newDate = newDate - 7
        Case 40
            newDate = newDate + 7
        Case 9
    End Select
    If newDate <> dValue Then
        Main.Value = newDate
        KeyCode = 0
    End If
End Sub

Private Sub Class_Initialize()
    bPShowDays = True
    bPShowTitle = True
    bPShowDateSelectors = True
    dValue = VBA.Date
    lPMonth = VBA.Month(VBA.Date)
    lPYear = VBA.Year(VBA.Date)
    lPDay = VBA.Day(VBA.Date)
    lPFontSize = 8
    lPMonthLength = 1
    lPDayLength = 1
    bPYearFirst = False
    lPTitleFontColor = &HA00000
    lPGridFontColor = &HA00000
    lPDayFontColor = &H0&
    lPFirstDay = 1
    lPBackColor = &H8000000F
    lPHeaderBackColor = 10053171
    lPUseDefaultBackColors = True
    lPSaturdayBackColor = &H80000002
    lPSundayBackColor = &HFFAA99
    bPVisible = True
    sPHeight = -1
    sPWidth = -1
    sPTop = -1
    sPLeft = -1
    sPControlTipText = ""
    Set TitleFont = New MSForms.NewFont
    With TitleFont
        .Name = "Arial"
        .Size = lPFontSize + 4
        .Bold = True
    End With
    Set DayFont = New MSForms.NewFont
    With DayFont
        .Name = "Arial"
        .Size = lPFontSize + 2
        .Bold = True
    End With
    Set GridFont = New MSForms.NewFont
    With GridFont
        .Name = "Arial"
        .Size = lPFontSize
    End With
End Sub

Private Sub Class_Terminate()
    Erase mDayButtons
    Erase mLabelButtons
    Set mcMain = Nothing
    Set PTitleNewFont = Nothing
    Set PDayNewFont = Nothing
    Set PGridNewFont = Nothing
    Set CBxY = Nothing
    Set CBxM = Nothing
    Set CmB = Nothing
    Set CLb = Nothing
    Set CmBl = Nothing
End Sub

Private Sub AAA_Private_Function_Book()
End Sub

Private Function ArraY_Days(ByVal lMonth As Long, ByVal lYear As Long)
    Dim v(41) As Date, i As Long, g As Long, l As Long, p As Long
    i = VBA.DateTime.Weekday( _
        VBA.DateSerial(lYear, lMonth, 1), 1 + lPFirstDay Mod 7) - 1
    If i = 0 Then i = 7
    g = VBA.Day(VBA.DateSerial(lYear, lMonth + 1, 0)) + i
    p = 1
    For l = i To 0 Step -1
        v(l) = VBA.DateSerial(lYear, lMonth, p)
        p = p - 1
    Next
    p = 0
    For l = i To g
        p = p + 1
        v(l) = VBA.DateSerial(lYear, lMonth, p)
    Next
    For l = g To 41
        v(l) = VBA.DateSerial(lYear, lMonth, p)
        p = p + 1
    Next
    ArraY_Days = v
End Function

Private Sub RenderLabel()
    Dim b As Currency, b_ym As Currency, b_combo_m As Long
    Const b_combo_y As Long = 42
    b_combo_m = IIf(lPMonthLength = mlENShort Or lPMonthLength = mlLocalShort, 42, 66)
    b_ym = b_combo_y + 2 + b_combo_m
    If bInit Then
        b = CBxY.parent.Width
        If bPYearFirst Then
            CLb.Caption = CBxY.Value & " " & CBxM.Value
        Else
            CLb.Caption = CBxM.Value & " " & CBxY.Value
        End If
        CLb.Width = Zero_Negative_Value(IIf(ShowDateSelectors, b - b_ym, b))
        CBxM.Width = b_combo_m
        CBxY.left = IIf(ShowTitle, CLb.Width, CCur((b - b_ym) / 2)) + _
                                                                    IIf(YearFirst, 0, b_combo_m + 2)
        CBxM.left = IIf(ShowTitle, CLb.Width, CCur((b - b_ym) / 2)) + _
                                                                    IIf(YearFirst, b_combo_y + 2, 0)
    End If
End Sub

Private Function bInit() As Boolean
    If Not CBxY Is Nothing Then bInit = True
End Function

Private Function SumMonthsToDate(dDate As Date, Optional lMonth As Long = 1) As Date
    Dim d As Date
    d = VBA.DateSerial( _
        VBA.Year(dDate), _
        VBA.Month(dDate) + lMonth, _
        fMin( _
        VBA.Day(dDate), _
        VBA.Day( _
        VBA.DateSerial( _
        VBA.Year(dDate), _
        VBA.Month(dDate) + 1 + VBA.Abs(lMonth), _
        0))))
    If d = VBA.DateSerial(CheckYear(VBA.Year(d)), VBA.Month(d), VBA.Day(d)) Then
        SumMonthsToDate = d
    Else
        SumMonthsToDate = dDate
    End If
End Function

Private Function fMin(vFirstValue, ParamArray vValues())
    Dim i As Long
    fMin = vFirstValue
    If IsMissing(vValues) = False Then
        For i = 0 To UBound(vValues)
            If fMin > vValues(i) Then
                fMin = vValues(i)
            End If
        Next
    End If
End Function

Private Function fMonthName(lIndex As Long)
    Dim m(11), i As Long, v
    lIndex = lIndex Mod 4
    If Int(lIndex / 2) Then
        If lIndex Mod 2 Then
            v = Array("Jan", "Feb", "Mar", "Apr", "May", _
                      "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
        Else
            v = Array("January", "February", "March", _
                      "April", "May", "June", "July", "August", _
                      "September", "October", "November", "December")
        End If
        fMonthName = v
    Else
        For i = 0 To 11
            m(i) = VBA.Strings.MonthName(i + 1, lIndex Mod 2)
        Next
        fMonthName = m
    End If
End Function

Private Function fWeekdayName(lIndex As Long)
    Dim m(6), i As Long, v
    lIndex = lIndex Mod 4
    If Int(lIndex / 2) Then
        If lIndex Mod 2 Then
            v = Array("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
        Else
            v = Array("Monday", "Tuesday", "Wednestay", _
                      "Thursday", "Friday", "Saturday", "Sunday")
        End If
        fWeekdayName = v
    Else
        For i = 0 To 6
            m(i) = VBA.Strings.WeekdayName(i + 1, lIndex Mod 2, vbMonday)
        Next
        fWeekdayName = m
    End If
End Function

Private Function CheckYear(ByVal lYear As Long) As Long
    Select Case lYear
        Case Is < 1904
            CheckYear = 1904
        Case 1904 To 2103
            CheckYear = lYear
        Case Else
            CheckYear = 2103
    End Select
End Function

Private Sub AAA_Private_Sub_Book()
End Sub

Public Property Let Event_DblClick(ByVal X As Boolean)
    RaiseEvent DblClick
End Property

Private Property Get Event_DblClick() As Boolean
    Event_DblClick = False
End Property

Public Property Let Event_click(ByVal X As Boolean)
    RaiseEvent Click
End Property

Private Property Get Event_click() As Boolean
    Event_click = False
End Property

Private Sub Refresh_Properities()
    With Me
        .BackColor = .BackColor
        .ControlTipText = .ControlTipText
        .DayFontColor = .DayFontColor
        .DayLength = .DayLength
        .GridFontColor = .GridFontColor
        .MonthLength = .MonthLength
        If .UseDefaultBackColors = False Then
            .SaturdayBackColor = .SaturdayBackColor
            .SundayBackColor = .SundayBackColor
            .HeaderBackColor = .HeaderBackColor
        End If
        .ShowDateSelectors = .ShowDateSelectors
        .ShowDays = .ShowDays
        .ShowTitle = .ShowTitle
        .TabIndex = .TabIndex
        .TabStop = .TabStop
        .TitleFontColor = .TitleFontColor
        .ValueIsNull = .ValueIsNull
        .YearFirst = .YearFirst
    End With
End Sub

Private Sub Refresh_Selected_Day(ByVal dValue As Date)
    Dim i As Long, c As MSForms.label
    For i = 0 To 41
        If mDayButtons(i).Value = dValue And Not bPValueIsNull Then
            On Error Resume Next
            mDayButtons(i).Obj_Cmb.SetFocus
            On Error GoTo 0
            With mDayButtons(i).Obj_CmBl
                .BackStyle = fmBackStyleOpaque
                .BackColor = cBackColorInactive
                .ForeColor = cDayFontColorSelected
            End With
            lPMonth = VBA.Month(dValue)
            lPYear = VBA.Year(dValue)
            lPDay = VBA.Day(dValue)
        End If
    Next
End Sub

Private Sub Refresh_Panel(ByVal lMonth As Long, ByVal lYear As Long)
    Dim v, i As Long, l As Long
    Dim iDay As Long
    If bInit Then
        v = ArraY_Days(lMonth, lYear)
        For i = 0 To 41
            mDayButtons(i).Value = v(i)
            With mDayButtons(i).Obj_CmBlNum
                If .Caption <> VBA.Day(v(i)) Then
                    .Caption = VBA.Day(v(i))
                End If
                If lMonth = VBA.Month(v(i)) Then
                    If .ForeColor <> GridFontColor Then
                        .ForeColor = GridFontColor
                    End If
                Else
                    If .ForeColor <> cDayFontColorInactive Then
                        .ForeColor = cDayFontColorInactive
                    End If
                End If
            End With
            With mDayButtons(i).Obj_CmBl
                If .BackStyle = fmBackStyleOpaque Then
                    .BackStyle = fmBackStyleTransparent
                End If
                If UseDefaultBackColors = False Then
                    iDay = VBA.DateTime.Weekday(v(i))
                    If iDay = vbSaturday Then
                        If .BackColor <> lPSaturdayBackColor Then
                            .BackColor = lPSaturdayBackColor
                        End If
                        If .BackStyle <> fmBackStyleOpaque Then
                            .BackStyle = fmBackStyleOpaque
                        End If
                    ElseIf iDay = vbSunday Then
                        If .BackColor <> lPSundayBackColor Then
                            .BackColor = lPSundayBackColor
                        End If
                        If .BackStyle <> fmBackStyleOpaque Then
                            .BackStyle = fmBackStyleOpaque
                        End If
                    End If
                End If
            End With
            If CheckValue(v(i)) = False Then
                mDayButtons(i).Obj_Cmb.Locked = True
            Else
                If mDayButtons(i).Obj_Cmb.Locked = True Then
                    mDayButtons(i).Obj_Cmb.Locked = False
                End If
            End If
        Next
        If UseDefaultBackColors = False Then
            For l = 0 To 6
                If mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleTransparent Then _
                                                         mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleOpaque
                If mLabelButtons(l).Obj_CmBl.BackColor <> lPHeaderBackColor Then _
                                                       mLabelButtons(l).Obj_CmBl.BackColor = lPHeaderBackColor
            Next
        Else
            For l = 0 To 6
                If mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleOpaque Then _
                                                         mLabelButtons(l).Obj_CmBl.BackStyle = fmBackStyleTransparent
            Next
        End If
        If lMonth = VBA.Month(dValue) And lYear = VBA.Year(dValue) Then
            Refresh_Selected_Day dValue
        Else
            lPMonth = 0
            lPYear = 0
            lPDay = 0
        End If
    End If
End Sub

Private Function CheckValue(d) As Boolean
    If VarType(d) = vbDate Then
        Select Case d
            Case 1462 To 74510
                CheckValue = CLng(d) = d
        End Select
    End If
End Function

Private Function Zero_Negative_Value(sNumber As Single) As Single
    If sNumber > 0 Then
        Zero_Negative_Value = sNumber
    End If
End Function



'clDragDropForm	2

Option Explicit

'--------------------------------------------------------------------------------------------------------------------------
' Author    : Manfred van den Noort
' Copyright : © 2020 worksheetsvba.com, all rights reserved
' Date      : 2020-12-07
' Version   : 1.0
' Purpose   : Enable ListBox Drag & Drop Advanced Version
'
' You are free to use, change and distribute the code in this class module for your own projects,
'       however this header with copyright notice should remain intact
' You may not publish the code in this class module, for example on a web site, without the explicit consent of the author.
'--------------------------------------------------------------------------------------------------------------------------

Implements IDragDropForm

Private frmDragDrop As MSForms.UserForm
Private lstbxDragSource As MSForms.ListBox
Private colListBoxes As Collection
Private iDropType As DropTypes, iDropEffect As DropEffects
Private bAllowDropInSameListbox As Boolean
Private aSelectedDragItems As Variant
Private sDragSourceGroupName As String

Public Enum DropEffects
    CopyItem = fmDropEffectCopy
    MoveItem = fmDropEffectMove
End Enum

Public Enum DropTypes
    Alphabetic = 1
    BottomOfList = 2
    CursorPosition = 3
    Numeric = 4
End Enum

Private Sub Class_Initialize()
    Set colListBoxes = New Collection
    'set default values
    iDropEffect = MoveItem
    iDropType = BottomOfList
    bAllowDropInSameListbox = False
End Sub

Private Property Set IDragDropForm_DragDropForm(ByRef oFrm As Object)
    Set frmDragDrop = oFrm
End Property

Private Property Let IDragDropForm_DropEffect(ByVal iVal As DropEffects)
    iDropEffect = iVal
End Property

Friend Property Get DropEffect() As DropEffects
    DropEffect = iDropEffect
End Property

Private Property Let IDragDropForm_DropType(ByVal iVal As DropTypes)
    iDropType = iVal
End Property

Friend Property Get DropType() As DropTypes
    DropType = iDropType
End Property

Private Property Let IDragDropForm_AllowDropInSameListbox(ByVal bValue As Boolean)
    bAllowDropInSameListbox = bValue
End Property

Friend Property Get AllowDropInSameListbox() As Boolean
    AllowDropInSameListbox = bAllowDropInSameListbox
End Property

Friend Property Let SelectedDragItems(ByVal aValue As Variant)
    aSelectedDragItems = aValue
End Property

Friend Property Get SelectedDragItems() As Variant
    SelectedDragItems = aSelectedDragItems
End Property

Friend Property Set DragSource(ByRef oListBox As MSForms.ListBox)
    Set lstbxDragSource = oListBox
End Property

Friend Property Get DragSource()
    Set DragSource = lstbxDragSource
End Property

Friend Property Let DragSourceGroupName(sValue As String)
    sDragSourceGroupName = sValue
End Property

Friend Property Get DragSourceGroupName() As String
    DragSourceGroupName = sDragSourceGroupName
End Property

Private Sub IDragDropForm_GetListboxes(ParamArray aListBoxGroupNames() As Variant)
    Dim ctl As control, oDragDropListBox As clDragDropListbox, iTabIndex As Integer, sActiveListbox As String, i As Integer
    iTabIndex = (2 ^ 15) - 1
    For Each ctl In frmDragDrop.Controls
        If TypeName(ctl) = "ListBox" Then
            If ctl.Enabled And Not ctl.Locked Then
                'SetFocus is used, otherwise the first Y in the MouseMove event is not always correct
                ctl.SetFocus
                If ctl.TabIndex < iTabIndex Then
                    iTabIndex = ctl.TabIndex
                    sActiveListbox = ctl.Name
                End If
            End If
            Set oDragDropListBox = New clDragDropListbox
            With oDragDropListBox
                Set .ParentForm = Me
                Set .DragDropListBox = ctl
                .SetItemRowHeight
                For i = 0 To UBound(aListBoxGroupNames)
                    If InStr(aListBoxGroupNames(i), "~") > 0 Then
                        If Split(aListBoxGroupNames(i), "~")(0) = ctl.Name Then
                            .GroupName = Split(aListBoxGroupNames(i), "~")(1)
                        End If
                    End If
                Next
            End With
            colListBoxes.Add oDragDropListBox
        End If
    Next
    If sActiveListbox <> "" Then
        frmDragDrop.Controls(sActiveListbox).SetFocus
    End If
End Sub

Friend Sub IncreaseSelectedItemIndex(iIdx As Long)
    aSelectedDragItems(iIdx) = aSelectedDragItems(iIdx) + 1
End Sub

Private Sub IDragDropForm_TerminateDragDrop()
    Set colListBoxes = Nothing
End Sub


'clDragDropListbox	2

Option Explicit

'--------------------------------------------------------------------------------------------------------------------------
' Author    : Manfred van den Noort
' Copyright : © 2020 worksheetsvba.com, all rights reserved
' Date      : 2020-12-07
' Version   : 1.0
' Purpose   : Enable ListBox Drag & Drop Advanced Version
'
' You are free to use, change and distribute the code in this class module for your own projects,
'       however this header with copyright notice should remain intact
' You may not publish the code in this class module, for example on a web site, without the explicit consent of the author.
'--------------------------------------------------------------------------------------------------------------------------

Private oParentForm As clDragDropForm
Private WithEvents LstBx As MSForms.ListBox
Private sngItemHeight As Single
Private lNewListIdx As Long
Private sGroupName As String
Private bDeselectValues As Boolean

Private Sub Class_Initialize()
    lNewListIdx = -1
End Sub

Friend Property Set ParentForm(ByRef oValue As clDragDropForm)
    Set oParentForm = oValue
End Property

Friend Property Set DragDropListBox(ByRef oValue As MSForms.ListBox)
    Set LstBx = oValue
End Property

Friend Property Let GroupName(sValue As String)
    sGroupName = sValue
End Property

Private Sub LstBx_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim oDataObject As DataObject, sItemValue As String, i As Long, j As Long, k As Long, aSelectedItems As Variant, lEffect As Long, lItemClicked As Long, sColValues As String
    If Button = 1 Then
        If LstBx.multiSelect = fmMultiSelectSingle Then
            If LstBx.ListIndex > -1 Then
                For i = 1 To LstBx.columnCount
                    sItemValue = sItemValue & "~" & LstBx.list(LstBx.ListIndex, i - 1)
                Next
                sItemValue = Mid(sItemValue, 2)
            End If
        Else
            lItemClicked = GetMouseOverRow(Y)
            For i = 0 To LstBx.ListCount - 1
                If LstBx.SELECTED(i) Or i = lItemClicked Then
                    LstBx.SELECTED(i) = True
                    sColValues = ""
                    For k = 1 To LstBx.columnCount
                        sColValues = sColValues & "~" & LstBx.list(i, k - 1)
                    Next
                    sItemValue = sItemValue & "~~" & Mid(sColValues, 2)
                    If j = 0 Then
                        ReDim aSelectedItems(0)
                    Else
                        ReDim Preserve aSelectedItems(j)
                    End If
                    aSelectedItems(j) = i
                    j = j + 1
                End If
            Next
            sItemValue = Mid(sItemValue, 3)
        End If
        If sItemValue <> "" Then
            If LstBx.multiSelect = fmMultiSelectSingle Then
                oParentForm.SelectedDragItems = Array(LstBx.ListIndex)
            Else
                oParentForm.SelectedDragItems = aSelectedItems
            End If
            oParentForm.DragSourceGroupName = sGroupName
            Set oParentForm.DragSource = LstBx
            Set oDataObject = New DataObject
            oDataObject.SetText sItemValue
            lEffect = oDataObject.StartDrag
        End If
    Else
        'set ListIndex on new added item in case of fmMultiSelectSingle in same listbox
        If lNewListIdx >= 0 Then
            LstBx.ListIndex = lNewListIdx
            lNewListIdx = -1
        End If
        'reset multiselect dragsource in case of MoveItem
        If IsObject(oParentForm.DragSource) And bDeselectValues Then
            bDeselectValues = False
            If oParentForm.DragSource.multiSelect <> fmMultiSelectSingle Then
                For i = 0 To oParentForm.DragSource.ListCount - 1
                    oParentForm.DragSource.SELECTED(i) = False
                Next
            End If
        End If
    End If
End Sub

Private Sub LstBx_BeforeDragOver(ByVal Cancel As MSForms.ReturnBoolean, ByVal Data As MSForms.DataObject, ByVal X As Single, ByVal Y As Single, ByVal DragState As Long, ByVal Effect As MSForms.ReturnEffect, ByVal Shift As Integer)
    Dim i As Long, iActiveItemRow As Long
    Cancel = True
    If (oParentForm.DragSource Is LstBx And (Not oParentForm.AllowDropInSameListbox Or oParentForm.DropType <> CursorPosition Or LstBx.multiSelect <> fmMultiSelectSingle)) _
        Or LstBx.Locked Or sGroupName <> oParentForm.DragSourceGroupName Or oParentForm.DragSource.columnCount <> LstBx.columnCount Then
        Effect = fmDropEffectNone
    Else
        Effect = oParentForm.DropEffect
        If oParentForm.DropType = CursorPosition Then
            With LstBx
                iActiveItemRow = GetMouseOverRow(Y)
                If oParentForm.AllowDropInSameListbox Then
                    If iActiveItemRow = LstBx.ListCount Then
                        oParentForm.DragSource.SetFocus
                    Else
                        LstBx.SetFocus
                    End If
                End If
                If DragState = fmDragStateLeave Then
                    If oParentForm.AllowDropInSameListbox And LstBx Is oParentForm.DragSource Then
                        'highlight selected items
                        If LstBx.multiSelect = fmMultiSelectSingle Then
                            LstBx.ListIndex = oParentForm.SelectedDragItems(0)
                        Else
                            For i = 0 To LstBx.ListCount - 1
                                LstBx.SELECTED(i) = False
                            Next
                            For i = 0 To UBound(oParentForm.SelectedDragItems)
                                LstBx.SELECTED(oParentForm.SelectedDragItems(i)) = True
                            Next
                        End If
                    Else
                        For i = 0 To .ListCount - 1
                            .SELECTED(i) = False
                        Next
                    End If
                Else
                    'highlight items with mousemove
                    For i = 0 To .ListCount - 1
                        If i = iActiveItemRow Then
                            .SELECTED(i) = True
                        Else
                            .SELECTED(i) = False
                        End If
                    Next
                End If
            End With
        End If
    End If
End Sub

Private Sub LstBx_BeforeDropOrPaste(ByVal Cancel As MSForms.ReturnBoolean, ByVal action As Long, ByVal Data As MSForms.DataObject, ByVal X As Single, ByVal Y As Single, ByVal Effect As MSForms.ReturnEffect, ByVal Shift As Integer)
    Dim i As Long, j As Long, iInsertPosition As Long, aItemValues() As String, aColValues() As String
    Cancel = True
    Effect = oParentForm.DropEffect
    aItemValues = Split(Data.GetText, "~~")
    For i = 0 To UBound(aItemValues)
        aColValues = Split(aItemValues(i), "~")
        With LstBx
            Select Case oParentForm.DropType
                Case Alphabetic
                    For j = 0 To .ListCount - 1
                        If .list(j) > aColValues(0) Then
                            Exit For
                        End If
                    Next
                    iInsertPosition = j
                Case BottomOfList
                    iInsertPosition = .ListCount
                Case CursorPosition
                    If i = 0 Then
                        iInsertPosition = GetMouseOverRow(Y)
                    Else
                        iInsertPosition = iInsertPosition + 1
                    End If
                Case Numeric
                    For j = 0 To .ListCount - 1
                        If val(.list(j)) > val(aColValues(0)) Then
                            Exit For
                        End If
                    Next
                    iInsertPosition = j
            End Select
            .AddItem aColValues(0), iInsertPosition
            For j = 1 To UBound(aColValues)
                .list(iInsertPosition, j) = aColValues(j)
            Next
            If oParentForm.DragSource Is LstBx Then
                For j = 0 To UBound(oParentForm.SelectedDragItems)
                    If iInsertPosition < oParentForm.SelectedDragItems(j) Then
                        oParentForm.IncreaseSelectedItemIndex j
                    End If
                Next
            End If
            .ListIndex = iInsertPosition
            lNewListIdx = iInsertPosition
        End With
    Next
    If oParentForm.DropEffect = MoveItem Then
        With oParentForm.DragSource
            For i = UBound(oParentForm.SelectedDragItems) To 0 Step -1
                .RemoveItem oParentForm.SelectedDragItems(i)
                If oParentForm.SelectedDragItems(i) < lNewListIdx Then
                    lNewListIdx = lNewListIdx - 1
                End If
            Next
            If Not oParentForm.DragSource Is LstBx Then
                'reset lNewListIdx because this is only used for drop in same listbox (because then after drop the listindex is reset to wrong value)
                lNewListIdx = -1
                If oParentForm.DragSource.multiSelect = fmMultiSelectSingle Then
                    .ListIndex = -1
                Else
                    bDeselectValues = True
                End If
            End If
        End With
        LstBx.SetFocus
    End If
    Erase oParentForm.SelectedDragItems
End Sub

Private Function GetMouseOverRow(ByVal Ypos As Single) As Long
    Dim iItemRow As Long
    With LstBx
        If sngItemHeight > 0 Then
            iItemRow = .TopIndex + Ypos / sngItemHeight
        End If
        If iItemRow > .ListCount - 1 Then
            iItemRow = .ListCount
        End If
    End With
    GetMouseOverRow = iItemRow
End Function

Friend Sub SetItemRowHeight()
    'get ItemHeight by setting the TopIndex to Listount - 1
    'if TopIndex > 0 then all rows in the listbox are filled
    'if the listbox is not completely filled, temporary items are added until TopIndex > 0
    Dim lOldTopIndex As Long, lTempTopIndex As Long, i As Long, j As Long
    With LstBx
        If .ListCount > 0 Then
            lOldTopIndex = .TopIndex
            .TopIndex = .ListCount - 1
            lTempTopIndex = .TopIndex
        End If
        Do While lTempTopIndex = 0
            i = i + 1
            .AddItem i
            .TopIndex = .ListCount - 1
            lTempTopIndex = .TopIndex
        Loop
        sngItemHeight = .Height / (.ListCount - .TopIndex)
        For j = 1 To i
            .RemoveItem .ListCount - 1
        Next
        If .ListCount > 0 Then
            .TopIndex = lOldTopIndex
        End If
    End With
End Sub



'clsMsoImage	2

Public WithEvents LabelEvents As MSForms.label

Private Sub LabelEvents_Click()
    uImageMso.TextBox1.TEXT = LabelEvents.Caption
    uImageMso.TextBox1.SelStart = 0
    uImageMso.TextBox1.SelLength = Len(uImageMso.TextBox1.TEXT)
End Sub


'cStack	2

'Class module cStack
'Uses a VBA Collection as the stack data structure

Option Explicit

Dim pStack As Collection

Private Sub Class_Initialize()
    Set pStack = New Collection
End Sub

Private Sub Class_Terminate()
    Set pStack = Nothing
End Sub

Public Function Push(newItem As cStackItem) As cStackItem
    With pStack
        .Add newItem
        Set Push = .item(.count)
    End With
End Function

Public Function Pop() As cStackItem
    With pStack
        If .count > 0 Then
            Set Pop = .item(.count)
            .Remove .count
        End If
    End With
End Function

Public Function count() As Long
    count = pStack.count
End Function

Public Sub Dump()
    Dim i As Long
    Dim stackItem As cStackItem
    With pStack
        If .count = 0 Then Debug.Print "Empty"
        For i = .count To 1 Step -1
            Set stackItem = .item(i)
            With stackItem
                Debug.Print i; .baseCell.OFFSET(.rowOffset).Address(False, False), Hex(.hwndParent), "Offset " & .rowOffset
            End With
        Next
    End With
End Sub


'cStackItem	2

'Class module cStackItem
'User-defined type for a stack item

Option Explicit

Public baseCell As Range
Public rowOffset As Long
#If VBA7 Then
    Public hwndParent As LongPtr
#Else
    Public hwndParent As Long
#End If

'IDragDropForm	2

Option Explicit

Public Property Set DragDropForm(ByRef oFrm As Object)
End Property

Public Property Let DropEffect(ByVal iVal As DropEffects)
End Property

Public Property Let DropType(ByVal iVal As DropTypes)
End Property

Public Property Let AllowDropInSameListbox(ByVal bValue As Boolean)
End Property

Public Sub GetListboxes(ParamArray aListBoxGroupNames() As Variant)
End Sub

Public Sub TerminateDragDrop()
End Sub


'LogFile	2

Rem INCLUDE class  ApplicationError
Rem INCLUDE class  RegistryEditor
Rem INCLUDE module mLogFile

Option Explicit
Option Base 1
'
' Log File Class
' |> Brian J. Satola
' |> https://chejunkie.com
' |> brian.satola@gmail.com
'
'==========================================================================================================================
' This class provides several methods for logging intermediate calculation results.
'==========================================================================================================================
' These routines rely on each other, so you should import this entire class module into your project
'   rather than just copying and pasting individual procedures into other modules.
' The Registry Editor class and Application Error class are also required.
'--------------------------------------------------------------------------------------------------------------------------
'
'==========================================================================================================================
' Public Subs, Functions and Properties - oh my!
'==========================================================================================================================
'   |> Get | --- About                  :: Returns description of the class.
'   |> --------- CreateLogFile          :: Creates a logfile for output and stores it in the specified [storageDirectory].
'   |> Get | Let DirectoryPath          :: Returns the directory location of the current logfile.
'   |> Get | --- FilePath               :: Returns the file path of the current logfile.
'   |> --------- LogBlankLine           :: Outputs a blank line to the logfile.
'   |> Get | --- LogFileName            :: Returns the file name of the current logfile.
'   |> --------- LogDividingLine        :: Outputs a line to the logfile.
'   |> --------- Log              :: Outputs strOutputMessage to the logfile.
'   |> Get | --- Name                   :: Returns name of the class.
'   |> --------- OpenDirectory          :: Opens the directory that the current logfile is stored in.
'   |> --------- OpenLogFile            :: Opens the current logfile (iff it exists).
'   |> Get | Let RegDirectoryScratch    :: Retrieves or sets the output directory used to save the logfile.
'   |> --------- RemoveRegistrySetting  :: Removes the registry setting for the default save location.
'   |> Get | --- Version                :: Returns version string for the class [e.g. #.# (year)].
'
'==========================================================================================================================
' References
'==========================================================================================================================
Dim m_RegEdit       As New RegistryEditor
Dim m_AppErr        As New ApplicationError

'==========================================================================================================================
' Application constants
'==========================================================================================================================
Private Const C_BASE_KEY                As Long = &H80000001        ' HKey_Current_User (HKCU)
Private Const C_KEY_NAME                As String = "Software\Microsoft\Office\Excel\TRUxl"        'registry location used to store values.
Private Const C_REG_SCRATCH             As String = "DirectoryScratch"

Private Const C_NAME                    As String = "LogFile.cls"
Private Const C_DEFAULT_LOG_FILE_NAME   As String = "Logger"
Private Const C_MAX_LEN                 As Integer = 96        ' size/length of header boarders. (MUST BE AN EVEN NUMBER!)
' 96 seems to be a good size for wide-screen, else 90 or lower.

Private Enum LogOutputType
    LogAppend = 1
    LogOutput = 2
End Enum

Public Enum LogFormatType
    LogTitle
    LogHeader1
    LogHeader2
    LogDefault
    LogBullet1
    LogBullet2
    LogNoFormat
    LogLineThru
End Enum

'==========================================================================================================================
' Private variables
'==========================================================================================================================
Private m_LogFileExists             As Boolean
Private m_FilePath                  As String
Private m_DirectoryPath             As String
Private m_FileName                  As String
Private m_FileExt                   As String

'==========================================================================================================================
' Error constants
'==========================================================================================================================
Const C_ERR_OFFSET = 100
Private Const C_ERR_NO_ERROR            As Long = 0
Private Const C_ERR_INVALID_FILE        As Long = C_ERR_OFFSET + vbObjectError + 1
Private Const C_ERR_INVALID_DIRECTORY   As Long = C_ERR_OFFSET + vbObjectError + 2
Private Const C_ERR_LOG_FILE_DNE        As Long = C_ERR_OFFSET + vbObjectError + 3
Private Const C_ERR_INVALID_INPUT       As Long = C_ERR_OFFSET + vbObjectError + 4
Private Const C_ERR_REGISTRY_CLASS      As Long = C_ERR_OFFSET + vbObjectError + 5
Private Const C_ERR_TYPE_MISMATCH       As Long = C_ERR_OFFSET + vbObjectError + 6

'''
''' Returns the application error object of the class.
'''
Public Property Get AppErr() As ApplicationError

    Set AppErr = m_AppErr
    
End Property

'''
''' Creates a folder according to the specified <path> [fullPath].
'''
Private Function CreateFolder(ByVal fullPath As String) As Boolean

    If (fullPath <> vbNullString) Then        'create folder
        '// Ensure correct input format
        If (VBA.Right$(fullPath, 1) = "\") Then
            fullPath = VBA.left$(fullPath, VBA.Len(fullPath) - 1)
        End If
        '// Create folder
        On Error GoTo ERR_HANDLER
        MkDir fullPath
        CreateFolder = True
        Exit Function
    End If
    
ERR_HANDLER:
End Function

'''
''' This method is just to change the order of the inputs for the CreateLogFile method.
''' Due to legacy support, the original method could not be directly changed etc.
'''
Public Function CreateLogFileByName(Optional ByRef LogFileName As String, Optional storageDirectory As String) As Boolean
    CreateLogFileByName = CreateLogFile(storageDirectory, LogFileName)
End Function

'''
''' Generates a string of singleCharaster(s) of length stringLength.
''' Used to generate outputs for e.g. header boarders.
'''
Private Function GetBufferString(singleCharacter As String, stringLength As Integer) As String

    Dim i       As Long

    m_AppErr.clear
    
    If (VBA.Len(singleCharacter) = 1) Then
        For i = 1 To stringLength
            GetBufferString = GetBufferString & singleCharacter
        Next i
    Else        'display application error
        With m_AppErr
            .Number = C_ERR_INVALID_INPUT
            .source = "GetBufferString(...)"
            .Description = GetAppErrDescription(.Number)
            .DisplayMessage
        End With
    End If

End Function

'''
''' Version string of the current class.
'''
Public Property Get Version() As String

    '==========================================================================================================================
    ' Class changelog here.
    '==========================================================================================================================
   
    'Version = "Version 1.0 (2015)"  ' Initial (official) release.
    'Version = "Version 2.0 (2015)"  ' Cleaned up code, including procedure descriptions.
    '   |> Added "About" Get property for use in e.g. display messages.
    '   |> Added "Version" Get property to track class changes.
    '   |> Added "Name" Get property (literal defintion).
    '   |> Added 'C_MAX_LEN' and "GetBufferString" to generalise the procedures for
    '       use in defining header titles, line outputs, etc.
    '   |> Updated "Log" procedure to use "GetBufferString" instead of literals.
    '   |> Updated "GetAppErrDisplayMessage" to include titles in dislpay messages.
    '   |> Removed the 'RegistryTRUxl.cls' reference; instead, directly handle read/write
    '       to the srcratch-directory location defined in the registry. This required
    '       adding a local reference to 'Registry.cls', and adding the appropriate
    '       property Get|Let procedures for "RegDirectoryScratch".
    '   |> Added "CreateFolder" procedure.
    '   |> Updated class constructor. If no valid "RegDirectoryScratch" definition exists,
    '       then "CreateFolder" is used to automatically create a scratch folder in the
    '       directory of the workbook to use for outputs. "RegDirectoryScratch" is then
    '       updated to match the new definition. If a valid "RegDirectoryScratch"
    '       defintion exists, then no changes are made.
    'Version = "Version 2.5 (2016)" ' SATOLA, BRIAN J. 26-AUG. 2016:
    '   |> Syntax corrections to module-level variables (prefix:= "m_").
    '   |> Changed enumeration names and values to use Pascal casing.
    '   |> Updated constructor print statement to use new "Name" property.
    '   |> Re-simplified ;) "AppErrDisplayMessage".
    '   |> Updated 'm_AppErr.Source =' definitions (simple formatting changes).
    '   |> FIXED CRITICAL ERROR in class constructor made during version 2 release.
    '       "RegDirectoryScratch" was returning Null to 'm_directoryPath',
    '       a string variable, which was preventing the routine from auto-creating
    '       a directory storage location for the logfile outputs.
    '   |> Modified Let RegDirectoryScratch to force use of trailing slash "\".
    '   |> Fixed formatting problem for titles in the Log method.
    'Version = "3.0 (2017+)"  ' SATOLA, BRIAN J.
    '   |> Updated to use newest registry class (now called RegistryEditor).
    '   |> Removed the Let FileName property, CreateLogFile method already defines the name.
    '   |> Get FileName property is now called FileName_ to avoid naming conflicts.
    '   |> Reformated comments to new convention (for later automation).
    '   |> Replaced application error properties and methods with a new error object/holder.
    '   |> Renamed GetPaddedString to GetBufferString (which is more descriptive).
    '   |> Modified the log file header printed in CreateLogFile to use C_MAX_LEN.
    '   |> Removed the 'Version' string from the get Version property (more intuitive this way).
    '   |> Added RemoveRegistrySetting() for testing purposes.
    Version = "3.1 (2018)"        ' SATOLA, BRIAN J.
    '   |> Automatically define default file name if user does not provide:
    '       C_DEFAULT_LOG_FILE_NAME.
                                    
End Property

'''
''' Returns a string describing the class.
'''
Public Property Get About() As String

    About = "ChE Junkie VBA LogFile class module, v" & Me.Version & "." & VBA.vbCrLf & VBA.vbCrLf
    About = About & "For additional details see https://chejunkie.com/knowledge-base/the-log-file-class-vba/"
    
End Property

'''
''' Returns the name of the class.
'''
Public Property Get Name() As String
    
    Name = C_NAME
    
End Property

'''
''' Returns the file path of the current log file.
'''
Public Property Get FilePath() As String
    
    FilePath = m_FilePath
    
End Property

'''
''' Returns the text description of the application error number.
'''
Private Function GetAppErrDescription(errNumber As Long) As String
    
    Select Case errNumber
        Case C_ERR_NO_ERROR:                GetAppErrDescription = vbNullString
        Case C_ERR_INVALID_FILE:            GetAppErrDescription = "Invalid file."
        Case C_ERR_INVALID_DIRECTORY:       GetAppErrDescription = "Invalid directory."
        Case C_ERR_LOG_FILE_DNE:            GetAppErrDescription = "Logfile DNE."
        Case C_ERR_INVALID_INPUT:           GetAppErrDescription = "Invalid input."
        Case C_ERR_REGISTRY_CLASS:          GetAppErrDescription = m_RegEdit.AppErr.Description
        Case C_ERR_TYPE_MISMATCH:           GetAppErrDescription = "Type mismatch."
        Case Else
            GetAppErrDescription = "Undefined error."
    End Select
    
End Function

'''
''' Creates a log file for output and stores it in the specified [storageDirectory].
''' If no [storageDirectory] is provided, then the [DirectoryPath] property is used.
'''
Public Function CreateLogFile(Optional storageDirectory As String = vbNullString, Optional ByRef LogFileName As String) As Boolean

    Dim sfx         As String
    Dim i           As Integer

    '//========================================================================================================================
    '// Initialize
    '//========================================================================================================================

    m_LogFileExists = False
    m_AppErr.clear
    
    If ((storageDirectory = vbNullString) And (m_DirectoryPath <> vbNullString)) Then        ' use existing directory definition.
        storageDirectory = m_DirectoryPath        ' e.g. class initializes to registry pointer.
    End If
    
    If ((storageDirectory <> vbNullString) And FileFolderExists(storageDirectory)) Then        ' valid input definition.
        m_DirectoryPath = storageDirectory
        If (LogFileName <> "") Then
            m_FileName = LogFileName
        Else
            LogFileName = C_DEFAULT_LOG_FILE_NAME
            m_FileName = LogFileName
        End If
        m_FilePath = m_DirectoryPath & m_FileName & m_FileExt
    Else        ' display application error
        With m_AppErr
            .Number = C_ERR_INVALID_DIRECTORY
            .Description = GetAppErrDescription(m_AppErr.Number)
            .source = "CreateLogFile(...)"
            .DisplayMessage
        End With
        Exit Function
    End If

    '==========================================================================================================================
    ' Define LogFileName
    '==========================================================================================================================

    '// Ensure unique name (use integer suffix until found)
    Do Until (FileFolderExists(m_FilePath) = False)
        i = i + 1
        sfx = " (" & i & ")"
        m_FilePath = m_DirectoryPath & m_FileName & sfx & m_FileExt
    Loop
    m_FileName = m_FileName & sfx
    
    m_LogFileExists = True
        
    '//========================================================================================================================
    '// Print Logfile Header
    '//========================================================================================================================

    '// Function WriteToFile(ByVal strLogMessage As String, ByVal iTypeOutput As EOutputType) As Boolean
    Call WriteToFile("LogFile       :    " & m_FileName, LogAppend)
    Call WriteToFile("Created       :    " & VBA.Now, LogAppend)
    Call WriteToFile(GetBufferString("_", C_MAX_LEN), LogAppend)
    Call WriteToFile("", LogAppend)
    
    CreateLogFile = True
    
End Function

'''
''' Function returns TRUE if the specified file or folder exists, FALSE if not.
'''
Private Function FileFolderExists(fullPath As String) As Boolean
    
    On Error Resume Next
    
    If Not (Dir(fullPath, vbDirectory) = vbNullString) And (fullPath <> vbNullString) Then
        FileFolderExists = True
    End If
    
End Function

'''
''' Outputs a blank line to the log file.
'''
Public Sub LogBlankLine()
    
    Call WriteToFile("", LogAppend)
    
End Sub

'''
''' Outputs a line to the Log file: solid (default) or dashed.
'''
Public Sub LogDividingLine(Optional includeBlankLineAfter As Boolean = True, Optional useDashLine As Boolean = False)

    If includeBlankLineAfter Then
        If Not useDashLine Then
            Call WriteToFile(GetBufferString("_", C_MAX_LEN) & VBA.vbCrLf, LogAppend)
        Else
            Call WriteToFile(GetBufferString("-", C_MAX_LEN) & VBA.vbCrLf, LogAppend)
        End If
    ElseIf Not useDashLine Then
        Call WriteToFile(GetBufferString("_", C_MAX_LEN), LogAppend)
    Else
        Call WriteToFile(GetBufferString("-", C_MAX_LEN), LogAppend)
    End If

End Sub

'''
''' Opens the file/folder by the specified <path>.
'''
Private Sub OpenFileFolder(fullPath As String)
    
    m_AppErr.clear
    
    On Error Resume Next
    Excel.ActiveWorkbook.FollowHyperlink Address:=fullPath, NewWindow:=True
    Select Case err.Number
        Case 0, -2147467260        '(-2147467260) results when someone hits cancel on Excel prompt.
            Exit Sub
        Case Else
            On Error Resume Next
            With m_AppErr
                If (VBA.InStr(VBA.Mid(fullPath, VBA.Len(fullPath) - VBA.Len(m_FileExt) - 1, VBA.Len(m_FileExt)), ".") <> 0) Then
                    .Number = C_ERR_INVALID_FILE
                Else
                    .Number = C_ERR_INVALID_DIRECTORY
                End If
                .source = "OpenFileFolder(...)"
                .Description = GetAppErrDescription(.Number)
            End With
    End Select
   
End Sub

'''
''' Opens the directory location of the current Log File.
'''
Public Sub OpenDirectory()

    OpenFileFolder (DirectoryPath)
    
End Sub

'''
''' Opens the current log file (if it exists).
'''
Public Sub OpenLogFile()

    OpenFileFolder (m_FilePath)
    
End Sub

Private Sub Class_Initialize()
    '//// Class constructor.
    '--------------------------------------------------------------------------------------------------------------------------
    Debug.Print "|> Initializing:= " & C_NAME
    
    m_AppErr.Initialize C_NAME
    
    ' Create Registry key if it DNE, or if it does not point to an existing folder.
    On Error Resume Next
    m_DirectoryPath = Me.RegDirectoryScratch
    On Error GoTo 0
    If Not FileFolderExists(m_DirectoryPath) Then        'key DNE, or invalid path.
        If Not FileFolderExists(ThisWorkbook.Path & "\scr\") Then
            CreateFolder ThisWorkbook.Path & "\scr\"
        End If
        m_DirectoryPath = ThisWorkbook.Path & "\scr\"
        Me.RegDirectoryScratch = m_DirectoryPath
    End If
    
    m_FileName = vbNullString
    m_FilePath = vbNullString
    m_FileExt = ".txt"

End Sub

'''
''' Returns the default directory save location (scratch folder).
''' Returns NULL if an error occured.
'''
Property Get RegDirectoryScratch() As Variant

    Dim var           As Variant

    m_AppErr.clear
    
    '// Retrieve and check value.
    var = m_RegEdit.RegistryGetValue(C_BASE_KEY, C_KEY_NAME, C_REG_SCRATCH)
    If Not VBA.IsNull(var) Then
        RegDirectoryScratch = VBA.CStr(var)
    Else
        RegDirectoryScratch = Null
        With m_AppErr
            .source = "'Get' RegDirecotryScratch"
            .Number = C_ERR_REGISTRY_CLASS
            .Description = m_RegEdit.AppErr.Description
        End With
    End If
End Property

'''
''' Sets the directory path for the default save location (scratch folder).
'''
Public Property Let RegDirectoryScratch(strDirectoryPath As Variant)

    m_AppErr.clear
    
    '// Force trailing slash
    If (VBA.Right(VBA.Trim(strDirectoryPath), 1) <> "\") Then
        strDirectoryPath = VBA.Trim(strDirectoryPath) & "\"
    End If
    
    '// Check and set value.
    If (strDirectoryPath = vbNullString) Then
        GoTo ErrHandler
    ElseIf FileFolderExists(VBA.CStr(strDirectoryPath)) Then
        If m_RegEdit.RegistryUpdateValue(C_BASE_KEY, C_KEY_NAME, C_REG_SCRATCH, VBA.CStr(strDirectoryPath), createKeyIfNotExist:=True) Then
            Exit Property
        Else
            m_AppErr.Number = C_ERR_REGISTRY_CLASS
        End If
    Else
        m_AppErr.Number = C_ERR_INVALID_DIRECTORY
    End If
    
ErrHandler:
    With m_AppErr
        If (.Number = 0) Then .Number = C_ERR_TYPE_MISMATCH
        .source = "'Let' RegDirectoryScratch"
        .Description = GetAppErrDescription(.Number)
    End With
End Property

'''
''' Returns the file name of the current log file.
'''
Public Property Get fileName() As String
    
    fileName = m_FileName
    
End Property

'''
''' Returns the directory location for the current log file.
'''
Public Property Get DirectoryPath() As String
    
    DirectoryPath = m_DirectoryPath
    
End Property

'''
''' Sets the directory location in which the log file is saved.
'''
Private Property Let DirectoryPath(Path As String)
    
    m_AppErr.clear
    
    If (VBA.Right(VBA.Trim(Path), 1) <> "\") Then
        Path = VBA.Trim(Path) & "\"
    End If
        
    '// Check existence
    If (VBA.Dir(Path, vbDirectory) = ".") Then
        m_DirectoryPath = Path
    Else        ' display application error
        With m_AppErr
            .Number = C_ERR_INVALID_DIRECTORY
            .Description = GetAppErrDescription(.Number)
            .source = "'Let' DirectoryPath"
            .DisplayMessage
        End With
    End If
       
End Property

'''
''' For testing purposes.
''' The LogFile class will automatically create a default registry path if none is detected i.e. workbook.path/scr/
''' This method alows me to remove the defined registry path, to verify that it is correctly created by the class.
'''
Public Sub RemoveRegistrySetting()
  
    m_AppErr.clear
    
    If Not m_RegEdit.RegistryDeleteValue(C_BASE_KEY, C_KEY_NAME, C_REG_SCRATCH) Then        ' display error message
        With m_AppErr
            .Number = C_ERR_REGISTRY_CLASS
            .source = "RemoveRegistrySetting"
            .Description = GetAppErrDescription(.Number)
            .DisplayMessage
        End With
    End If
    
End Sub

'''
''' Logs the stringToLog to the defined log file.
''' Formats the output according to LogFormatType.
'''
Public Sub Log(ByVal stringToLog As String, Optional formatType As LogFormatType = LogFormatType.LogDefault, Optional blankLineBeforeHeader As Boolean = True)

    Dim strg                As String
    Dim pads(2)             As String
    Dim nlen(2)             As Integer
    Dim ilen                As Long
    
    '//========================================================================================================================
    '// Optional Message Formatting
    '//========================================================================================================================

    m_AppErr.clear
    
    Select Case formatType
    
            '//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            '////               ///////////////////////////////////////////////////////////////////////////////////////////////
            '////   LOG TITLE   ///////////////////////////////////////////////////////////////////////////////////////////////
            '////               ///////////////////////////////////////////////////////////////////////////////////////////////
            '//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Case LogFormatType.LogTitle
        
            '// Preformatting
            '   [1] Padding for "stringToLog line.
            '   [2] Padding for spacer line.
            nlen(1) = C_MAX_LEN - (VBA.Len(stringToLog) + 12)
            For ilen = 1 To nlen(1)
                pads(1) = pads(1) & "/"
            Next ilen
            pads(1) = "    " & pads(1)
            
            nlen(2) = VBA.Len(stringToLog)
            For ilen = 1 To nlen(2)
                pads(2) = pads(2) & " "
            Next ilen
            
            '// Title definition.
            If blankLineBeforeHeader Then
                strg = VBA.vbCrLf & VBA.vbCrLf
            End If
            strg = strg & GetBufferString("/", C_MAX_LEN) & VBA.vbCrLf
            strg = strg & "////    " & pads(2) & pads(1) & VBA.vbCrLf
            strg = strg & "////    " & stringToLog & pads(1) & VBA.vbCrLf
            strg = strg & "////    " & pads(2) & pads(1) & VBA.vbCrLf
            strg = strg & GetBufferString("/", C_MAX_LEN) & VBA.vbCrLf
            stringToLog = strg
        
            '==================================================================================================================
            'LOG HEADER NO. 1
            '==================================================================================================================
        Case LogFormatType.LogHeader1
            
            '// Preformatting
            If blankLineBeforeHeader Then
                strg = VBA.vbCrLf
            End If
            '// Header definition
            strg = strg & GetBufferString("=", C_MAX_LEN) & VBA.vbCrLf
            strg = strg & stringToLog & VBA.vbCrLf
            strg = strg & GetBufferString("=", C_MAX_LEN) & VBA.vbCrLf
            stringToLog = strg
            
            '------------------------------------------------------------------------------------------------------------------
            'LOG HEADER NO. 2
            '------------------------------------------------------------------------------------------------------------------
        Case LogFormatType.LogHeader2
            
            '// Preformatting
            If blankLineBeforeHeader Then
                strg = VBA.vbCrLf
            End If
            '// Header definition
            strg = strg & GetBufferString("-", C_MAX_LEN) & VBA.vbCrLf
            strg = strg & stringToLog & VBA.vbCrLf
            strg = strg & GetBufferString("-", C_MAX_LEN) & VBA.vbCrLf
            stringToLog = strg
        
            '__________________________________________________________________________________________________________________
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        Case LogFormatType.LogDefault:          stringToLog = VBA.Now & ": " & stringToLog
        Case LogFormatType.LogBullet1:          stringToLog = VBA.Now & ": |> " & stringToLog
        Case LogFormatType.LogBullet2:          stringToLog = VBA.Now & ": |--> " & stringToLog
        Case LogFormatType.LogNoFormat
        
        Case LogFormatType.LogLineThru
            nlen(1) = C_MAX_LEN - VBA.Len(VBA.Now & ": ")
            If (VBA.Len(stringToLog) <= nlen(1)) Then
                strg = VBA.Replace(stringToLog, " ", "-")
                strg = "---" & strg
                nlen(2) = nlen(1) - VBA.Len(stringToLog) - 3
                For ilen = 1 To nlen(2)
                    strg = strg & "-"
                Next ilen
                stringToLog = VBA.Now & ": " & strg
            End If
            
        Case Else        ' display error message
            With m_AppErr
                .Number = C_ERR_INVALID_INPUT
                .source = "Log(...)"
                .Description = GetAppErrDescription(.Number)
                .DisplayMessage
            End With
            Exit Sub
    End Select
    
    '//========================================================================================================================
    '// Write Message to Logfile
    '//========================================================================================================================
    Call WriteToFile(stringToLog, LogAppend)

End Sub

'''
''' Writes "message" to the current log file.
'''
Private Sub WriteToFile(message As String, OutputType As LogOutputType)

    Dim lu          As Integer
    
    On Error Resume Next
    If m_LogFileExists Then
    
        lu = VBA.FreeFile
        
        Select Case OutputType
            Case LogAppend:         Open m_FilePath For Append As #lu
            Case LogOutput:         Open m_FilePath For Output As #lu
        End Select
        
        Print #lu, message
        Close #lu
        
    Else        ' display application error number
        With m_AppErr
            .Number = C_ERR_LOG_FILE_DNE
            .Description = GetAppErrDescription(.Number)
            .source = "WriteToFile(...)"
            .DisplayMessage
        End With
    End If

End Sub


'RegistryEditor	2

Option Explicit
Option Base 1
Option Compare Text
'
' Registry Class
' |* Brian J. Satola
' |* https://chejunkie.com
'
'==========================================================================================================================
' Based on the work of Chip Pearson, www.cpearson.com, chip@cpearson.com.
'==========================================================================================================================
' This class provides several methods related to working with keys and values in the system registry.
' These routines rely on each other, so you should import this entire class module into your project
'   rather than just copying and pasting individual procedures into other modules.
' In all functions with a BaseKey parameter, the value of BaseKey must be either HKEY_CURRENT_USER (or HKCU)
'   or HKEY_LOCAL_MACHINE (or HKML). Any other value is invalid.
'--------------------------------------------------------------------------------------------------------------------------
' The registry is a tree structure; as such, the following variables are used:
'   |* BaseKey       ::   tree trunk (or specific tree [or hive] of information in your registry).
'   |* KeyName       ::   a specific branch on the trunk.
'   |* SubKeys       ::   sub-branches of a key-branch on the trunk.
'   |* ValueName     ::   a specific leaf on the branch.
'   |* ValueValue    ::   the value that is actually written on the leaf.
'
'==========================================================================================================================
' Public Subs, Functions and Properties - oh my!
'==========================================================================================================================
'   |* Get | --- About                          :: String that describes the current class.
'   |* --------- CloseRegEdit                   ::
'   |* --------- GetBaseKeyName                 ::
'   |* --------- GetBaseKeyNameShort            ::
'   |* --------- GetDataTypeName                :: Returns REG_DATA_TYPE as a string e.g. needed for WShRegKeyWrite.
'   |* Get | --- Name                           :: Returns the name# of the class.
'   |* --------- IsRegEditOpen                  ::
'   |* --------- OpenRegEdit                    :: Opens the Registry Editor (C:\Windows\regedit.exe).
'   |* --------- OpenRegEditToKey               ::
'   |* --------- RegistryCreateKey              :: Creates registry key in specified basekey (registry hive).
'   |* --------- RegistryCreateValue            :: Creates registry value in specified key of the basekey.
'   |* --------- RegistryDeleteKey              :: Deletes the registry key in basekey, including all subkeys and values.
'   |* --------- RegistryDeleteValue            :: Deletes registry value in specified key of the basekey.
'   |* --------- RegistryGetValue               :: Returns the value of the specified name in the key of the basekey.
'   |* --------- RegistryGetValueType           :: Returns the data type of the value name in the key of the basekey.
'   |* --------- RegistryKeyExists              :: Returns TRUE or FALSE indicating whether the key exists in the basekey.
'   |* --------- RegistryNumberOfSubKeys        :: Returns the number of sub-keys under the specified key in basekey.
'   |* --------- RegistryNumberOfValues         :: Returns the number of values under the specified key in basekey.
'   |* --------- RegistrySubKeyNamesToArray     :: Returns an array of names of all sub-keys under a key in basekey.
'   |* --------- RegistryUpdateValue            :: Updates the value of the specified name in the key of basekey.
'   |* --------- RegistryValueExists            :: Returns TRUE or FALSE indicating whether the value name exists.
'   |* --------- RegistryValueNamesToArray      :: Returns an array of names of all values under the key in basekey.
'   |* Get | --- Version                        :: Returns version string for the class [e.g. #.# (year)].
'
'==========================================================================================================================
' References
'==========================================================================================================================
Private m_AppErr As ApplicationError
'--Private m_SysErr As New SystemError
'
' Library API errors
'--------------------------------------------------------------------------------------------------------------------------
'   |* Get | --- SysErrNumber       ::      Returns the system error number, usually the value of Err.LastDllError
'   |* Get | --- SysErrDescription  ::      Returns the text description associated with m_RegSysErrNum,
'                                           the text returned from GetSystemErrorMessageText
'
'==========================================================================================================================
' Application constants
'==========================================================================================================================
Private Const C_NAME As String = "RegistryEditor.cls"

Private Type RegValue
    valueName   As String
    valueValue  As Variant
End Type

'==========================================================================================================================
' Private variables
'==========================================================================================================================
'--Private m_RegSysErrNum           As Long
'--Private m_RegSysErrText          As String

'==========================================================================================================================
' Error constants
'==========================================================================================================================
Const C_ERR_OFFSET = 0
Private Const C_ERR_NO_ERROR                    As Long = 0
Private Const C_ERR_INVALID_BASE_KEY            As Long = C_ERR_OFFSET + vbObjectError + 1
Private Const C_ERR_INVALID_DATA_TYPE           As Long = C_ERR_OFFSET + vbObjectError + 2
Private Const C_ERR_KEY_NOT_FOUND               As Long = C_ERR_OFFSET + vbObjectError + 3
Private Const C_ERR_VALUE_NOT_FOUND             As Long = C_ERR_OFFSET + vbObjectError + 4
Private Const C_ERR_DATA_TYPE_MISMATCH          As Long = C_ERR_OFFSET + vbObjectError + 5
Private Const C_ERR_ENTRY_LOCKED                As Long = C_ERR_OFFSET + vbObjectError + 6
Private Const C_ERR_INVALID_KEYNAME             As Long = vbObjectError + C_ERR_OFFSET + 7
Private Const C_ERR_UNABLE_TO_OPEN_KEY          As Long = vbObjectError + C_ERR_OFFSET + 8
Private Const C_ERR_UNABLE_TO_READ_KEY          As Long = vbObjectError + C_ERR_OFFSET + 9
Private Const C_ERR_UNABLE_TO_CREATE_KEY        As Long = vbObjectError + C_ERR_OFFSET + 10
Private Const C_ERR_UNABLE_TO_READ_VALUE        As Long = vbObjectError + C_ERR_OFFSET + 11
Private Const C_ERR_UNABLE_TO_UPDATE_VALUE      As Long = vbObjectError + C_ERR_OFFSET + 12
Private Const C_ERR_UNABLE_TO_CREATE_VALUE      As Long = vbObjectError + C_ERR_OFFSET + 13
Private Const C_ERR_UNABLE_TO_DELETE_KEY        As Long = vbObjectError + C_ERR_OFFSET + 14
Private Const C_ERR_UNABLE_TO_DELETE_VALUE      As Long = vbObjectError + C_ERR_OFFSET + 15
Private Const C_ERR_INVALID_PATH                As Long = vbObjectError + C_ERR_OFFSET + 16

'==========================================================================================================================
' API Constants
'==========================================================================================================================
'--Private Const HKEY_CURRENT_USER_        As Long = &H80000001
'--Private Const HKEY_LOCAL_MACHINE_       As Long = &H80000002
'--Private Const HKEY_CLASSES_ROOT_        As Long = &H80000000
'--Private Const HKEY_CURRENT_CONFIG_      As Long = &H80000005
'--Private Const HKEY_DYN_DATA_            As Long = &H80000006
'--Private Const HKEY_PERFORMANCE_DATA_    As Long = &H80000004
'--Private Const HKEY_USERS_               As Long = &H80000003
'--Private Const HKCU                      As Long = HKEY_CURRENT_USER_
'--Private Const HKLM                      As Long = HKEY_LOCAL_MACHINE_
Public Enum HKEY
    HKEY_CURRENT_USER_HKCU = &H80000001
    HKEY_LOCAL_MACHINE_HKLM = &H80000002
    HKEY_CLASSES_ROOT_HKCR = &H80000000
    HKEY_CURRENT_CONFIG_HKCC = &H80000005
    HKEY_DYN_DATA_HKDD = &H80000006
    HKEY_PERFORMANCE_DATA_HKPD = &H80000004
    HKEY_USERS_HKU = &H80000003
End Enum

Private Const KEY_QUERY_VALUE           As Long = &H1
Private Const KEY_SET_VALUE             As Long = &H2
Private Const KEY_CREATE_SUB_KEY        As Long = &H4
Private Const KEY_ENUMERATE_SUB_KEYS    As Long = &H8
Private Const KEY_NOTIFY                As Long = &H10
Private Const KEY_CREATE_LINK           As Long = &H20
Private Const KEY_ALL_ACCESS            As Long = &H3F

Private Const REG_CREATED_NEW_KEY       As Long = &H1
Private Const REG_OPENED_EXISTING_KEY   As Long = &H2

Private Const STANDARD_RIGHTS_ALL       As Long = &H1F0000
Private Const SPECIFIC_RIGHTS_ALL       As Long = &HFFFF

Private Const REG_OPTION_NON_VOLATILE   As Long = 0&
Private Const REG_OPTION_VOLATILE       As Long = &H1

Private Const ERROR_SUCCESS             As Long = 0&
Private Const ERROR_ACCESS_DENIED       As Long = 5
Private Const ERROR_INVALID_DATA        As Long = 13&
Private Const ERROR_MORE_DATA           As Long = 234        ' dderror
Private Const ERROR_NO_MORE_ITEMS       As Long = 259

Private Const S_OK                      As Long = &H0
Private Const MAX_DATA_BUFFER_SIZE      As Long = 1024
Private Const REGSTR_MAX_VALUE_LENGTH   As Long = &H100

'==========================================================================================================================
' API Types
'==========================================================================================================================
Private Type SECURITY_ATTRIBUTES
    nLength                 As Long
    lpSecurityDescriptor    As Long
    bInheritHandle          As Boolean
End Type

Private Type FILETIME
    dwLowDateTime           As Long
    dwHighDateTime          As Long
End Type

Public Enum REG_DATA_TYPE
    REG_INVALID = -1        ' invalid
    REG_SZ = 1        ' string
    REG_EXPAND_SZ = 2        ' string
    REG_BINARY = 3        ' bianry
    REG_DWORD = 4        ' long
    REG_MULTI_SZ = 7        ' string
End Enum

Private Type ACL
    AclRevision             As Byte
    Sbz1                    As Byte
    AclSize                 As Integer
    AceCount                As Integer
    Sbz2                    As Integer
End Type

Private Type SECURITY_DESCRIPTOR
    Revision                As Byte
    Sbz1                    As Byte
    control                 As Long
    Owner                   As Long
    Group                   As Long
    Sacl                    As ACL
    Dacl                    As ACL
End Type

'==========================================================================================================================
' API Declarations
'==========================================================================================================================
Private Declare PtrSafe Function RegCloseKey Lib "advapi32.dll" _
(ByVal hiveKey As Long) As Long

Private Declare PtrSafe Function RegCreateKeyEx Lib "advapi32.dll" Alias "RegCreateKeyExA" ( _
ByVal hiveKey As Long, _
ByVal lpSubKey As String, _
ByVal Reserved As Long, _
ByVal lpClass As String, _
ByVal dwOptions As Long, _
ByVal samDesired As Long, _
lpSecurityAttributes As SECURITY_ATTRIBUTES, _
phkResult As Long, _
lpdwDisposition As Long) As Long

Private Declare PtrSafe Function RegDeleteKey Lib "advapi32.dll" Alias "RegDeleteKeyA" ( _
ByVal hiveKey As Long, _
ByVal lpSubKey As String) As Long

Private Declare PtrSafe Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" ( _
ByVal hiveKey As Long, _
ByVal lpSubKey As String, _
phkResult As Long) As Long

Private Declare PtrSafe Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" ( _
ByVal hiveKey As Long, _
ByVal lpValueName As String) As Long

Private Declare PtrSafe Function RegEnumKey Lib "advapi32.dll" Alias "RegEnumKeyA" ( _
ByVal hiveKey As Long, _
ByVal dwIndex As Long, _
ByVal lpName As String, _
ByVal cbName As Long) As Long

Private Declare PtrSafe Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" ( _
ByVal hiveKey As Long, _
ByVal dwIndex As Long, _
ByVal lpName As String, _
lpcbName As Long, _
ByVal lpReserved As Long, _
ByVal lpClass As String, _
lpcbClass As Long, _
lpftLastWriteTime As FILETIME) As Long

Private Declare PtrSafe Function RegEnumValue Lib "advapi32.dll" Alias "RegEnumValueA" ( _
ByVal hiveKey As Long, _
ByVal dwIndex As Long, _
ByVal lpValueName As String, _
lpcbValueName As Long, _
ByVal lpReserved As Long, _
lpType As Long, _
lpData As Byte, _
lpcbData As Long) As Long

Private Declare PtrSafe Function RegFlushKey Lib "advapi32.dll" ( _
ByVal hiveKey As Long) As Long

Private Declare PtrSafe Function RegGetKeySecurity Lib "advapi32.dll" ( _
ByVal hiveKey As Long, _
ByVal SecurityInformation As Long, _
pSecurityDescriptor As SECURITY_DESCRIPTOR, _
lpcbSecurityDescriptor As Long) As Long

Private Declare PtrSafe Function RegQueryInfoKey Lib "advapi32.dll" Alias "RegQueryInfoKeyA" ( _
ByVal hiveKey As Long, _
ByVal lpClass As String, _
lpcbClass As Long, _
ByVal lpReserved As Long, _
lpcSubKeys As Long, _
lpcbMaxSubKeyLen As Long, _
lpcbMaxClassLen As Long, _
lpcValues As Long, _
lpcbMaxValueNameLen As Long, _
lpcbMaxValueLen As Long, _
lpcbSecurityDescriptor As Long, _
lpftLastWriteTime As FILETIME) As Long

Private Declare PtrSafe Function RegQueryValue Lib "advapi32.dll" Alias "RegQueryValueA" ( _
ByVal hiveKey As Long, _
ByVal lpSubKey As String, _
ByVal lpValue As String, _
lpcbValue As Long) As Long

Private Declare PtrSafe Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" ( _
ByVal hiveKey As Long, _
ByVal lpValueName As String, _
ByVal lpReserved As Long, _
lpType As Long, _
lpData As Any, _
lpcbData As Long) As Long

Private Declare PtrSafe Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" ( _
ByVal hiveKey As Long, _
ByVal lpValueName As String, _
ByVal Reserved As Long, _
ByVal dwType As Long, _
lpData As Any, _
ByVal cbData As Long) As Long

Private Declare PtrSafe Function RegSetValueExStr Lib "advapi32" Alias "RegSetValueExA" ( _
ByVal hiveKey As Long, _
ByVal lpValueName As String, _
ByVal Reserved As Long, _
ByVal dwType As Long, _
ByVal szData As String, _
ByVal cbData As Long) As Long

Private Declare PtrSafe Function RegSetValueExLong Lib "advapi32" Alias "RegSetValueExA" ( _
ByVal hiveKey As Long, _
ByVal lpValueName As String, _
ByVal Reserved As Long, _
ByVal dwType As Long, _
szData As Long, _
ByVal cbData As Long) As Long

Private Declare PtrSafe Function RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" ( _
ByVal hiveKey As Long, _
ByVal lpSubKey As String, _
ByVal ulOptions As Long, _
ByVal samDesired As Long, _
phkResult As Long) As Long

Private Declare PtrSafe Function RegQueryValueExStr Lib "advapi32" Alias "RegQueryValueExA" ( _
ByVal hiveKey As Long, _
ByVal lpValueName As String, _
ByVal lpReserved As Long, _
ByRef lpType As Long, _
ByVal szData As String, _
ByRef lpcbData As Long) As Long

'''
''' Returns a string describing the class.
'''
Public Property Get About() As String

    About = "ChE Junkie VBA Registry class module, v" & Me.Version & "." & VBA.vbCrLf
    About = About & "An extension of original work done by Chip Pearson (www.cpearson.com)." & VBA.vbCrLf & VBA.vbCrLf
    About = About & "For additional details see:" & VBA.vbCrLf & "https://chejunkie.com/knowledge-base/registry-editor-class-vba/"
    
End Property

'''
''' Returns the application error object of the class.
'''
Public Property Get AppErr() As ApplicationError

    Set AppErr = m_AppErr
    
End Property

'''
''' Returns the *baseKey* name.
''' An empty string is returned if no match is found.
'''
Public Function GetBaseKeyName(baseKey As HKEY) As String

    Select Case baseKey
        Case HKEY.HKEY_CLASSES_ROOT_HKCR:       GetBaseKeyName = "HKEY_CLASSES_ROOT"
        Case HKEY.HKEY_CURRENT_USER_HKCU:       GetBaseKeyName = "HKEY_CURRENT_USER"
        Case HKEY.HKEY_LOCAL_MACHINE_HKLM:      GetBaseKeyName = "HKEY_LOCAL_MACHINE"
        Case HKEY.HKEY_USERS_HKU:               GetBaseKeyName = "HKEY_USERS"
        Case HKEY.HKEY_CURRENT_CONFIG_HKCC:     GetBaseKeyName = "HKEY_CURRENT_CONFIG"
        Case HKEY.HKEY_DYN_DATA_HKDD:           GetBaseKeyName = "HKEY_DYN_DATA"
        Case HKEY.HKEY_PERFORMANCE_DATA_HKPD:   GetBaseKeyName = "HKEY_PERFORMANCE_DATA"
    End Select

End Function

'''
''' Returns the abbreviated *baseKey* name, which is needed for working with WScript.Shell objects.
''' An empty string is returned if no match is found.
'''
Public Function GetBaseKeyNameShort(baseKey As HKEY) As String

    Select Case baseKey
        Case HKEY.HKEY_CLASSES_ROOT_HKCR:       GetBaseKeyNameShort = "HKCR"
        Case HKEY.HKEY_CURRENT_USER_HKCU:       GetBaseKeyNameShort = "HKCU"
        Case HKEY.HKEY_LOCAL_MACHINE_HKLM:      GetBaseKeyNameShort = "HKLM"
        Case HKEY.HKEY_USERS_HKU:               GetBaseKeyNameShort = "HKU"
        Case HKEY.HKEY_CURRENT_CONFIG_HKCC:     GetBaseKeyNameShort = "HKCC"
        Case HKEY.HKEY_DYN_DATA_HKDD:           GetBaseKeyNameShort = "HKDD"
        Case HKEY.HKEY_PERFORMANCE_DATA_HKPD:   GetBaseKeyNameShort = "HKPD"
    End Select

End Function

'''
''' Closes all instances of regedit.exe.
''' By defaulat, the user is prompted before closing open instances of the Registry Editor.
'''
Public Sub CloseRegEdit(Optional promptUserBeforeClosing As Boolean = True)

    Dim cReg                As Collection
    Dim proc                As Object
    Dim errReturnCode       As Long
    Dim response            As Integer

    If IsRegEditOpen(cReg) Then
        If promptUserBeforeClosing Then
            Select Case cReg.count
                Case Is = 1: response = VBA.MsgBox("Are you sure that you want to close the Regestry Editor (regedit.exe)?", vbYesNo)
                Case Is > 1: response = VBA.MsgBox("Are you sure that you want to close [" & cReg.count & "] instances of the Registry Editor (regedit.exe)?", vbYesNo)
            End Select
        End If
        If (response = vbYes) Or (promptUserBeforeClosing = False) Then
            For Each proc In cReg
                errReturnCode = proc.Terminate()
            Next proc
        End If
    End If

End Sub

'''
''' Tests whether or not the Registry Editor (regedit.exe) is open.
''' Option to pass all open instances back as a collection [cReg].
'''
Public Function IsRegEditOpen(Optional cReg As Collection) As Boolean

    Dim oServ       As Object
    Dim cProc       As Variant
    Dim oProc       As Object

    Set oServ = GetObject("winmgmts:")
    Set cProc = oServ.ExecQuery("Select * from Win32_Process")
    Set cReg = New Collection
    
    For Each oProc In cProc
        If (oProc.Name = "regedit.exe") Then
            cReg.Add oProc
        End If
    Next
    
    On Error GoTo ErrHandler
    If (cReg.count > 0) Then
        IsRegEditOpen = True
    End If
    
ErrHandler:
End Function

'''
''' Returns the name of the class.
'''
Public Property Get Name() As String

    Name = C_NAME
    
End Property

'''
''' Opens the Registry Editor (regedit.exe).
''' Opens to the previous key if [openToLastKey]:=True (which is the default behavior of RegEdit).
''' To kill existing regedit.exe processes before opening, set [closeBeforeOpening]:= TRUE.
'''
Public Sub OpenRegEdit(Optional openToLastKey As Boolean = True, Optional closeBeforeOpening = False)

    Dim wsh         As Object

    '// Set last position of reg.exe
    If Not openToLastKey Then
        RegistryUpdateValue HKEY.HKEY_CURRENT_USER_HKCU, "Software\Microsoft\Windows\CurrentVersion\Applets\Regedit", "LastKey", "Computer", createKeyIfNotExist:=False
    End If
    
    '// Option switch.
    If closeBeforeOpening Then
        CloseRegEdit promptUserBeforeClosing:=False
    End If
    
    '// Open instance of Registry Editor.
    On Error Resume Next
    Set wsh = VBA.CreateObject("WScript.Shell")
    wsh.Run "regedit.exe -m", 1, False
    Set wsh = Nothing
    On Error GoTo 0
    
End Sub

'''
''' Opens the Registry Editor (regedit.exe) to specified locaiton.
''' To kill existing regedit.exe processes before opening, set [closeInstancesBeforeOpening]:= TRUE.
'''
Public Sub OpenRegEditToKey(baseKey As HKEY, ByVal keyName As String, Optional closeBeforeOpening As Boolean = False)

    Dim wsh         As Object

    ResetErrorVariables
    
    '// Input checks.
    If IsValidBaseKey(baseKey:=baseKey) = False Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        GoTo ErrHandler
    End If
    If IsValidKeyName(keyName:=keyName) = False Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        GoTo ErrHandler
    End If
    If RegistryKeyExists(baseKey:=baseKey, keyName:=keyName) = False Then
        m_AppErr.Number = C_ERR_KEY_NOT_FOUND
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        GoTo ErrHandler
    End If
    
    '// Define open location.
    If Not RegistryUpdateValue(HKEY.HKEY_CURRENT_USER_HKCU, "Software\Microsoft\Windows\CurrentVersion\Applets\Regedit", _
                               "LastKey", "Computer\" & GetBaseKeyName(baseKey) & "\" & keyName, createKeyIfNotExist:=False) Then
        m_AppErr.Number = C_ERR_INVALID_PATH
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        GoTo ErrHandler
    End If
    
    '// Option switch.
    If closeBeforeOpening Then
        CloseRegEdit promptUserBeforeClosing:=False
    End If
    
    '// Open instance of Registry Editor.
    On Error Resume Next
    Set wsh = VBA.CreateObject("WScript.Shell")
    wsh.Run "regedit.exe -m", 1, False
    Set wsh = Nothing
    On Error GoTo 0
    Exit Sub

ErrHandler:
    m_AppErr.source = "OpenRegEditToKey(...)"
    OpenRegEdit openToLastKey:=False
    m_AppErr.DisplayMessage
    
End Sub

'''
''' Returns the value of the value named *valueName* in *keyName* in *baseKey*.
''' Returns NULL if an error occurred.
'''
Public Function RegistryGetValue(baseKey As HKEY, ByVal keyName As String, valueName As String) As Variant

    Dim hiveKey                 As Long
    Dim result                  As Long
    Dim regDataType             As REG_DATA_TYPE
    Dim lenData                 As Long
    Dim longData                As Long
    Dim stringData              As String
    Dim intArr(0 To 1024)       As Integer
    Dim lenStringData           As Long

    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValue(...) As Variant"
        RegistryGetValue = Null
        Exit Function
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValue(...) As Variant"
        RegistryGetValue = Null
        Exit Function
    End If
    
    If (RegistryKeyExists(baseKey:=baseKey, keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_KEY_NOT_FOUND
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValue(...) As Variant"
        RegistryGetValue = Null
        Exit Function
    End If
    
    regDataType = RegistryGetValueType(baseKey:=baseKey, keyName:=keyName, valueName:=valueName)
    hiveKey = OpenRegistryKey(baseKey:=baseKey, keyName:=keyName)
    If (hiveKey = 0) Then
        '--m_RegSysErrNumber = result
        '--m_RegSysErrText = GetSystemErrorMessageText(errNumber:=result)
        m_AppErr.NumberDLL = result
        m_AppErr.Number = C_ERR_UNABLE_TO_OPEN_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValue(...) As Variant"
        RegistryGetValue = Null
        Exit Function
    End If
    
    
    If (regDataType = REG_DWORD) Or (regDataType = REG_BINARY) Then
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' Data is Long data-type.
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        result = RegQueryValueEx(hiveKey:=hiveKey, lpValueName:=valueName, lpReserved:=0&, _
                                 lpType:=regDataType, lpData:=longData, lpcbData:=Len(longData))
        If (result = ERROR_SUCCESS) Then
            RegistryGetValue = longData
            Exit Function
        Else
            '--m_RegSysErrNumber = result
            '--m_RegSysErrText = GetSystemErrorMessageText(errNumber:=result)
            m_AppErr.NumberDLL = result
            m_AppErr.Number = C_ERR_UNABLE_TO_READ_VALUE
            m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
            m_AppErr.source = "RegistryGetValue(...) As Variant"
            RegCloseKey hiveKey
            RegistryGetValue = Null
            Exit Function
        End If
    ElseIf (regDataType = REG_SZ) Or (regDataType = REG_EXPAND_SZ) Or (regDataType = REG_MULTI_SZ) Then
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        ' Data is String data-type.
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        stringData = VBA.String$(MAX_DATA_BUFFER_SIZE, vbNullChar)
        lenStringData = VBA.Len(stringData)
        result = RegQueryValueExStr(hiveKey:=hiveKey, lpValueName:=valueName, lpReserved:=0&, _
                                    lpType:=regDataType, szData:=stringData, lpcbData:=lenStringData)
        If (result <> ERROR_SUCCESS) Then
            '--m_RegSysErrNumber = result
            '--m_RegSysErrText = GetSystemErrorMessageText(errNumber:=result)
            m_AppErr.NumberDLL = result
            m_AppErr.Number = C_ERR_UNABLE_TO_READ_VALUE
            m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
            m_AppErr.source = "RegistryGetValue(...) As Variant"
            RegCloseKey hiveKey
            RegistryGetValue = Null
            Exit Function
        End If
        stringData = TrimToNull(stringData)
        RegistryGetValue = stringData
    Else
        m_AppErr.Number = C_ERR_INVALID_DATA_TYPE
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValue(...) As Variant"
        RegistryGetValue = Null
    End If
    
End Function

'''
''' Indicates whether or not the *keyName* exists in *baseKey*.
''' Returns TRUE or FALSE.
'''
''' Returns FALSE if an error occurred. See the global error values for more information.
''' If [createKeyIfNotExist]:=TRUE and the key does not exist, it will be created.
'''
Public Function RegistryKeyExists(baseKey As HKEY, ByVal keyName As String, Optional createKeyIfNotExist As Boolean = False) As Boolean

    Dim hiveKey        As Long
    Dim result         As Long
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryKeyExists(...) As Boolean"
        RegistryKeyExists = False
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryKeyExists(...) As Boolean"
        RegistryKeyExists = False
    End If
    
    result = RegOpenKey(hiveKey:=baseKey, lpSubKey:=keyName, phkResult:=hiveKey)
    If (result = ERROR_SUCCESS) Then
        RegistryKeyExists = True
    Else
        RegistryKeyExists = False
        If (createKeyIfNotExist = True) Then
            result = RegistryCreateKey(baseKey:=baseKey, keyName:=keyName)
            RegistryKeyExists = CBool(result)
        End If
    End If
    
    RegCloseKey hiveKey:=hiveKey
    
End Function

'''
''' Returns the number of sub-keys under *keyName* in *baseKey*.
'''
''' Returns -1 if an error occurred or if *keyName* does not exist.
''' Includes an option to return a list of the subkeys as [listOfSubKeyNames].
'''
Public Function RegistryNumberOfSubKeys(baseKey As HKEY, ByVal keyName As String, Optional listOfSubKeyNames As Variant) As Long

    listOfSubKeyNames = RegistrySubKeyNamesToArray(baseKey, keyName)
    
    If VBA.IsNull(listOfSubKeyNames) Then
        RegistryNumberOfSubKeys = -1
    Else
        RegistryNumberOfSubKeys = UBound(listOfSubKeyNames)
        If LBound(listOfSubKeyNames) = 0 Then RegistryNumberOfSubKeys = RegistryNumberOfSubKeys + 1
    End If
    
End Function

'''
''' Returns the number of values under *keyName* in *baseKey*.
'''
''' Returns -1 if an error occurred or if *keyName* does not exist.
''' Inludes the option to return a list of values as [listOfValueNames].
'''
Public Function RegistryNumberOfValues(baseKey As HKEY, ByVal keyName As String, Optional listOfValueNames As Variant) As Long

    listOfValueNames = RegistryValueNamesToArray(baseKey, keyName)
    
    If VBA.IsNull(listOfValueNames) Then
        RegistryNumberOfValues = -1
    Else
        RegistryNumberOfValues = UBound(listOfValueNames)
        If LBound(listOfValueNames) = 0 Then RegistryNumberOfValues = RegistryNumberOfValues + 1
    End If
    
End Function

'''
''' Returns REG_DATA_TYPE as a string.
'''
''' Required for WShRegKeyWrite.
'''
Public Function GetDataTypeName(dataType As REG_DATA_TYPE) As String

    Select Case dataType
        Case REG_INVALID:       GetDataTypeName = "REG_INVALID"
        Case REG_SZ:            GetDataTypeName = "REG_SZ"
        Case REG_EXPAND_SZ:     GetDataTypeName = "REG_EXPAND_SZ"
        Case REG_BINARY:        GetDataTypeName = "REG_BINARY"
        Case REG_DWORD:         GetDataTypeName = "REG_DWORD"
        Case REG_MULTI_SZ:      GetDataTypeName = "REG_MULTI_SZ"
    End Select
    
End Function

'''
''' Indicates whether or not *valueName* exists under *keyName* in *baseKey* hive.
''' Returns TRUE or FALSE.
'''
Public Function RegistryValueExists(baseKey As HKEY, ByVal keyName As String, valueName As String, _
                                    Optional createKeyIfNotExist As Boolean = False, Optional CreateType As REG_DATA_TYPE = REG_DWORD) As Boolean

    Dim hiveKey        As Long
    Dim result         As Long
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryValueExists(...) As Boolean"
        RegistryValueExists = False
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryValueExists(...) As Boolean"
        RegistryValueExists = False
    End If
    
    hiveKey = OpenRegistryKey(baseKey:=baseKey, keyName:=keyName)
    If (hiveKey = 0) Then
        m_AppErr.Number = C_ERR_UNABLE_TO_OPEN_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryValueExists(...) As Boolean"
        RegistryValueExists = False
    End If
    
    result = RegQueryValueEx(hiveKey:=hiveKey, lpValueName:=valueName, lpReserved:=0&, lpType:=0&, lpData:=0&, lpcbData:=0&)
    If (result = ERROR_SUCCESS) Or (result = ERROR_MORE_DATA) Then
        RegistryValueExists = True
    Else
        If (createKeyIfNotExist = True) Then
            If (CreateType = REG_DWORD) Then
                result = RegistryCreateValue(baseKey:=baseKey, keyName:=keyName, valueName:=valueName, _
                                             valueValue:=0&, createKeyIfNotExist:=True)
            Else
                result = RegistryCreateValue(baseKey:=baseKey, keyName:=keyName, valueName:=valueName, _
                                             valueValue:=vbNullString, createKeyIfNotExist:=True)
            End If
            If (CBool(result) = True) Then
                RegistryValueExists = True
            Else
                RegistryValueExists = False
            End If
        End If
    End If
    
    RegCloseKey hiveKey
    
End Function

'''
''' Returns an array of the names of all the subkeys under *keyName* in *baseKey*.
'''
''' Returns NULL if an error occurred or if *keyName* does not exist.
''' Indexes to base [0], regardless of Option Base switch.
'''
Public Function RegistrySubKeyNamesToArray(baseKey As HKEY, ByVal keyName As String) As Variant

    Dim procHiveKeyRes            As Long
    Dim result             As Long
    Dim ooReg           As Object

    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistrySubKeyNames(...) As Variant"
        RegistrySubKeyNamesToArray = Null
        Exit Function
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistrySubKeyNames(...) As Variant"
        RegistrySubKeyNamesToArray = Null
        Exit Function
    End If
    
    procHiveKeyRes = OpenRegistryKey(baseKey:=baseKey, keyName:=keyName)
    If (procHiveKeyRes = 0) Then
        m_AppErr.Number = C_ERR_UNABLE_TO_OPEN_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistrySubKeyNames(...) As Variant"
        RegistrySubKeyNamesToArray = Null
        RegCloseKey procHiveKeyRes
        Exit Function
    Else: RegCloseKey procHiveKeyRes
    End If
     
    '// Ref: http://msdn.microsoft.com/en-us/library/aa392722(v=vs.85).aspx
    On Error Resume Next
    Set ooReg = VBA.GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
    ooReg.EnumKey baseKey, keyName, RegistrySubKeyNamesToArray
    If (err.Number <> 0) Then
        '--m_SysErr.Number = err.Number
        '--m_SysErr.Description = err.Description
        '--m_SysErr.Source = "RegistrySubKeyNames(...) As Variant"
        m_AppErr.NumberDLL = err.LastDllError
        m_AppErr.Number = err.Number
        m_AppErr.Description = err.Description
        m_AppErr.source = "RegistrySubKeyNames(...) As Variant"
    End If
    Set ooReg = Nothing
    On Error GoTo 0
    
End Function

'''
''' Returns an array of the names of all the values under *keyName*.
'''
''' Returns NULL if an error occurred or if the *keyName* does not exist.
''' Indexes to base [0], regardless of Option Base switch.
'''
Public Function RegistryValueNamesToArray(baseKey As HKEY, ByVal keyName As String) As Variant

    Dim procHiveKeyRes      As Long
    Dim result              As Long
    Dim ooReg               As Object
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryValueNamesToArray(...) As Variant"
        RegistryValueNamesToArray = Null
        Exit Function
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryValueNamesToArray(...) As Variant"
        RegistryValueNamesToArray = Null
        Exit Function
    End If
    
    procHiveKeyRes = OpenRegistryKey(baseKey:=baseKey, keyName:=keyName)
    If (procHiveKeyRes = 0) Then
        m_AppErr.Number = C_ERR_UNABLE_TO_OPEN_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryValueNamesToArray(...) As Variant"
        RegistryValueNamesToArray = Null
        RegCloseKey procHiveKeyRes
        Exit Function
    Else: RegCloseKey procHiveKeyRes
    End If
     
    '// Ref: http://msdn.microsoft.com/en-us/library/xka57xy4.aspx
    Set ooReg = VBA.GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
    On Error Resume Next
    ooReg.EnumValues baseKey, keyName, RegistryValueNamesToArray
    If (err.Number <> 0) Then
        '--m_RegSysErrNum = err.Number
        '--m_RegSysErrText = err.Description
        m_AppErr.NumberDLL = err.LastDllError
        m_AppErr.Number = err.Number
        m_AppErr.Description = err.Description
        m_AppErr.source = "RegistryValueNamesToArray(...) As Variant"
    End If
    Set ooReg = Nothing
    On Error GoTo 0
    
End Function

'''
''' This returns the data type of value named *valueName* in *keyName* in *baseKey*.
'''
''' The procedures in this module support only longs and strings, so the result will be REG_SZ
''' for a string, REG_DWORD for a long or REG_INVALID for any other data type.
'''
Public Function RegistryGetValueType(baseKey As HKEY, ByVal keyName As String, valueName As String) As REG_DATA_TYPE

    Dim result              As Long
    Dim procHiveKeyRes      As Long
    Dim dataType            As REG_DATA_TYPE
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValueType(...) As REG_DATA_TYPE"
        RegistryGetValueType = False
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValueType(...) As REG_DATA_TYPE"
        RegistryGetValueType = False
    End If
    
    result = RegOpenKey(hiveKey:=baseKey, lpSubKey:=keyName, phkResult:=procHiveKeyRes)
    If (result <> ERROR_SUCCESS) Then
        m_AppErr.Number = C_ERR_UNABLE_TO_OPEN_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValueType(...) As REG_DATA_TYPE"
        RegistryGetValueType = REG_INVALID
        Exit Function
    End If
        
    result = RegQueryValueEx(hiveKey:=procHiveKeyRes, lpValueName:=valueName, lpReserved:=0&, lpType:=dataType, lpData:=0&, lpcbData:=0&)
    If (result <> ERROR_SUCCESS) And (result <> ERROR_MORE_DATA) Then
        m_AppErr.Number = C_ERR_UNABLE_TO_READ_VALUE
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryGetValueType(...) As REG_DATA_TYPE"
        RegistryGetValueType = REG_INVALID
        RegCloseKey procHiveKeyRes
        Exit Function
    End If
        
    Select Case dataType
        Case REG_SZ
            RegistryGetValueType = REG_SZ
        Case REG_EXPAND_SZ
            RegistryGetValueType = REG_EXPAND_SZ
        Case REG_BINARY
            RegistryGetValueType = REG_BINARY
        Case REG_DWORD
            RegistryGetValueType = REG_DWORD
        Case REG_MULTI_SZ
            RegistryGetValueType = REG_MULTI_SZ
        Case Else
            RegistryGetValueType = REG_INVALID
    End Select
    
    RegCloseKey procHiveKeyRes
    
End Function

'''
''' This creates a value named *valueName* in *keyName* in *baseKey* with a value of *valueValue*.
''' If the key named by *keyName* does not exist, and [createKeyIfNotExist]:=TRUE, the key will
''' be created. If the value already exists, its value is set to th enew value if they are
''' compatible data types.
'''
Public Function RegistryCreateValue(baseKey As HKEY, ByVal keyName As String, valueName As String, valueValue As Variant, _
                                    Optional createKeyIfNotExist As Boolean = False) As Boolean

    Dim procHiveKeyRes      As Long
    Dim result              As Long
    Dim dataType            As REG_DATA_TYPE
    Dim StringValue         As String
    Dim LongValue           As Long
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryCreateValue = False
        Exit Function
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryCreateValue = False
        Exit Function
    End If
    
    '** Satola B 11-Nov. 2014
    If (RegistryKeyExists(baseKey:=baseKey, keyName:=keyName, _
                          createKeyIfNotExist:=createKeyIfNotExist) = False) Then
        m_AppErr.Number = C_ERR_KEY_NOT_FOUND
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryCreateValue = False
        Exit Function
    End If
         
    If (IsCompatibleValueValue(var:=valueValue) = False) Then
        m_AppErr.Number = C_ERR_INVALID_DATA_TYPE
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryCreateValue = False
        Exit Function
    End If
    
    If (RegistryKeyExists(baseKey:=baseKey, keyName:=keyName, createKeyIfNotExist:=False) = False) Then
        If (createKeyIfNotExist = True) Then
            If (RegistryKeyExists(baseKey:=baseKey, keyName:=keyName, createKeyIfNotExist:=True) = False) Then
                m_AppErr.Number = C_ERR_UNABLE_TO_CREATE_KEY
                m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
                RegistryCreateValue = False
                Exit Function
            End If
        Else
            m_AppErr.Number = C_ERR_KEY_NOT_FOUND
            m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
            RegistryCreateValue = False
            Exit Function
        End If
    End If
    
    If (RegistryValueExists(baseKey:=baseKey, keyName:=keyName, valueName:=valueName) = True) Then
        dataType = RegistryGetValueType(baseKey:=baseKey, keyName:=keyName, valueName:=valueName)
        If (dataType = REG_SZ) Then
            If (VarType(valueValue) <> vbString) Then
                m_AppErr.Number = C_ERR_DATA_TYPE_MISMATCH
                m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
                RegistryCreateValue = False
                Exit Function
            Else
                '''''''''''''''''''''''''''''
                ' ValueValue is a string. OK.
                '''''''''''''''''''''''''''''
            End If
        Else
            '''''''''''''''''''''''''
            ' ValueValue is numeric
            '''''''''''''''''''''''''
        End If
    Else
        '''''''''''''''''''''''
        ' Value does not exist.
        ' Set the DataType.
        '''''''''''''''''''''''
        If (VarType(valueValue) = vbString) Then
            dataType = REG_SZ
        Else
            dataType = REG_DWORD
        End If
    End If
    
    If (dataType = REG_DWORD) Then
        LongValue = VBA.CLng(valueValue)
        procHiveKeyRes = OpenRegistryKey(baseKey:=baseKey, keyName:=keyName)
        If (procHiveKeyRes = 0) Then
            '--m_RegSysErrNumber = err.LastDllError
            '--m_RegSysErrText = GetSystemErrorMessageText(errNumber:=m_RegSysErrNum)
            m_AppErr.NumberDLL = err.LastDllError
            m_AppErr.Number = C_ERR_UNABLE_TO_OPEN_KEY
            m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
            RegCloseKey procHiveKeyRes
            RegistryCreateValue = False
            Exit Function
        End If
            
        result = RegSetValueExLong(hiveKey:=procHiveKeyRes, lpValueName:=valueName, Reserved:=0&, _
                                   dwType:=REG_DWORD, szData:=LongValue, cbData:=Len(LongValue))
        If (result <> ERROR_SUCCESS) Then
            m_AppErr.Number = C_ERR_UNABLE_TO_UPDATE_VALUE
            m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
            RegCloseKey procHiveKeyRes
            RegistryCreateValue = False
            Exit Function
        End If
    Else
        StringValue = CStr(valueValue)
        procHiveKeyRes = OpenRegistryKey(baseKey:=baseKey, keyName:=keyName)
        If (procHiveKeyRes = 0) Then
            '--m_RegSysErrNumber = err.LastDllError
            '--m_RegSysErrText = GetSystemErrorMessageText(errNumber:=m_RegSysErrNum)
            m_AppErr.NumberDLL = err.LastDllError
            m_AppErr.Number = C_ERR_UNABLE_TO_OPEN_KEY
            m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
            RegCloseKey procHiveKeyRes
            RegistryCreateValue = False
            Exit Function
        End If
        result = RegSetValueExStr(hiveKey:=procHiveKeyRes, lpValueName:=valueName, Reserved:=0&, _
                                  dwType:=REG_SZ, szData:=StringValue, cbData:=Len(StringValue))
        If (result <> ERROR_SUCCESS) Then
            m_AppErr.Number = C_ERR_UNABLE_TO_UPDATE_VALUE
            m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
            RegistryCreateValue = False
            RegCloseKey procHiveKeyRes
            Exit Function
        End If
    End If
    
    RegCloseKey procHiveKeyRes
    RegistryCreateValue = True
    
End Function

'''
''' Creates a key named *keyName* in *baseKey*.
''' Returns True if successful or False if an error occurrs.
'''
Public Function RegistryCreateKey(baseKey As HKEY, ByVal keyName As String) As Boolean

    Dim result              As Long
    Dim procHiveKeyRes      As Long
    Dim dataType            As REG_DATA_TYPE
    Dim secAttrib           As SECURITY_ATTRIBUTES
    Dim disposition         As Long
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryCreateKey = False
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryCreateKey = False
    End If
    
    If (RegistryKeyExists(baseKey:=baseKey, keyName:=keyName) = True) Then
        '''''''''''''''''''''''''''
        ' Key already exist. Return
        ' True as if we created it.
        '''''''''''''''''''''''''''
        RegistryCreateKey = True
        Exit Function
    End If
    
    result = RegCreateKeyEx(hiveKey:=baseKey, lpSubKey:=keyName, Reserved:=0&, lpClass:=vbNullString, _
                            dwOptions:=REG_OPTION_NON_VOLATILE, samDesired:=KEY_ALL_ACCESS, _
                            lpSecurityAttributes:=secAttrib, phkResult:=procHiveKeyRes, lpdwDisposition:=disposition)
    If (result <> ERROR_SUCCESS) Then
        '--m_RegSysErrNumber = result
        '--m_RegSysErrText = GetSystemErrorMessageText(errNumber:=m_RegSysErrNum)
        m_AppErr.NumberDLL = result
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryCreateKey = False
        Exit Function
    End If
    
    RegistryCreateKey = True
    
End Function

'''
''' This deletes a value named *valueName* in *keyName* in *baseKey*.
''' Returns TRUE or FALSE indicating success (returns TRUE if the value does not exist).
'''
Public Function RegistryDeleteValue(baseKey As HKEY, ByVal keyName As String, valueName As String) As Boolean

    Dim result              As Long
    Dim procHiveKeyRes      As Long
    Dim dataType            As REG_DATA_TYPE
    Dim secAttrib           As SECURITY_ATTRIBUTES
    Dim disposition         As Long
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryDeleteValue = False
        Exit Function
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryDeleteValue = False
        Exit Function
    End If
    
    If (RegistryKeyExists(baseKey:=baseKey, keyName:=keyName, createKeyIfNotExist:=False) = False) Then
        m_AppErr.Number = C_ERR_KEY_NOT_FOUND
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryDeleteValue = False
        Exit Function
    End If
    
    procHiveKeyRes = OpenRegistryKey(baseKey:=baseKey, keyName:=keyName)
    If (procHiveKeyRes = 0) Then
        RegistryDeleteValue = False
        Exit Function
    End If
    If RegistryValueExists(baseKey:=baseKey, keyName:=keyName, valueName:=valueName) = False Then
        RegCloseKey procHiveKeyRes
        RegistryDeleteValue = True
        Exit Function
    End If
    
    result = RegDeleteValue(hiveKey:=procHiveKeyRes, lpValueName:=valueName)
    If (result <> ERROR_SUCCESS) Then
        '--m_RegSysErrNumber = result
        '--m_RegSysErrText = GetSystemErrorMessageText(errNumber:=result)
        m_AppErr.Number = C_ERR_UNABLE_TO_DELETE_VALUE
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegCloseKey procHiveKeyRes
        RegistryDeleteValue = False
        Exit Function
    End If
        
    RegCloseKey procHiveKeyRes
    RegistryDeleteValue = True
    
End Function

'''
''' This deletes the registry key named *keyName* in *baseKey*, including all subkeys and values.
''' Returns TRUE or FALSE indicating success (returns TRUE if the key does not exist).
'''
Public Function RegistryDeleteKey(baseKey As HKEY, ByVal keyName As String) As Boolean

    Dim result              As Long
    Dim procHiveKeyRes      As Long
    Dim dataType            As REG_DATA_TYPE
    Dim secAttrib           As SECURITY_ATTRIBUTES
    Dim disposition         As Long
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryDeleteKey = False
        Exit Function
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryDeleteKey = False
        Exit Function
    End If
    
    If (RegistryKeyExists(baseKey:=baseKey, keyName:=keyName, createKeyIfNotExist:=False) = False) Then
        RegistryDeleteKey = True
        Exit Function
    End If
    
    procHiveKeyRes = OpenRegistryKey(baseKey:=baseKey, keyName:=keyName)
    If (procHiveKeyRes = 0) Then
        RegistryDeleteKey = False
        Exit Function
    End If
    
    result = RegDeleteKey(hiveKey:=baseKey, lpSubKey:=keyName)
    RegCloseKey procHiveKeyRes
    If (result <> ERROR_SUCCESS) Then
        '--m_RegSysErrNumber = result
        '--m_RegSysErrText = GetSystemErrorMessageText(result)
        m_AppErr.NumberDLL = result
        m_AppErr.Number = C_ERR_UNABLE_TO_DELETE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        RegistryDeleteKey = False
        Exit Function
    End If
    
    RegistryDeleteKey = True
    
End Function

'''
''' Updates the value of the key, and returns TRUE or FALSE indicating success.
'''
Public Function RegistryUpdateValue(baseKey As HKEY, ByVal keyName As String, valueName As String, NewValue As Variant, _
                                    Optional createKeyIfNotExist As Boolean = True) As Boolean

    Dim result         As Boolean
    Dim hiveKey        As Long
    
    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey:=baseKey) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryUpdateValue(...) As Variant"
        RegistryUpdateValue = False
        Exit Function
    End If
    
    If (IsValidKeyName(keyName:=keyName) = False) Then
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryUpdateValue(...) As Variant"
        RegistryUpdateValue = False
        Exit Function
    End If
    
    If (IsCompatibleValueValue(var:=NewValue) = False) Then
        m_AppErr.Number = C_ERR_INVALID_DATA_TYPE
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryUpdateValue(...) As Variant"
        RegistryUpdateValue = False
        Exit Function
    End If
    
    
    result = RegistryKeyExists(baseKey:=baseKey, keyName:=keyName, createKeyIfNotExist:=True)
    If (result = False) Then
        m_AppErr.Number = C_ERR_KEY_NOT_FOUND
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryUpdateValue(...) As Variant"
        RegistryUpdateValue = False
        Exit Function
    End If
    
    If (VarType(NewValue) = vbString) Then
        result = RegistryValueExists(baseKey:=baseKey, keyName:=keyName, valueName:=valueName, _
                                     createKeyIfNotExist:=createKeyIfNotExist, CreateType:=REG_DWORD)
    Else
        result = RegistryValueExists(baseKey:=baseKey, keyName:=keyName, valueName:=valueName, _
                                     createKeyIfNotExist:=createKeyIfNotExist, CreateType:=REG_SZ)
    End If
    
    If (result = False) Then
        m_AppErr.Number = C_ERR_VALUE_NOT_FOUND
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        m_AppErr.source = "RegistryUpdateValue(...) As Variant"
        RegistryUpdateValue = False
        Exit Function
    End If
    
    
    result = RegistryDeleteValue(baseKey:=baseKey, keyName:=keyName, valueName:=valueName)
    result = RegistryCreateValue(baseKey:=baseKey, keyName:=keyName, valueName:=valueName, valueValue:=NewValue, createKeyIfNotExist:=True)
    
    RegistryUpdateValue = result
    
End Function

'''
''' Opens the *keyName* in *baseKey* and returns the key handle if successful or 0 if an error occurs.
'''
Private Function OpenRegistryKey(baseKey As HKEY, ByVal keyName As String) As Long

    Dim result              As Long
    Dim procHiveKeyRes      As Long

    ResetErrorVariables
    
    If (IsValidBaseKey(baseKey) = False) Then
        ''''''''''''''''''''''''''''''''''''''
        ' Invalid Base Key. Return 0 and
        ' get out.
        ''''''''''''''''''''''''''''''''''''''
        OpenRegistryKey = 0
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        Exit Function
    End If
    
    result = RegOpenKeyEx(hiveKey:=baseKey, lpSubKey:=keyName, ulOptions:=0&, samDesired:=KEY_ALL_ACCESS, phkResult:=procHiveKeyRes)
    If (result <> ERROR_SUCCESS) Then
        OpenRegistryKey = 0
        '--m_RegSysErrNumber = result
        '--m_RegSysErrText = GetSystemErrorMessageText(errNumber:=result)
        m_AppErr.NumberDLL = result
        m_AppErr.Number = C_ERR_INVALID_BASE_KEY
        m_AppErr.Description = GetAppErrDescription(m_AppErr.Number)
        Exit Function
    End If
    
    OpenRegistryKey = procHiveKeyRes
    
End Function

'''
''' If [reverse] is omitted or FALSE, the function returns the portion of *text* that is to the
''' left of the first vbNullChar character. The vbNullChar is not returned. If *reverse* is TRUE,
''' the function returns the portion to the left of the last vbNullChar. The vbNullChar is not
''' returned. In either case, if vbNullChar is not found, the entire string Text is returned.
'''
Private Function TrimToNull(TEXT As String, Optional reverse As Boolean = False) As String

    Dim pos         As Long

    If (reverse = False) Then
        pos = VBA.InStr(1, TEXT, vbNullChar, vbTextCompare)
    Else
        pos = VBA.InStrRev(TEXT, vbNullChar, -1, vbTextCompare)
    End If
    If pos Then
        TrimToNull = VBA.left(TEXT, pos - 1)
    Else
        TrimToNull = TEXT
    End If
    
End Function

'''
''' If *reverse* is FALSE, the function returns the portion of *text* that is to the left of the
''' first occurrence of *char*. If *reverse* is TRUE, the function returns the portion of *text*
''' that is to the left of the first occurrence of *char*. If *char* is not found, the entire
''' string *text* is returned.
'''
''' If [compareMode} is vbBinaryCompare, *text* is compared in a CASE-SENSITIVE manner ("A" <> "a").
''' If [compareMode] is any other value, text is compared in CASE-INSENSITVE mode ("A" = "a").
'''
Private Function TrimToChar(TEXT As String, char As String, Optional ByVal reverse As Boolean = False, _
                            Optional ByVal CompareMode As VbCompareMethod) As String
                    
    Dim pos         As Long
    
    If (CompareMode <> vbBinaryCompare) Then
        CompareMode = vbTextCompare
    End If
    
    If (reverse = False) Then
        pos = InStr(1, TEXT, char, CompareMode)
    Else
        pos = InStrRev(TEXT, char, -1, CompareMode)
    End If
    
    If pos Then
        TrimToChar = VBA.left(TEXT, pos - 1)
    Else
        TrimToChar = TEXT
    End If
    
End Function

'''
''' Indicates whether or not *baseKey* is a valid base key (e.g. HKEY_CURRENT_USER).
'''
Private Function IsValidBaseKey(baseKey As HKEY) As Boolean

    Select Case baseKey
        Case HKEY.HKEY_CURRENT_USER_HKCU, HKEY.HKEY_LOCAL_MACHINE_HKLM, _
             HKEY.HKEY_CLASSES_ROOT_HKCR, HKEY.HKEY_CURRENT_CONFIG_HKCC, HKEY.HKEY_DYN_DATA_HKDD, _
             HKEY.HKEY_PERFORMANCE_DATA_HKPD, HKEY.HKEY_USERS_HKU
            IsValidBaseKey = True
        Case Else
            IsValidBaseKey = False
    End Select
    
End Function

'''
''' Resets the class error property holders.
'''
Private Sub ResetErrorVariables()

    m_AppErr.clear
    
End Sub

'''
''' Returns the text description of the application *errNumber*.
'''
Private Function GetAppErrDescription(errNumber As Long) As String

    Select Case errNumber
        Case C_ERR_NO_ERROR:                    GetAppErrDescription = vbNullString
        Case C_ERR_INVALID_BASE_KEY:            GetAppErrDescription = "Invalid Base Key Value."
        Case C_ERR_INVALID_DATA_TYPE:           GetAppErrDescription = "Invalid Data Type."
        Case C_ERR_KEY_NOT_FOUND:               GetAppErrDescription = "Key Not Found."
        Case C_ERR_VALUE_NOT_FOUND:             GetAppErrDescription = "Value Not Found."
        Case C_ERR_DATA_TYPE_MISMATCH:          GetAppErrDescription = "Value Data Type Mismatch."
        Case C_ERR_ENTRY_LOCKED:                GetAppErrDescription = "Registry Entry Locked."
        Case C_ERR_INVALID_KEYNAME:             GetAppErrDescription = "The Specified Key Is Invalid."
        Case C_ERR_UNABLE_TO_OPEN_KEY:          GetAppErrDescription = "Unable To Open Key."
        Case C_ERR_UNABLE_TO_READ_KEY:          GetAppErrDescription = "Unable To Read Key."
        Case C_ERR_UNABLE_TO_CREATE_KEY:        GetAppErrDescription = "Unable To Create Key."
        Case C_ERR_UNABLE_TO_READ_VALUE:        GetAppErrDescription = "Unable To Read Value."
        Case C_ERR_UNABLE_TO_UPDATE_VALUE:      GetAppErrDescription = "Unable To Update Value."
        Case C_ERR_UNABLE_TO_CREATE_VALUE:      GetAppErrDescription = "Unable To Create Value."
        Case C_ERR_UNABLE_TO_DELETE_KEY:        GetAppErrDescription = "Unable To Delete Key."
        Case C_ERR_UNABLE_TO_DELETE_VALUE:      GetAppErrDescription = "Unable To Delete Value."
        Case C_ERR_INVALID_PATH:                GetAppErrDescription = "Invalid registry path."
        Case Else
            GetAppErrDescription = "Undefined Error."
    End Select
    
End Function

'''
''' Indicates whether the length of *txt* is less than REGSTR_MAX_VALUE_LENGTH.
'''
Private Function IsStringValidLength(txt As String) As Boolean

    IsStringValidLength = (Len(txt) <= REGSTR_MAX_VALUE_LENGTH)
    
End Function

'''
''' Indicates whether or not *keyName* is valid.
''' Returns TRUE or FALSE.
'''
''' An invalid key is one whose name length is greater than REGSTR_MAX_VALUE_LENGTH, is all
''' spaces or is an empty string i.e. MUST KEEP REFERENCE TO VARIABLE.
'''
Private Function IsValidKeyName(keyName As String) As Boolean

    IsValidKeyName = (VBA.Len(keyName) <= REGSTR_MAX_VALUE_LENGTH) And (Len(VBA.Trim(keyName)) > 0)

    '/* Satola B 11-Nov. 2014, checks for leading and ending slashes, and
    '   removes them from the 'keyName' defintion if found. This eliminates
    '   a typical formatting error when calling the API functions.
    If (VBA.Mid(keyName, 1, 1) = "\") Then
        Do While VBA.Mid(keyName, 1, 1) = "\"
            keyName = VBA.Mid(keyName, 2, VBA.Len(keyName) - 1)
        Loop
    End If
    If (VBA.Mid(keyName, VBA.Len(keyName), 1) = "\") Then
        Do While VBA.Mid(keyName, VBA.Len(keyName), 1) = "\"
            keyName = VBA.Mid(keyName, 1, VBA.Len(keyName) - 1)
        Loop
    End If
    
End Function

'''
''' Indicates whether or not *dataType* is avalid data type (e.g. REG_DWORD).
''' Returns TRUE or FALSE.
'''
Private Function IsValidDataType(dataType As REG_DATA_TYPE) As Boolean

    Select Case dataType
        Case REG_SZ, REG_DWORD
            IsValidDataType = True
        Case Else
            IsValidDataType = False
    End Select
    
End Function

'''
''' Indicates if *var* can be used as a registry key value.
''' Returns TRUE or FALSE.
'''
''' Note that all numeric data types (singles, doubles, etc.) are considered values, even
''' though their values will be changed when converted to longs.
'''
Private Function IsCompatibleValueValue(var As Variant) As Boolean

    If VarType(var) >= vbArray Then
        IsCompatibleValueValue = False
        Exit Function
    End If
    If IsArray(var) = True Then
        IsCompatibleValueValue = False
        Exit Function
    End If
    If IsObject(var) = True Then
        IsCompatibleValueValue = False
        Exit Function
    End If
    
    Select Case VarType(var)
        Case vbBoolean, vbByte, vbCurrency, vbDate, vbDouble, vbInteger, vbLong, vbSingle, vbString
            IsCompatibleValueValue = True
        Case Else
            IsCompatibleValueValue = False
    End Select
    
End Function

'''
''' Returns version information for the class.
'''
Public Property Get Version() As String

    '==========================================================================================================================
    ' Class changelog here.
    '==========================================================================================================================

    'Version = "Version 1.0 (2014)"  'Initial (official) release.
    'Version = "Version 1.1 (2014)"  'Satola B 10-Oct. 2014
    '   |* Minor corrections e.g. cleaned-up variable declarations and descriptions.
    '   |* The function 'GetDataTypeName' is also now accessible, so that it can be used with the
    '       Windows scripting shell functions (wsh). Using the standard API functions, however,
    '       are recommended. I only added the wsh functions because I was having trouble modifying
    '       a security key using the API functions, but the error was because I wrongly formatted the
    '       keyName string. I made the shell functions private, incase they are needed in the future.
    '   |* Because of [this] I modified the 'IsValidKeyName' function to automatically remove leading
    '       and trailing "\" characters from KeyName input parameters (i.e. to remove source of errors).
    'Version = "Version 2.0 (2015)"  'Satola B 08-Nov. 2015
    '   |* Additional updates to descriptions for consistency. I needed to change to a specific format
    '       so that I can programmatically export the class summary to worksheet i.e. easier maintenance.
    '   |* Changed application error variables and reformatted "GetAppErrDescription" for consistency
    '       with other classes. This includes adding "AppErrSource" property and "AppErrDisplayMessage"
    '       method, and changing the name of "GetAppErrText" to "GetAppErrDescription". [m_appErrSource]
    '       definitions were added to methods as necessary.
    '   |* Changed "GetDataTypeName" to use REG_DATA_TYPE enumerations instead of literals.
    Version = "3.0 (2017)"
    '   |* Improved documentation and readability.
    '   |* Constructor statement now uses *Name* property to print to immediate.
    '   |* Completely removed shell functions; duplicate functionality that causes confusion.
    '   |* Added *OpenRegEditToKey* so that regedit.exe can be opened to a specific location.
    '   |* Added the function *BaseKeyName* in support of method *OpenRegEditToKey*.
    '   |* Added the function *BaseKeyNameShort* for WScript.Shell, needed for DemoRegistryEditor module.
    '   |* Reformated comments to new convention (for later automation).
    '   |* Replaced application error properties and methods with a new error object/holder.
    '   |* Added opption to return the class name without extension (.cls).
    '   |* Removed the *Version* string from the get version property (more intuitive this way).
    '   |* Removed *HKEY_* properties in favour of a public enumeration: ~HKEY~.
                                    
End Property

'''
''' Class constructor.
'''
Private Sub Class_Initialize()

    Debug.Print "|* Initializing Class:= " & C_NAME
    
    Set m_AppErr = New ApplicationError
    m_AppErr.Initialize C_NAME
    
End Sub



'SECollect	2

Option Explicit

Private LBCol As Collection
Private SuperExtendLB As SExtendLB

Private Sub Class_Initialize()
    Set LBCol = New Collection
End Sub

Public Sub Add(ByVal NewLB As MSForms.ListBox)
    Set SuperExtendLB = New SExtendLB
    SuperExtendLB.Add NewLB
    LBCol.Add SuperExtendLB
End Sub


'SExtendLB	2

Rem in userform
Rem'''''''''''''''''''''''''''''''
Rem Dim LBCollection As SECollect
Rem
Rem Private Sub UserForm_Initialize()
Rem Set LBCollection = New SECollect
Rem LBCollection.Add ListBox1
Rem LBCollection.Add ListBox2
Rem End Sub

Option Explicit
Private Declare PtrSafe Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
Public WithEvents LB As MSForms.ListBox

Private ItemsSelected As Variant

Private Sub LB_Change()
    Dim i As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With LB
            For i = 0 To .ListCount - 1
                If ItemsSelected(i) = False And .SELECTED(i) = True Then
                    ItemsSelected(i) = True
                End If
            Next i
        End With
    End If
End Sub

Private Sub LB_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim i As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With LB
            ReDim ItemsSelected(0 To .ListCount - 1) As Boolean
            For i = 0 To .ListCount - 1
                ItemsSelected(i) = .SELECTED(i)
            Next i
        End With
    End If
End Sub

Private Sub LB_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim i As Long
    If CBool(GetKeyState(&HA0) And &HFF80) Then
        With LB
            For i = 0 To .ListCount - 1
                .SELECTED(i) = ItemsSelected(i)
            Next i
        End With
    End If
End Sub

Public Sub Add(ByVal NewLB As MSForms.ListBox)
    Set LB = NewLB
End Sub


'C_LogFile	1

Option Explicit
Option Base 1
Public Logger As LogFile

Private Sub QuickIllustration()
    Dim mLogger As New LogFile        ' instantiate the log class as an object
    '--logger.CreateLogFile logFileName:="QuickIllustration" '<-- using legacy method
    mLogger.CreateLogFileByName "QuickIllustration"        ' or new alternative.
    mLogger.Log "Some string you want to log."
    mLogger.OpenLogFile
End Sub

'''
''' Example method demonstrating the the Log File class.
'''
Private Sub Example_03_LogFile_Demonstration()
    '#INCLUDE StartLogger
    Dim dirPath     As String
    Dim fileName     As String
    Dim iter        As Integer
    '// Instantiate the LogFile class.
    StartLogger        ' <-- only creates a new log file if none exists.
    '// Printing to the logfile uses enumerators for the output-formatting i.e. it is relatively straightforward.
    With Logger
        ' For example, we can define a title.
        .Log "Demonstration: ExampleLogger", LogTitle        'I prefer this style (it is more clean).
        ' <h1> Then we can add different headers like e.g.
        Call .Log("Start Example", LogHeader1, blankLineBeforeHeader:=False)        'but this style is equally okay.
        .Log "We will first list information about the current log file, and then print in a loop as an example."
        ' <h2> Logfile information
        .Log "Current LogFile Information", LogHeader2
        .Log "FilePath:= " & .FilePath, LogBullet1
        .Log "FileName:= " & .fileName, LogBullet2
        .Log "DirPath:= " & .DirectoryPath, LogBullet2
        ' <h2> Iteration loop as example
        .Log "Iteration Loop as an Example", LogHeader2
        For iter = 1 To 100
            If (iter Mod 10 = 0) Then
                .Log "At iteration:= " & iter & " value = " & VBA.rnd() * 100
            End If
        Next iter
        ' Now, let's clean-up and see what we got!
        .LogBlankLine
        .LogDividingLine
        .Log "How's it look? Now you try...", LogNoFormat
        .OpenLogFile
    End With        'logger
End Sub

'''
''' Displays the about string of the LogFile class.
'''
Private Sub Example_01_About()
    '#INCLUDE StartLogger
    StartLogger
    MsgBox "EXAMPLE ROUTINES FOR:" & VBA.vbCrLf & VBA.vbCrLf & Logger.About, vbInformation, Logger.Name
End Sub

'''
''' Initiates class variables if they do not exist.
'''
Private Sub StartLogger(Optional LogFileName As String = "0.LOG")
    Dim dirPath     As String
    Dim fileName_   As String
    '/* (0.) Instantiate the LogFile class.
    '        This is generally considered good coding practice i.e. instead of 'Dim logger as New LogFile' for every
    '        module, class and/or routine (like for the RegistryTRUxl class declaration above, but it can be done ;).
    '        This is especially true if you desired to declare a 'GLOBAL' (or module-level) instance of the LogFile
    '        class so that the same logfile can be used by multiple methods and/or functions.
    If Logger Is Nothing Then        ' no existing log file => create
        Set Logger = New LogFile
        '/* (1.) Before printing to the logfile you must first create the logfile
        '        if it does not already exist (e.g. from a previous method that
        '        already initiated the class object). If you wanted to 'continue'
        '        using a logfile that has already been initiated then this next
        '        statement should within the if statement above, but since this
        '        is an example we will start from scratch here.
        dirPath = Logger.RegDirectoryScratch        '<-- The LogFile class initializes using the dirPath defined in registry.
        '    This, of course, can be overwritten by defining a different dir path.
        '    If no definition exists, the LogFile class creates a folder named "scr"
        '    in the directory of the Excel file and defines the registry as such.
        fileName_ = LogFileName        '<-- A prefix is automatically generated for the FileName of the LogFile class,
        '    i.e. if this is left blank then a generic FileName is used.
        If Not Logger.CreateLogFile(dirPath, fileName_) Then
            Logger.AppErr.DisplayMessage
        Else
            Debug.Print "Log file successfully created :)"
            Debug.Print "|> FileName:= " & Logger.fileName
            Debug.Print "|> DirPath:= " & Logger.DirectoryPath
            Debug.Print "|> FilePath:= " & Logger.FilePath
        End If
    End If
End Sub

'''
''' Example that displays the different formatting styles/options of the Log File class.
'''
Private Sub Example_02_LogFile_Formatting_Options()
    '#INCLUDE StartLogger
    Dim dirPath         As String
    Dim fileName        As String
    Dim iter            As Integer
    '==========================================================================================================================
    ' Print to log file and display different formatting results.
    '==========================================================================================================================
    StartLogger        ' <-- only creates a new log file if none exists.
    '// LogFile class uses enums to handle formatting.
    With Logger
        .Log "supercalifragilisticexpialidocious :p"
        .LogBlankLine
        ' For example, we can define a title.
        .Log "|> logFormatType.logTitle writes as:", LogNoFormat
        .Log "Section Title", LogTitle, blankLineBeforeHeader:=False
        ' Heading
        .Log "|> logFormatType.logHeader1 writes as:", LogNoFormat
        .Log "Heading 1", LogHeader1, blankLineBeforeHeader:=False
        ' Sub-heading
        .Log "|> logFormatType.logHeader2 writes as:", LogNoFormat
        .Log "Heading 1.2", LogHeader2, blankLineBeforeHeader:=False
        ' Default output style:
        .Log "|> logFormatType.logDefault writes as:", LogNoFormat
        .Log "This is what the default output looks like.", LogDefault
        ' Line through.
        .LogBlankLine
        .Log "|> logFormatType.logLineThru writes as:", LogNoFormat
        .Log "This puts a line through the text.", LogLineThru
        ' No format.
        .LogBlankLine
        .Log "|> logFormatType.LogNoFormat writes as:", LogNoFormat
        .Log "You can also choose to output with no formatting (and no time stamp).", LogNoFormat
        ' Bullet points
        .LogBlankLine
        .Log "|> There are also different types of bullets written as:", LogNoFormat
        For iter = 1 To 6
            .Log "Bullet 1." & iter, LogBullet1
            .Log "Bullet 2." & iter, LogBullet2
        Next iter
        .LogBlankLine
        .Log "|> You can also log a dividing line to e.g. further separate sections."
        .LogDividingLine
        .Log "The LogFile class can be easily modified."
        .Log "Now you try...", LogNoFormat
        .OpenLogFile
    End With        ' logger
End Sub

'''
''' Changes the registry setting used to define the output directory.
'''
Sub Example_04_LogFile_Set_Output_Directory()
    '#INCLUDE StartLogger
    StartLogger
    ' The LogFile class defines ThisWorkbook.path & "\scr\" as the default directory and saves the path in the registry.
    ' This is automatically defined when the LogFile class is used for the first time (see the constructor method).
    ' This setting can be overwritten using the RegDirectoryScratch method.
    ' ** NOTE: only valid (existing) directory paths can be defined.
    Logger.RegDirectoryScratch = ThisWorkbook.Path & "\scr\"        ' <--- this updates a registry entry.
    If (Logger.AppErr.Number <> 0) Then
        Logger.AppErr.DisplayMessage
    Else
        Logger.OpenDirectory
    End If
End Sub

'''
''' Removes the registry setting defining the storage directory for the log files (for testing purposes).
''' This will not break anything, because the class will automatically define a default directory if none exists.
''' Sometimes an error is generated, but I cannot isolate it when stepping through i.e. it is a VBA quirk.
'''
Private Sub RemoveRegistrySetting()
    StartLogger
    Logger.RemoveRegistrySetting
End Sub

'''
''' Runs all examples.
'''
Sub RunAllExamples()
    '#INCLUDE Example_03_LogFile_Demonstration
    '#INCLUDE Example_01_About
    '#INCLUDE Example_02_LogFile_Formatting_Options
    Example_01_About
    Example_02_LogFile_Formatting_Options
    Example_03_LogFile_Demonstration
End Sub


'M_Login	1

Option Explicit

Rem @Folder Login
Sub ListRightsSheets()
    Dim coll As New Collection
    Dim uLoginSettingsSheet As Worksheet
    Set uLoginSettingsSheet = ThisWorkbook.SHEETS("uLoginSettings")
    Dim rng As Range
    Dim ws As Worksheet
    Dim cell As Range
    Set cell = uLoginSettingsSheet.Range("H4")
    Set rng = Union(cell, cell.End(xlToRight))
    rng.ClearContents
    For Each ws In ThisWorkbook.Worksheets
        cell = ws.Name
        Set cell = cell.OFFSET(0, 1)
    Next
End Sub

Sub CheckUser()
    On Error Resume Next
    Dim UserRow, SheetCol As Long, SheetNm As String
    With ThisWorkbook.SHEETS("uLoginSettings")
        .Calculate
        If .Range("B8").Value = Empty Then
            MsgBox "Please enter a correct user name"
            Exit Sub
        End If
        If .Range("B7").Value <> True Then
            MsgBox "Pleae enter a correct password"
            Exit Sub
        End If
        uLogin.Hide
        UserRow = .Range("B8").Value
        For SheetCol = 8 To 13
            SheetNm = .Cells(4, SheetCol).Value
            If .Cells(UserRow, SheetCol).Value = .[B1] Then
                SHEETS(SheetNm).Unprotect "123"
                SHEETS(SheetNm).visible = xlSheetVisible
            End If
            If .Cells(UserRow, SheetCol).Value = .[b2] Then
                SHEETS(SheetNm).Protect "123"
                SHEETS(SheetNm).visible = xlSheetVisible
            End If
            If .Cells(UserRow, SheetCol).Value = .[b3] Then SHEETS(SheetNm).visible = xlVeryHidden
        Next SheetCol
    End With
End Sub

Sub UserLogOff()
    '#INCLUDE HideWorksheets
    Dim ans As Long
    ans = MsgBox("Log Off?", vbYesNo)
    If ans = vbYes Then
        SHEETS("uLoginSettings").Range("B5,B6").ClearContents
        HideWorksheets
    End If
End Sub

Sub UserLoginStart()
    uLogin.Show
End Sub

Sub HideWorksheets()
    Dim WkSht As Worksheet
    ThisWorkbook.SHEETS("uLogin").Activate
    For Each WkSht In ThisWorkbook.Worksheets
        If WkSht.Name <> "uLogin" Then WkSht.visible = xlSheetVeryHidden
    Next WkSht
End Sub


'uLogin	3


Option Explicit

Private Sub Label1_Click()
    Login
End Sub

Sub Login()
    '#INCLUDE CheckUser
    ThisWorkbook.SHEETS("uLoginSettings").Range("B6").Value = Me.Password.Value
    ThisWorkbook.SHEETS("uLoginSettings").Range("B5").Value = Me.UserNames.Value
    CheckUser
End Sub

Private Sub Label3_Click()
    Unload Me
End Sub

Private Sub UserForm_Initialize()
    MakeFormBorderless Me
    MakeFormTransparent Me, vbYellow
    ListUsernames
End Sub

Sub ListUsernames()
    UserNames.clear
    Dim rng As Range
    Set rng = ThisWorkbook.SHEETS("uLoginSettings").Range("E4").CurrentRegion.RESIZE(, 1)
    Set rng = rng.OFFSET(1).RESIZE(rng.rows.count - 1)
    Dim cell As Range
    For Each cell In rng
        UserNames.AddItem cell
    Next
    UserNames.ListIndex = 0
End Sub

Private Sub UserNames_DropButtonClick()
    UserNames.ForeColor = vbBlack
End Sub

Private Sub UserNames_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    UserNames.ForeColor = vbWhite
End Sub


'F_Modifier	1

Rem @Folder Modifier References

'Declared elsewhere
'Declare PtrSafe Function GetAsyncKeyState Lib "user32.dll" (ByVal vKey As Long) As Long

Public Enum VirtualKey
    VK_LBUTTON = &H1
    VK_SHIFT = &H10
    VK_CONTROL = &H11
    VK_MENU = &H12
    VK_PAUSE = &H13
    VK_CAPITAL = &H14
    VK_ESCAPE = &H1B
    VK_RBUTTON = &H2
    VK_SPACE = &H20
    VK_PRIOR = &H21
    VK_NEXT = &H22
    VK_END = &H23
    VK_HOME = &H24
    VK_LEFT = &H25
    VK_UP = &H26
    VK_RIGHT = &H27
    VK_DOWN = &H28
    VK_SELECT = &H29
    VK_PRINT = &H2A
    VK_EXECUTE = &H2B
    VK_SNAPSHOT = &H2C
    VK_INSERT = &H2D
    VK_DELETE = &H2E
    VK_HELP = &H2F
    VK_CANCEL = &H3
    VK_MBUTTON = &H4        ' NOT contiguous with L RBUTTON
    VK_NUMPAD0 = &H60
    VK_NUMPAD1 = &H61
    VK_NUMPAD2 = &H62
    VK_NUMPAD3 = &H63
    VK_NUMPAD4 = &H64
    VK_NUMPAD5 = &H65
    VK_NUMPAD6 = &H66
    VK_NUMPAD7 = &H67
    VK_NUMPAD8 = &H68
    VK_NUMPAD9 = &H69
    VK_MULTIPLY = &H6A
    VK_ADD = &H6B
    VK_SEPARATOR = &H6C
    VK_SUBTRACT = &H6D
    VK_DECIMAL = &H6E
    VK_DIVIDE = &H6F
    VK_F1 = &H70
    VK_F2 = &H71
    VK_F3 = &H72
    VK_F4 = &H73
    VK_F5 = &H74
    VK_F6 = &H75
    VK_F7 = &H76
    VK_F8 = &H77
    VK_F9 = &H78
    VK_F10 = &H79
    VK_F11 = &H7A
    VK_F12 = &H7B
    VK_F13 = &H7C
    VK_F14 = &H7D
    VK_F15 = &H7E
    VK_F16 = &H7F
    VK_BACK = &H8
    VK_F17 = &H80
    VK_F18 = &H81
    VK_F19 = &H82
    VK_F20 = &H83
    VK_F21 = &H84
    VK_F22 = &H85
    VK_F23 = &H86
    VK_F24 = &H87
    VK_TAB = &H9
    VK_NUMLOCK = &H90
    VK_SCROLL = &H91
    VK_LSHIFT = &HA0
    VK_RSHIFT = &HA1
    VK_LCONTROL = &HA2
    VK_RCONTROL = &HA3
    VK_LMENU = &HA4
    VK_RMENU = &HA5
    VK_CLEAR = &HC
    VK_RETURN = &HD
    VK_PROCESSKEY = &HE5
    VK_ATTN = &HF6
    VK_CRSEL = &HF7
    VK_EXSEL = &HF8
    VK_EREOF = &HF9
    VK_PLAY = &HFA
    VK_ZOOM = &HFB
    VK_NONAME = &HFC
    VK_PA1 = &HFD
    VK_OEM_CLEAR = &HFE
End Enum

Rem @Folder Modifier

Sub is_correct_key_pressed()
    If GetAsyncKeyState(VirtualKey.VK_SHIFT) <> 0 Then
        MsgBox "Shift was pressed"
    Else
        MsgBox "Shift was NOT pressed"
    End If
End Sub


'Sheet27	100

Option Explicit

Private Sub Worksheet_BeforeDoubleClick(ByVal Target As Range, Cancel As Boolean)
    If Not Intersect(Target, Range("H5:Z24")) Is Nothing Then
        If Target.Value = [B1] Then
            Target.Value = [b2]
            Cancel = True
            Exit Sub
        End If
        If Target.Value = [b3] Then Target.Value = [B1]
        If Target.Value = [b2] Then Target.Value = [b3]
        If Target.Value = Empty Then Target.Value = [B1]
    End If
    If Not Intersect(Target, Range("G5:G24")) Is Nothing Then
        If Target.Value = [B1] Then
            Range("G" & Target.row & ":M" & Target.row).Value = [b2]
            Cancel = True
            Exit Sub
        End If
        If Target.Value = [b3] Then Range("G" & Target.row & ":M" & Target.row).Value = [B1]
        If Target.Value = [b2] Then Range("G" & Target.row & ":M" & Target.row).Value = [b3]
        If Target.Value = Empty Then Range("G" & Target.row & ":M" & Target.row).Value = [B1]
    End If
    Cancel = True
End Sub


'Sheet28	100

Option Explicit

'Sheet26	100



'Sheet13	100



'Sheet14	100



'U_MouseRecorder	1


#If VBA7 And Win64 Then
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#Else
    public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
#End If
Public MouseFolder As String
Rem mouse
Public MouseArray() As Variant
Rem declaration for keys event reading
Public Declare PtrSafe Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer
Rem declaration for mouse events
Public Declare PtrSafe Sub mouse_event Lib "user32" (ByVal dwFlags As Long, ByVal dx As Long, ByVal dy As Long, ByVal cbuttons As Long, ByVal dwExtraInfo As Long)
Public Const MOUSEEVENTF_LEFTDOWN = &H2
Public Const MOUSEEVENTF_LEFTUP = &H4
Public Const MOUSEEVENTF_MIDDLEDOWN = &H20
Public Const MOUSEEVENTF_MIDDLEUP = &H40
Public Const MOUSEEVENTF_RIGHTDOWN As Long = &H8
Public Const MOUSEEVENTF_RIGHTUP As Long = &H10
Public Const MOUSEEVENTF_MOVE = &H1
Public Const MOUSEEVENTF_ABSOLUTE = &H8000
Rem declaration for setting mouse position
Public Declare PtrSafe Function SetCursorPos Lib "user32" (ByVal X As Long, ByVal Y As Long) As Long
Rem declaration for getting mouse position
Public Declare PtrSafe Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Public Type POINTAPI
    X As Long
    Y As Long
End Type


'uMouseRecorder	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uMouseRecorder
'* Created    : 06-10-2022 10:38
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Completed As Boolean

Private Sub UserForm_Initialize()
    Me.Height = 125
    Me.Width = 230
    LoadPosition Me
    UserformOnTop Me
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    MouseFolder = Environ("USERprofile") & "\Documents\vbArc\MouseMacro\"
    FoldersCreate MouseFolder
    checkFile
    ClicksOnly.Value = ws.Range("h2")
    LoadMRcaption
    LoadListbox

    CreateListboxHeader lBoxData, lBoxHeader, Array("X", "Y", "L", "R", "NOTE")
End Sub

Function CursorPosition() As Variant
    Dim lngCurPos As POINTAPI, activeX As Long, activeY As Long
    GetCursorPos lngCurPos
    activeX = lngCurPos.X
    activeY = lngCurPos.Y
    Dim out(1) As Variant
    out(0) = activeX
    out(1) = activeY
    CursorPosition = out
End Function

Sub ShowCoordinates(X As Long, Y As Long)
    uCoordinates.Load
    uCoordinates.left = X
    uCoordinates.top = Y
    uCoordinates.Show
End Sub

Private Sub iLogLink_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    LogLink
    LoadListbox
End Sub

Sub LogLink()
    '#INCLUDE InputboxString
    '#INCLUDE IsFileFolderURL
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim msg As String
    msg = InputboxString()
    If Len(msg) = 0 Then Exit Sub
    If msg = "False" Then Exit Sub
    If IsFileFolderURL(msg) = "I" Then Exit Sub
    Dim cell As Range
    Set cell = ws.Range("A" & rows.count).End(xlUp).OFFSET(1)
    cell = "go"
    cell.OFFSET(0, 1) = msg
End Sub

Private Sub iLogLink_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iLogLink.ControlTipText
End Sub

Private Sub iLogRight_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    LogClick "right"
    LoadListbox
End Sub

Private Sub iCoordinates_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    IndexMouseLocation
End Sub

Private Sub iCoordinates_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iCoordinates.ControlTipText
End Sub

Private Sub iSize_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Me.Height > 125 Then
        Me.Height = 125
        iSize.SpecialEffect = fmSpecialEffectRaised
    Else
        Me.Height = 275
        iSize.SpecialEffect = fmSpecialEffectSunken
        CreateListboxHeader lBoxData, lBoxHeader, Array("X", "Y", "L", "R", "NOTE")
    End If
End Sub

Private Sub iSize_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iSize.ControlTipText
End Sub

Private Sub lBoxData_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = lBoxData.ControlTipText
End Sub

Private Sub UserForm_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = "Hold ESC to STOP recording or playback"
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    SavePosition Me
End Sub

Private Sub ClicksOnly_Click()
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    ws.Range("H2") = ClicksOnly
End Sub

Sub DeleteRows()
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If ListboxSelectedCount(uMouseRecorder.lBoxData) = 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Range(ws.Cells(2 + r, 1), ws.Cells(2 + r, 5)).RESIZE(c)
    rng.Delete Shift:=xlUp
End Sub

Sub DoubleClick()
    'Double click as a quick series of two clicks
    mouse_event MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0
    mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, 0
    mouse_event MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0
    mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, 0
End Sub

Sub DuplicateRows()
    '#INCLUDE LoadListbox
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If ListboxSelectedCount(uMouseRecorder.lBoxData) = 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Range(ws.Cells(2 + r, 1), ws.Cells(2 + r, 5)).RESIZE(c)
    Dim var
    var = rng.Value
    rng.OFFSET(rng.rows.count).Insert
    rng.OFFSET(rng.rows.count).RESIZE(rng.rows.count) = var
    Application.CutCopyMode = False
    LoadListbox
End Sub

Sub EditMemo()
    '#INCLUDE LoadListbox
    '#INCLUDE InputboxString
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    Dim s As String
    If ListboxSelectedCount(uMouseRecorder.lBoxData) = 0 Then Exit Sub
    Dim ans As String
    ans = InputboxString
    If ans = "False" Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Cells(2 + r, 5).RESIZE(c)
    rng.Value = ans
    LoadListbox
End Sub

Sub EditRow()
    '#INCLUDE LoadListbox
    '#INCLUDE InputboxString
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    Dim s As String
    If ListboxSelectedCount(uMouseRecorder.lBoxData) = 0 Then Exit Sub
    s = lBoxData.list(lBoxData.ListIndex, 0)
    s = s & "|" & lBoxData.list(lBoxData.ListIndex, 1)
    s = s & "|" & lBoxData.list(lBoxData.ListIndex, 2)
    s = s & "|" & lBoxData.list(lBoxData.ListIndex, 3)
    s = s & "|" & lBoxData.list(lBoxData.ListIndex, 4)
    Dim ans As String
    ans = InputboxString(, , s)
    If ans = "False" Then Exit Sub
    If UBound(Split(s, "|")) <> 4 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Range(ws.Cells(2 + r, 1), ws.Cells(2 + r, 5)).RESIZE(c)
    rng.Value = (Split(ans, "|"))
    LoadListbox
End Sub

Private Sub info_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Sub LeftClick()
    mouse_event MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0
    mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, 0
End Sub

'Private Sub iMove_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
'If Button = 1 Then
'    m_sngDownX = X
'    m_sngDownY = Y
'End If
'End Sub
'Private Sub iMove_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
'If Button And 1 Then
'    Me.left = Me.left + (X - m_sngDownX)
'    Me.top = Me.top + (Y - m_sngDownY)
'End If
'End Sub
Sub LoadListbox()
    '#INCLUDE RecordRange
    Dim rng As Range
    Set rng = RecordRange
    lBoxData.clear
    If rng Is Nothing Then Exit Sub
    lBoxData.columnCount = rng.Columns.count
    lBoxData.list = rng.Value
End Sub

Sub LoadMRcaption()
    '#INCLUDE RecordFileFullName
    '#INCLUDE FileExists
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim FileFullPath As String
    FileFullPath = RecordFileFullName
    If ws.Range("H1") = "" Then
        If ws.Range("A2") = "" Then
            Me.Caption = "New Recording"
        ElseIf ws.Range("A2") <> "" Then
            Me.Caption = "Existing Recording - NOT SAVED"
        End If
    ElseIf ws.Range("H1") <> "" Then
        Me.Caption = IIf(FileExists(FileFullPath), "Loaded - " & ws.Range("H1"), "New Recording")
    End If
End Sub

Sub LoadRecord()
    '#INCLUDE TXTtoArray
    '#INCLUDE PickRecord
    '#INCLUDE RecordFileFullName
    '#INCLUDE newRecord
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim FName As String
    FName = PickRecord(MouseFolder)
    If FName = "" Or Right(FName, 7) <> "_mr.txt" Then
        infoLab.Caption = "No valid file selected"
        Exit Sub
    End If
    newRecord
    FName = Mid(FName, InStrRev(FName, "\") + 1)
    FName = left(FName, InStr(1, FName, "_") - 1)
    uMouseRecorder.LoadedRecording.Caption = FName
    ws.Range("H1") = FName
    Dim recFile As String
    recFile = RecordFileFullName
    Dim arr
    arr = TXTtoArray(recFile)
    If IsEmpty(arr) Then Exit Sub
    Dim rng As Range
    Set rng = ws.Range("A2").CurrentRegion.OFFSET(1)
    rng.ClearContents
    rng.RESIZE(UBound(arr, 1), 4) = arr
End Sub

'VBA function to open a CSV file in memory and parse it to a 2D
'array without ever touching a worksheet:

Function TXTtoArray(sFile$)
    '#INCLUDE OpenTextFile
    Dim c&, i&, j&, p&, d$, s$, rows&, cols&, a, r, v
    Const Q = """", QQ = Q & Q
    Const ENQ = ""        'Chr(5)
    Const ESC = ""        'Chr(27)
    Const COM = ","
    
    d = OpenTextFile$(sFile)
    If LenB(d) Then
        r = Split(Trim(d), vbCrLf)
        rows = UBound(r) + 1
        cols = UBound(Split(r(0), ",")) + 1
        ReDim v(1 To rows, 1 To cols)
        For i = 1 To rows
            s = r(i - 1)
            If LenB(s) Then
                If InStrB(s, QQ) Then s = Replace(s, QQ, ENQ)
                For p = 1 To Len(s)
                    Select Case Mid(s, p, 1)
                        Case Q:   c = c + 1
                        Case COM: If c Mod 2 Then Mid(s, p, 1) = ESC
                    End Select
                Next
                If InStrB(s, Q) Then s = Replace(s, Q, "")
                a = Split(s, COM)
                For j = 1 To cols
                    s = a(j - 1)
                    If InStrB(s, ESC) Then s = Replace(s, ESC, COM)
                    If InStrB(s, ENQ) Then s = Replace(s, ENQ, Q)
                    v(i, j) = s
                Next
            End If
        Next
        TXTtoArray = v
    End If
End Function

Function OpenTextFile$(f)
    With CreateObject("ADODB.Stream")
        .Charset = "utf-8"
        .Open
        .LoadFromFile f
        OpenTextFile = .ReadText
        .Close
    End With
End Function

Private Sub LocMouse_Click()
    PreviewMousePosition
End Sub

Sub LogAsk()
    '#INCLUDE InputboxString
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim cell As Range
    Set cell = ws.Range("A" & rows.count).End(xlUp).OFFSET(1)
    Dim msg As String
    msg = InputboxString()
    If Len(msg) = 0 Then Exit Sub
    If msg = "False" Then Exit Sub
    cell = "ask"
    cell.OFFSET(0, 1) = msg
End Sub

Sub IndexMouseLocation()
    Dim lngCurPos As POINTAPI
    Dim activeX As Long, activeY As Long
    On Error GoTo LoopEnd
    Application.EnableCancelKey = xlErrorHandler
    Do
        GetCursorPos lngCurPos
        activeX = lngCurPos.X
        activeY = lngCurPos.Y
        LabX.TEXT = activeX
        LabY.TEXT = activeY
        Sleep 20
        DoEvents
    Loop
LoopEnd:
    Application.EnableCancelKey = xlInterrupt
End Sub

Sub LogClick(ClickType As String)
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Erase MouseArray
    Dim rng As Range
    Dim lngCurPos As POINTAPI
    Dim activeX As Long, activeY As Long
    On Error GoTo LoopEnd
    Application.EnableCancelKey = xlErrorHandler
    Do
        GetCursorPos lngCurPos
        activeX = lngCurPos.X
        activeY = lngCurPos.Y
        LabX.TEXT = activeX
        LabY.TEXT = activeY
        Sleep 20
        DoEvents
    Loop
LoopEnd:
    'If err = 18 Then
    Application.EnableCancelKey = xlInterrupt
    Set rng = ws.Range("A" & rows.count).End(xlUp).OFFSET(1, 0)
    Set rng = rng.RESIZE(, 5)
    rng.Value = Array(ClickType, activeX, activeY, "", "")
        
    infoLab.Caption = "Macro recorded."
    'End If
End Sub

Sub LogClickImmediate()
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Erase MouseArray
    Dim rng As Range
    Dim lngCurPos As POINTAPI
    Dim previousX As Long, previousY As Long, activeX As Long, activeY As Long
    Dim previousL As Long, previousR As Long, activeL As Long, activeR As Long
    Dim arrayCounter As Long: arrayCounter = 1
    On Error GoTo LoopEnd
    Application.EnableCancelKey = xlErrorHandler
    Dim counter As Long
    Do
        ReDim Preserve MouseArray(1 To arrayCounter)
        GetCursorPos lngCurPos
        activeL = IIf(GetAsyncKeyState(1) = 0, 0, 1)
        activeR = IIf(GetAsyncKeyState(2) = 0, 0, 1)
        activeX = lngCurPos.X
        activeY = lngCurPos.Y
        If previousL <> activeL Or previousR <> activeR Then
            previousX = activeX
            previousY = activeY
            previousL = activeL
            previousR = activeR
            MouseArray(arrayCounter) = Join(Array(previousX, previousY, activeL, activeR), ",")
            arrayCounter = arrayCounter + 1
            DoEvents
            counter = counter + 1
            If counter = 4 Then GoTo LoopEnd
        End If
    Loop
LoopEnd:
    If err = 18 Then
        Application.EnableCancelKey = xlInterrupt
        Set rng = ws.Range("A" & rows.count).End(xlUp).OFFSET(1, 0)
        Set rng = rng.RESIZE(UBound(MouseArray), 1)
        rng = WorksheetFunction.Transpose(MouseArray)
        rng.TextToColumns rng, comma:=True
        Range(rng.Cells(1, 1), rng.Cells(2, 4)).Delete Shift:=xlUp
        'ws.Range("A3:D3").Delete Shift:=xlUp
        infoLab.Caption = "Macro recorded."
        '        infoLab.Caption = "Macro recorded at rows: " & rng.Row & " to " & rng.Row + rng.Rows.Count
        Exit Sub
    End If
End Sub

Sub LogDoulbe()
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Erase MouseArray
    Dim rng As Range
    Dim lngCurPos As POINTAPI
    Dim activeX As Long, activeY As Long
    On Error GoTo LoopEnd
    Application.EnableCancelKey = xlErrorHandler
    Do
        GetCursorPos lngCurPos
        activeX = lngCurPos.X
        activeY = lngCurPos.Y
        LabX.TEXT = activeX
        LabY.TEXT = activeY
        Sleep 20
        DoEvents
    Loop
LoopEnd:
    If err = 18 Then
        Application.EnableCancelKey = xlInterrupt
        Set rng = ws.Range("A" & rows.count).End(xlUp).OFFSET(1, 0)
        Set rng = rng.RESIZE(5)
        rng.Value = Array("double", activeX, activeY, "", "")
        infoLab.Caption = "Macro recorded."
        '        infoLab.Caption = "Macro recorded at rows: " & rng.Row & " to " & rng.Row + rng.Rows.Count
        Exit Sub
    End If
End Sub

Sub LogText()
    '#INCLUDE InputboxString
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim cell As Range
    Set cell = ws.Range("A" & rows.count).End(xlUp).OFFSET(1)
    Dim msg As String
    msg = InputboxString()
    If Len(msg) = 0 Then Exit Sub
    If msg = "False" Then Exit Sub
    cell = "sendkeys"
    cell.OFFSET(0, 1) = msg
End Sub

Sub MouseReplay(Optional rng As Range)
    '#INCLUDE DoubleClick
    '#INCLUDE LeftClick
    '#INCLUDE RightClick
    '#INCLUDE dragMouse
    '#INCLUDE FollowLink
    '#INCLUDE InputboxString
    '#INCLUDE CLIP
    '#INCLUDE IsFileFolderURL
    Completed = False
    'ActiveWindow.WindowState = xlMaximized
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim cell As Range
    If rng Is Nothing Then
        Set rng = ws.Range("A2").CurrentRegion
        Set rng = rng.OFFSET(1).RESIZE(rng.rows.count - 1, 1)
    End If
    If WorksheetFunction.CountA(rng) = 0 Then Exit Sub
    On Error GoTo LoopEnd
    Application.EnableCancelKey = xlErrorHandler
    Dim DefaultSleep As Long
    DefaultSleep = 300
    Dim msg As String

    For Each cell In rng
        
        Rem if automatic record of clicks and motion
        If IsNumeric(cell) Then

            SetCursorPos cell, cell.OFFSET(, 1)
            
            If cell.OFFSET(0, 2) > 1 Then
                dragMouse cell.Value, cell.OFFSET(0, 1), cell.OFFSET(0, 2), cell.OFFSET(0, 3)
            ElseIf cell.OFFSET(0, 2) = 1 Then
                If cell.OFFSET(1, 2) = 0 Then
                    '                    If cell.Offset(2, 2) = 0 And cell.Offset(-1, 2) = 0 Then
                    LeftClick
                    Set cell = cell.OFFSET(2, 0)
                    Rem This way doesn't work if logging clicks only and not motion because two left clicks will be interpreted as double click
                    '                    ElseIf cell.Offset(2, 2) = 1 Then
                    '                        DoubleClick
                    '                        Set cell = cell.Offset(2, 0)
                    '                    End If
                End If
            ElseIf cell.OFFSET(0, 3) = 1 Then
                RightClick
            End If
        Else
            Rem if manual entry
            If cell = "wait" Then
                Sleep IIf(cell.OFFSET(0, 1) <> "", cell.OFFSET(0, 1), DefaultSleep)
            ElseIf cell = "go" Then
                msg = Replace(cell.OFFSET(0, 1), """", "")
                If IsFileFolderURL(msg) <> "I" Then
                    FollowLink msg
                    Sleep 500
                End If
            ElseIf cell = "move" Then
                SetCursorPos cell.OFFSET(0, 1), cell.OFFSET(0, 2)
            ElseIf cell = "left" Then
                SetCursorPos cell.OFFSET(0, 1), cell.OFFSET(0, 2)
                LeftClick
            ElseIf cell = "right" Then
                SetCursorPos cell.OFFSET(0, 1), cell.OFFSET(0, 2)
                RightClick
            ElseIf cell = "double" Then
                SetCursorPos cell.OFFSET(0, 1), cell.OFFSET(0, 2)
                DoubleClick
            ElseIf cell = "drag" Then
                dragMouse cell.OFFSET(0, 1), cell.OFFSET(0, 2), cell.OFFSET(0, 3), cell.OFFSET(0, 4)
            ElseIf cell = "ask" Then
                msg = InputboxString(0, cell.OFFSET(0, 1))
                If Len(msg) > 0 Then
                    CLIP msg
                    SendKeys CLIP, True
                End If
            ElseIf cell = "sendkeys" Then
                Dim ClipText As String
                ClipText = IIf(cell.OFFSET(0, 2) = "", cell.OFFSET(0, 1), String(cell.OFFSET(0, 2), cell.OFFSET(0, 1)))
                CLIP ClipText
                SendKeys CLIP, True

            End If
        End If
        
        DoEvents
        Sleep 20        'DefaultSleep
        If Completed Then Exit Sub
    Next
LoopEnd:
    '    If err = 18 Then
    Application.EnableCancelKey = xlInterrupt
    Do While GetAsyncKeyState(1) = 1
        mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, 0
        DoEvents
    Loop
    Completed = True
    '    End If
End Sub

Sub MoveRows(offsetRows As Long)
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If ListboxSelectedCount(uMouseRecorder.lBoxData) = 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Range(ws.Cells(2 + r, 1), ws.Cells(2 + r, 5)).RESIZE(c)
    On Error Resume Next        ' in case user makes unreasonable action like only 1 row exists and try to move it
    rng.Cut
    If 2 + r + offsetRows < 2 Then
        ws.Range("A2:E2").Insert
    ElseIf 2 + r + offsetRows > ws.Range("A1").CurrentRegion.rows.count Then
        Dim lRow As Long
        lRow = ws.Range("A1").CurrentRegion.rows.count
        ws.Range("A" & lRow).RESIZE(, 5).Insert
    Else
        rng.OFFSET(offsetRows).Insert
    End If
    Application.CutCopyMode = False
End Sub

Sub MoveToBottom()
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If lBoxData.ListIndex = -1 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Range(ws.Cells(2 + r, 1), ws.Cells(2 + r, 5)).RESIZE(c)
    On Error Resume Next        ' in case user makes unreasonable action like only 1 row exists and try to move it
    rng.Cut
    Dim lRow As Long
    lRow = ws.Range("A1").CurrentRegion.rows.count + 1
    ws.Range("A" & lRow).RESIZE(, 5).Insert
    Application.CutCopyMode = False
End Sub

Sub MoveToTop()
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If lBoxData.ListIndex = -1 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Range(ws.Cells(2 + r, 1), ws.Cells(2 + r, 5)).RESIZE(c)
    On Error Resume Next        ' in case user makes unreasonable action like only 1 row exists and try to move it
    rng.Cut
    ws.Range("A2").RESIZE(, 5).Insert
    Application.CutCopyMode = False
End Sub

Function PickRecord(Optional initFolder As String) As String
    If initFolder = "" Then initFolder = MouseFolder
    Dim strFile As String
    Dim fd As Office.FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .Filters.clear
        .Filters.Add "MouseRecord", "*.txt"
        .title = "Choose Mouse Record"
        .AllowMultiSelect = False
        .initialFileName = initFolder
        If .Show = True Then
            strFile = .SelectedItems(1)
            PickRecord = strFile
        End If
    End With
End Function

Sub PlayBackSelectedRows()
    '#INCLUDE MouseReplay
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If ListboxSelectedCount(uMouseRecorder.lBoxData) = 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Cells(2 + r, 1).RESIZE(c)
    MouseReplay rng
End Sub

Sub PlayFromHere()
    '#INCLUDE MouseReplay
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If ListboxSelectedCount(uMouseRecorder.lBoxData) = 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = lBoxData.ListCount - r
    Set rng = ws.Cells(2 + r, 1).RESIZE(c)
    MouseReplay rng
End Sub

Sub PlayUntilHere()
    '#INCLUDE MouseReplay
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If ListboxSelectedCount(uMouseRecorder.lBoxData) = 0 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Set rng = ws.Cells(2, 1).RESIZE(r)
    MouseReplay rng
End Sub

Sub PreviewMousePosition()
    '#INCLUDE ListboxSelectedCount
    '#INCLUDE ListboxSelectedIndexes
    If lBoxData.ListIndex = -1 Then Exit Sub
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim r As Long
    r = ListboxSelectedIndexes(lBoxData)(1)
    Dim c As Long
    c = ListboxSelectedCount(lBoxData)
    Set rng = ws.Range(ws.Cells(2 + r, 1), ws.Cells(2 + r, 2))
    SetCursorPos rng.Cells(1, 1), rng.Cells(1, 2)
End Sub

Function RecordFileFullName() As String
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    RecordFileFullName = MouseFolder & ws.Range("H1") & "_mr.txt"
End Function

Function RecordRange() As Range
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    If ws.Range("A2") = "" Then Exit Function
    Dim rng As Range
    Set rng = ws.Range("A1").CurrentRegion
    Set rng = rng.OFFSET(1).RESIZE(rng.rows.count - 1, 5)
    Set RecordRange = rng
End Function

Sub RecordStart(Optional recordWholeMotion As Boolean)
    'ActiveWindow.WindowState = xlMaximized
    '#INCLUDE LoadMRcaption
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim lngCurPos As POINTAPI
    Dim previousX As Long, previousY As Long, activeX As Long, activeY As Long
    Dim previousL As Long, previousR As Long, activeL As Long, activeR As Long
    Erase MouseArray
    Dim arrayCounter As Long: arrayCounter = 1
    On Error GoTo LoopEnd
    Application.EnableCancelKey = xlErrorHandler
    Do
        ReDim Preserve MouseArray(1 To arrayCounter)
        GetCursorPos lngCurPos
        activeL = IIf(GetAsyncKeyState(1) = 0, 0, 1)
        activeR = IIf(GetAsyncKeyState(2) = 0, 0, 1)
        activeX = lngCurPos.X
        activeY = lngCurPos.Y
        If recordWholeMotion Then
            If previousX <> lngCurPos.X Or previousY <> lngCurPos.Y Or previousL <> activeL Or previousR <> activeR Then
                previousX = activeX
                previousY = activeY
                previousL = activeL
                previousR = activeR
                MouseArray(arrayCounter) = Join(Array(previousX, previousY, activeL, activeR), ",")
                arrayCounter = arrayCounter + 1
                DoEvents
            End If
        Else
            If previousL <> activeL Or previousR <> activeR Then
                previousX = activeX
                previousY = activeY
                previousL = activeL
                previousR = activeR
                MouseArray(arrayCounter) = Join(Array(previousX, previousY, activeL, activeR), ",")
                arrayCounter = arrayCounter + 1
                DoEvents
            End If
            LabX.TEXT = activeX
            LabY.TEXT = activeY
        End If
    Loop
LoopEnd:
    If err = 18 Then
        Application.EnableCancelKey = xlInterrupt
        Set rng = ws.Range("A" & rows.count).End(xlUp).OFFSET(1, 0)
        Set rng = rng.RESIZE(UBound(MouseArray), 1)
        rng = WorksheetFunction.Transpose(MouseArray)
        rng.TextToColumns rng, comma:=True
        rng.Columns(1).Cells.Font.Bold = False
        rng.Cells.Font.Bold = True
        infoLab.Caption = "Macro recorded at rows: " & rng.row & " to " & rng.row + rng.rows.count - 3
        Range(rng.Cells(1, 1), rng.Cells(2, 4)).Delete Shift:=xlUp
        LoadMRcaption
    End If
End Sub

Function RecordedMacro() As String
    '#INCLUDE ArrayToString
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Set rng = ws.Range("A2").CurrentRegion.OFFSET(1)
    Set rng = rng.RESIZE(rng.rows.count - 1)
    Dim arr
    arr = rng.Value
    RecordedMacro = ArrayToString(arr)
End Function

'RETURNS A STRING FROM A 2 DIM ARRAY, SPERATED BY OPTIONAL DELIMITER AND VBNEWLINE FOR EACH ROW
'
'@AUTHOR ROBERT TODAR
Public Function ArrayToString(SourceArray As Variant, Optional Delimiter As String = ",") As String
    '#INCLUDE ArrayDimensionLength
    
    Dim temp As String
    
    Select Case ArrayDimensionLength(SourceArray)
            'SINGLE DIMENTIONAL ARRAY
        Case 1
            temp = Join(SourceArray, Delimiter)
        
            '2 DIMENSIONAL ARRAY
        Case 2
            Dim RowIndex As Long
            Dim ColIndex As Long
            
            'LOOP EACH ROW IN MULTI ARRAY
            For RowIndex = LBound(SourceArray, 1) To UBound(SourceArray, 1)
                
                'LOOP EACH COLUMN ADDING VALUE TO STRING
                For ColIndex = LBound(SourceArray, 2) To UBound(SourceArray, 2)
                    temp = temp & SourceArray(RowIndex, ColIndex)
                    If ColIndex <> UBound(SourceArray, 2) Then temp = temp & Delimiter
                Next ColIndex
                
                'ADD NEWLINE FOR THE NEXT ROW (MINUS LAST ROW)
                If RowIndex <> UBound(SourceArray, 1) Then temp = temp & vbNewLine
        
            Next RowIndex
    End Select
    
    ArrayToString = temp
    
End Function

'RETURNS THE LENGHT OF THE DIMENSION OF AN ARRAY
Public Function ArrayDimensionLength(SourceArray As Variant) As Integer
    
    Dim i As Integer
    Dim test As Long

    On Error GoTo catch
    Do
        i = i + 1
        test = UBound(SourceArray, i)
    Loop
    
catch:
    ArrayDimensionLength = i - 1

End Function

Sub RightClick()
    'Right click
    mouse_event MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0
    mouse_event MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0
End Sub

Sub SaveRecord()
    '#INCLUDE RecordFileFullName
    '#INCLUDE RecordedMacro
    '#INCLUDE txtoverwrite
    '#INCLUDE TxtOverwrite
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Set rng = ws.Range("A2").CurrentRegion
    Set rng = rng.OFFSET(1).RESIZE(rng.rows.count - 1)
    TxtOverwrite RecordFileFullName, RecordedMacro
End Sub

Sub checkFile()
    '#INCLUDE RecordFileFullName
    '#INCLUDE FileExists
    Dim recFile As String
    recFile = RecordFileFullName
    Dim recFileName As String
    recFileName = IIf(FileExists(recFile) = True, recFile, "NONE")
    LoadedRecording.Caption = recFileName
    Me.LoadedRecording.ControlTipText = Mid(recFileName, InStrRev(recFileName, "\") + 1)
End Sub

Sub dragMouse(x0 As Long, y0 As Long, X1 As Long, Y1 As Long)
    SetCursorPos x0, y0
    mouse_event MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0
    Sleep 20
    SetCursorPos X1, Y1
    Sleep 20
    mouse_event MOUSEEVENTF_LEFTUP, 0, 0, 0, 0
End Sub

Private Sub iBottom_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    MoveToBottom
    LoadListbox
End Sub

Private Sub iBottom_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iBottom.ControlTipText
End Sub

Private Sub iDelete_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    DeleteRows
    LoadListbox
End Sub

Private Sub iDelete_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iDelete.ControlTipText
End Sub

Private Sub iDown_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    MoveRows 2
    LoadListbox
End Sub

Private Sub iDown_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iDown.ControlTipText
End Sub

Private Sub iDuplicate_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    DuplicateRows
End Sub

Private Sub iDuplicate_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iDuplicate.ControlTipText
End Sub

Private Sub iFolder_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    FollowLink MouseFolder
End Sub

Private Sub iFolder_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iFolder.ControlTipText
End Sub

Private Sub iLoadRecord_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    LoadRecord
    LoadedRecording.ControlTipText = LoadedRecording.Caption
    Dim s As String
    s = LoadedRecording.Caption
    s = Mid(s, InStrRev(s, "\") + 1)
    Me.Caption = s
End Sub

Private Sub iLoadRecord_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iLoadRecord.ControlTipText
End Sub

Private Sub iLogAsk_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    LogAsk
    LoadListbox
End Sub

Private Sub iLogAsk_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iLogAsk.ControlTipText
End Sub

Private Sub iLogClick_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    LogClick "left"
    LoadListbox
End Sub

Private Sub iLogClick_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iLogClick.ControlTipText
End Sub

Private Sub iLogDouble_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    LogClick "double"
    LoadListbox
End Sub

Private Sub iLogDouble_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iLogDouble.ControlTipText
End Sub

Private Sub iLogInput_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    LogText
    LoadListbox
End Sub

Private Sub iLogInput_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iLogInput.ControlTipText
End Sub

Private Sub iMemo_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    EditMemo

End Sub

Private Sub iMemo_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iMemo.ControlTipText
End Sub

Private Sub iNewFile_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    newRecord
    LoadListbox
End Sub

Private Sub iNewFile_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iNewFile.ControlTipText
End Sub

Private Sub iPlayAll_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Me.Hide
    MouseReplay
    Me.Show
End Sub

Private Sub iPlayAll_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iPlayAll.ControlTipText
End Sub

Private Sub iPlayFromHere_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Me.Hide
    PlayFromHere
    Me.Show
End Sub

Private Sub iPlayFromHere_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iPlayFromHere.ControlTipText
End Sub

Private Sub iPlaySelection_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    PlayBackSelectedRows
End Sub

Private Sub iPlaySelection_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iPlaySelection.ControlTipText
End Sub

Private Sub iPlayUntilHere_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Me.Hide
    PlayUntilHere
    Me.Show
End Sub

Private Sub iPlayUntilHere_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iPlayUntilHere.ControlTipText
End Sub

Private Sub iRecClick_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    RecordStart ClicksOnly.Value
    LoadListbox
End Sub

Private Sub iRecClick_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iRecClick.ControlTipText
End Sub

Private Sub iRecDrag_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    recordDrag
    LoadListbox
End Sub

Private Sub iRecDrag_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iRecDrag.ControlTipText
End Sub

Private Sub iSave_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    If ws.Range("A2") = "" Then
        infoLab.Caption = "Record something first"
        Exit Sub
    End If
    Dim FName As String
    FName = InputboxString(, , ws.Range("H1"))
    If Len(FName) <> 0 And FName <> "False" Then
        ws.Range("H1") = FName
        SaveRecord
    End If
    LoadMRcaption
End Sub

Private Sub iSave_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iSave.ControlTipText
End Sub

Private Sub iTop_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    MoveToTop
    LoadListbox
End Sub

Private Sub iTop_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iTop.ControlTipText
End Sub

Private Sub iUp_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    MoveRows -1
    LoadListbox
End Sub

Private Sub iUp_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = iUp.ControlTipText
End Sub

Private Sub info_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    infoLab.Caption = info.ControlTipText
End Sub

Private Sub lBoxData_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    EditRow
End Sub

Private Sub labHome_Click()
    labHome.SpecialEffect = fmSpecialEffectSunken
    labRec.SpecialEffect = fmSpecialEffectRaised
    fFile.left = 30
    fPlay.left = 30
    fRecord.left = 255
    fLog.left = 255
End Sub

Private Sub labRec_Click()
    labHome.SpecialEffect = fmSpecialEffectRaised
    labRec.SpecialEffect = fmSpecialEffectSunken
    fFile.left = 255
    fPlay.left = 255
    fRecord.left = 30
    fLog.left = 83
End Sub

Rem @NOT WORKING - forces motion top to bottom?
Sub moveFromAtoB(x0 As Long, y0 As Long, X1 As Long, Y1 As Long)
    Dim steep As Boolean: steep = Abs(Y1 - y0) > Abs(X1 - x0)
    Dim t As Integer
    If steep Then
        '// swap(x0, y0);
        t = x0
        x0 = y0
        y0 = t
        ' // swap(x1, y1);
        t = X1
        X1 = Y1
        Y1 = t
    End If
    If x0 > X1 Then
        '// swap(x0, x1);
        t = x0
        x0 = X1
        X1 = t
        '// swap(y0, y1);
        t = y0
        y0 = Y1
        Y1 = t
    End If
    Dim deltax As Integer: deltax = X1 - x0
    Dim deltay As Integer: deltay = Abs(Y1 - y0)
    Dim deviation As Integer: deviation = deltax / 2
    Dim ystep As Integer
    Dim Y  As Integer: Y = y0
    If y0 < Y1 Then
        ystep = 1
    Else
        ystep = -1
    End If
    Dim X As Integer
    For X = x0 To X1 Step ystep
        If steep Then
            SetCursorPos Y, X
        Else
            SetCursorPos X, Y
        End If
        deviation = deviation - deltay
        If deviation < 0 Then
            Y = Y + ystep
            deviation = deviation + deltax
        End If
        DoEvents
        Sleep 1
    Next
End Sub

Sub newRecord()
    '#INCLUDE LoadMRcaption
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    ws.Range("A2").CurrentRegion.OFFSET(1).ClearContents
    ws.Range("R7").CurrentRegion.OFFSET(1).ClearContents
    ws.Range("H1").ClearContents
    LoadMRcaption
End Sub

Sub recordDrag()
    Dim ws As Worksheet: Set ws = ThisWorkbook.SHEETS("MouseDB")
    Dim rng As Range
    Dim lngCurPos As POINTAPI
    Dim previousX As Long, previousY As Long, activeX As Long, activeY As Long
    Dim previousL As Long, previousR As Long, activeL As Long, activeR As Long
    Erase MouseArray
    Dim arrayCounter As Long: arrayCounter = 1
    On Error GoTo LoopEnd
    Application.EnableCancelKey = xlErrorHandler
    Do
        ReDim Preserve MouseArray(1 To arrayCounter)
        GetCursorPos lngCurPos
        activeL = IIf(GetAsyncKeyState(1) = 0, 0, 1)
        activeR = IIf(GetAsyncKeyState(2) = 0, 0, 1)
        activeX = lngCurPos.X
        activeY = lngCurPos.Y
        If previousX <> lngCurPos.X Or previousY <> lngCurPos.Y Or previousL <> activeL Or previousR <> activeR Then
            previousX = activeX
            previousY = activeY
            previousL = activeL
            previousR = activeR
            MouseArray(arrayCounter) = Join(Array(previousX, previousY, activeL, activeR), ",")
            arrayCounter = arrayCounter + 1
        End If
    Loop
LoopEnd:
    If err = 18 Then
        Application.EnableCancelKey = xlInterrupt
        Dim arr
        arr = MouseArray
        arr = Filter(arr, ",1,", , vbTextCompare)
        Set rng = ws.Range("A" & rows.count).End(xlUp).OFFSET(1, 0)
        'Set rng = rng.Resize(UBound(arr), 1)
        rng = WorksheetFunction.Transpose(arr)
        rng.TextToColumns rng, comma:=True
        rng.OFFSET(0, 4) = "DRAG"
        rng.OFFSET(2).RESIZE(rng.rows.count - 3, 5).Delete xlUp
        rng.RESIZE(1, 5).Delete xlUp
        rng.OFFSET(0, 2).RESIZE(1, 2).Value = rng.OFFSET(1).RESIZE(1, 2).Value
        rng.OFFSET(1).RESIZE(1, 5).Delete xlUp
        infoLab.Caption = "Drag recorded."
        '        infoLab.Caption = "Drag recorded at rows: " & rng.Row & " to " & rng.Row + rng.Rows.Count
    End If
End Sub

' Enum MouseButtonConstants
' vbLeftButton
' vbMiddleButton
' vbRightButton
' End Enum
'
''simulate the MouseDown event
' Sub ButtonDown(Optional ByVal Button As MouseButtonConstants = _
'    vbLeftButton)
'    Dim lFlag As Long
'    If Button = vbLeftButton Then
'        lFlag = MOUSEEVENTF_LEFTDOWN
'    ElseIf Button = vbMiddleButton Then
'        lFlag = MOUSEEVENTF_MIDDLEDOWN
'    ElseIf Button = vbRightButton Then
'        lFlag = MOUSEEVENTF_RIGHTDOWN
'    End If
'    mouse_event lFlag, 0, 0, 0, 0
'End Sub
'
''simulate the MouseUp event
'
' Sub ButtonUp(Optional ByVal Button As MouseButtonConstants = _
'    vbLeftButton)
'    Dim lFlag As Long
'    If Button = vbLeftButton Then
'        lFlag = MOUSEEVENTF_LEFTUP
'    ElseIf Button = vbMiddleButton Then
'        lFlag = MOUSEEVENTF_MIDDLEUP
'    ElseIf Button = vbRightButton Then
'        lFlag = MOUSEEVENTF_RIGHTUP
'    End If
'    mouse_event lFlag, 0, 0, 0, 0
'End Sub
'
''simulate the MouseClick event
'
' Sub ButtonClick(Optional ByVal Button As MouseButtonConstants = _
'    vbLeftButton)
'    ButtonDown Button
'    ButtonUp Button
'End Sub
'
''simulate the MouseDblClick event
'
' Sub ButtonDblClick(Optional ByVal Button As MouseButtonConstants = _
'    vbLeftButton)
'    ButtonClick Button
'    ButtonClick Button
'End Sub


'Sub AlternativeLogPlayback()
'Rem from different logging style
'Dim DefaultSleep As Long
'DefaultSleep = 1000
'Dim cell As Range, rng As Range
'Set rng = ActiveSheet.Range("A1").CurrentRegion
'Set rng = rng.Resize(, 1).offset(1).Resize(rng.rows.count - 1)
'    Dim lngCurPos As POINTAPI, activeX As Long, activeY As Long
'    GetCursorPos lngCurPos
'    activeX = lngCurPos.x
'    activeY = lngCurPos.y
'For Each cell In rng
'    If cell <> "drag" Then
'        If cell.offset(0, 1) <> "" And cell.offset(0, 2) <> "" Then
'            'moveFromAtoB activeX, activeY, CLng(cell.offset(0, 1)), CLng(cell.offset(0, 2).Value)
'            SetCursorPos cell.offset(0, 1), cell.offset(0, 2)
'        End If
'   End If
'    If cell = "move" Then
'        'moveFromAtoB activeX, activeY, CLng(cell.offset(0, 1)), CLng(cell.offset(0, 2).Value)
'       SetCursorPos cell.offset(0, 1), cell.offset(0, 2)
'    ElseIf cell = "left" Then LeftClick
'    ElseIf cell = "double" Then DoubleClick
'    ElseIf cell = "right" Then RightClick
'    ElseIf cell = "drag" Then
'        GetCursorPos lngCurPos
'        activeX = lngCurPos.x
'        activeY = lngCurPos.y
'        dragMouse activeX, activeY, cell.offset(0, 1), cell.offset(0, 2)
'    ElseIf cell = "type" Then
'        CLIP cell.offset(0, 1)
'        SendKeys CLIP, True
'    ElseIf cell = "ask" Then
'        Dim msg As String
'        msg = InputboxString()
'        CLIP msg
'        SendKeys CLIP, True
'    End If
'    If cell = "wait" Then
'        Sleep IIf(cell.offset(0, 1) <> "", cell.offset(0, 1), DefaultSleep)
'    Else
'        Sleep DefaultSleep
'    End If
'    DoEvents
'Next
'End Sub


Sub CreateListboxHeader(body As MSForms.ListBox, header As MSForms.ListBox, arrHeaders)
    '#INCLUDE ArrayDimensions

    header.Width = body.Width
    Dim i As Long
    
    'must have a listbox to use as headers
    
    'header.columnCount = body.columnCount
    If header.ColumnWidths <> body.ColumnWidths And body.ColumnWidths <> "" Then
        header.ColumnWidths = body.ColumnWidths
    End If
    'add headerelements
    header.clear
    header.AddItem
    
    If ArrayDimensions(arrHeaders) = 1 Then
        For i = 0 To UBound(arrHeaders)
            'make it prety
            header.list(0, i) = arrHeaders(i)
        Next i
    Else
        For i = 1 To UBound(arrHeaders, 2)
            header.list(0, i - 1) = arrHeaders(1, i)
        Next i
    End If
    body.ZOrder (1)
    header.ZOrder (0)
    header.SpecialEffect = fmSpecialEffectFlat
    header.BackColor = RGB(200, 200, 200)
    'align header to body
    header.Height = 15
    header.Width = body.Width
    header.left = body.left
    header.top = body.top - header.Height - 1
    header.Font.Bold = True
    header.Font.Name = "Comic Sans MS"
    header.Font.Size = 9
    '    header.ForeColor =
    '    header.BackColor =
End Sub



'U_MemoryKnots	1


Rem  Procedure : ExportRangeAsImage
Rem  Author    : Daniel Pineault, CARDA Consultants Inc.
Rem  Website   : http://www.cardaconsultants.com
Rem  Purpose   : Capture a picture of a worksheet range and save it to disk
Rem                Returns True if the operation is successful
Rem  Note      : *** Overwrites files, if already exists, without any warning! ***
Rem  Copyright : The following is release as Attribution-ShareAlike 4.0 International
Rem              (CC BY-SA 4.0) - https://creativecommons.org/licenses/by-sa/4.0/
Rem  Reqrem d Refs: Uses Late Binding, so none required
Rem
Rem  Input Variables:
Rem  ~~~~~~~~~~~~~~~~
Rem  ws            : Worksheet to capture the image of the range from
Rem  rng           : Range to capture an image of
Rem  sPath         : Fully qualified path where to export the image to
Rem  sFileName     : filename to save the image to WITHOUT the extension, just the name
Rem  sImgExtension : The image file extension, commonly: JPG, GIF, PNG, BMP
Rem                    If omitted will be JPG format
Rem
Rem  Usage:
Rem  ~~~~~~
Rem  ? ExportRangeAsImage(Sheets("Sheet1"), Range("A1"), "C:\Temp\Charts\", "test01". "JPG")
Rem  ? ExportRangeAsImage(Sheets("Products"), Range("D5:F23"), "C:\Temp\Charts", "test02")
Rem  ? ExportRangeAsImage(Sheets("Sheet1"), Range("A1"), "C:\Temp\Charts\", "test01", "PNG")
Rem

Rem  Revision History:
Rem  Rev       Date(yyyy/mm/dd)        Description
Rem  **************************************************************************************
Rem  1         2020-04-06              Initial Release
Function ExportRangeAsImage(ws As Worksheet, _
                            rng As Range, _
                            sPath As String, _
                            sFilename As String, _
                            Optional sImgExtension As String = "JPG") As Boolean
    Dim oChart                As ChartObject
    On Error GoTo Error_Handler
    If Right(sPath, 1) <> "\" Then sPath = sPath & "\"
    Application.ScreenUpdating = False
    ws.Activate
    rng.CopyPicture xlScreen, xlPicture
    Set oChart = ws.ChartObjects.Add(0, 0, rng.Width, rng.Height)
    oChart.Activate
    With oChart.Chart
        .Paste
        .Export sPath & sFilename & "." & LCase(sImgExtension), sImgExtension
    End With
    oChart.Delete
    ExportRangeAsImage = True
Error_Handler_Exit:
    On Error Resume Next
    Application.ScreenUpdating = True
    If Not oChart Is Nothing Then Set oChart = Nothing
    Exit Function
Error_Handler:
    MsgBox "The following error has occurred" & vbCrLf & vbCrLf & _
           "Error Number: " & err.Number & vbCrLf & _
           "Error Source: ExportRangeAsImage" & vbCrLf & _
           "Error Description: " & err.Description & _
           Switch(Erl = 0, "", Erl <> 0, vbCrLf & "Line No: " & Erl) _
           , vbOKOnly + vbCritical, "An Error has Occurred!"
    Resume Error_Handler_Exit
End Function

Sub ListboxSortAZ(myListBox As MSForms.ListBox, Optional resetMacro As String)
    Dim j As Long
    Dim i As Long
    Dim temp As Variant
    If resetMacro <> "" Then
        Run resetMacro, myListBox
    End If
    With myListBox
        For j = 0 To .ListCount - 2
            For i = 0 To .ListCount - 2
                If LCase(.list(i)) > LCase(.list(i + 1)) Then
                    temp = .list(i)
                    .list(i) = .list(i + 1)
                    .list(i + 1) = temp
                End If
            Next i
        Next j
    End With
End Sub

Sub ListboxSortZA(myListBox As MSForms.ListBox, Optional resetMacro As String)
    Dim j As Long
    Dim i As Long
    Dim temp As Variant
    If resetMacro <> "" Then
        Run resetMacro, myListBox
    End If
    With myListBox
        For j = 0 To .ListCount - 2
            For i = 0 To .ListCount - 2
                If LCase(.list(i)) < LCase(.list(i + 1)) Then
                    temp = .list(i)
                    .list(i) = .list(i + 1)
                    .list(i + 1) = temp
                End If
            Next i
        Next j
    End With
End Sub

Function SelectionValues(link As String)
    Dim c As Range
    If TypeName(Selection) = "Range" _
                             And Selection.Cells.count = 1 Then
        SelectionValues = Selection.Value
    ElseIf TypeName(Selection) = "Range" Then
        For Each c In Selection.SpecialCells(xlCellTypeVisible)
            If Len(c.Value) <> 0 Then
                If SelectionValues = "" Then
                    SelectionValues = c.Value
                Else
                    SelectionValues = SelectionValues & link & c.Value
                End If
            End If
        Next c
    End If
End Function

Function Listbox_Selected(lBox As MSForms.ListBox, Count_Indexes_Values As Integer)
    Dim SelectedIndexes As String
    Dim SelectedValues As String
    Dim SelectedCount As Integer
    Dim i As Long
    With lBox
        For i = 0 To .ListCount - 1
            If .SELECTED(i) Then
                SelectedCount = SelectedCount + 1
                SelectedIndexes = SelectedIndexes & i & ","
                SelectedValues = SelectedValues & .list(i) & ","
            End If
        Next i
    End With
    If SelectedCount = 0 Then
        Listbox_Selected = 0
        Exit Function
    End If
    SelectedIndexes = left(SelectedIndexes, Len(SelectedIndexes) - 1)
    SelectedValues = left(SelectedValues, Len(SelectedValues) - 1)
    Select Case Count_Indexes_Values
        Case Is = 1
            Listbox_Selected = SelectedCount
        Case Is = 2
            Listbox_Selected = SelectedIndexes
        Case Is = 3
            Listbox_Selected = SelectedValues
    End Select
End Function

Sub ListboxClearSelection(lBox As MSForms.ListBox)
    On Error Resume Next
    For i = 0 To lBox.ListCount
        lBox.SELECTED(i) = False
    Next i
End Sub

Sub ListboxSelectValue(lBox As MSForms.ListBox, str As String, Optional clr As Boolean = True)
    '#INCLUDE ListboxClearSelection
    If clr = True Then ListboxClearSelection (lBox)
    For i = 0 To lBox.ListCount - 1
        If lBox.list(i) = str Then
            lBox.SELECTED(i) = True
            Exit Sub
        End If
    Next i
End Sub

Rem  Zip a file or a folder to a zip file/folder using Windows Explorer.
Rem  Default behaviour is similar to right-clicking a file/folder and selecting:
Rem    Send to zip file.
Rem
Rem  Parameters:
Rem    Path:
Rem        Valid (UNC) path to the file or folder to zip.
Rem    Destination:
Rem        (Optional) Valid (UNC) path to file with zip extension or other extension.
Rem    Overwrite:
Rem        (Optional) Leave (default) or overwrite an existing zip file.
Rem        If False, the created zip file will be versioned: Example.zip, Example (2).zip, etc.
Rem        If True, an existing zip file will first be deleted, then recreated.
Rem
Rem    Path and Destination can be relative paths. If so, the current path is used.
Rem
Rem    If success, 0 is returned, and Destination holds the full path of the created zip file.
Rem    If error, error code is returned, and Destination will be zero length string.
Rem
Rem  Early binding requires references to:
Rem
Rem    Shell:
Rem        Microsoft Shell Controls And Automation
Rem
Rem    Scripting.FileSystemObject:
Rem        Microsoft Scripting Runtime
Rem
Rem  2017-10-22. Gustav Brock. Cactus Data ApS, CPH.
Public Function Zip( _
       ByVal Path As String, _
       Optional ByRef Destination As String, _
       Optional ByVal Overwrite As Boolean) _
        As Long
    '#INCLUDE FileExists
    '#INCLUDE FolderExists
    '#INCLUDE OpenTextFile
    '#INCLUDE getFolder
    #If EarlyBinding Then
        Dim FileSystemObject    As Scripting.FileSystemObject
        Dim ShellApplication    As Shell
        Set FileSystemObject = New Scripting.FileSystemObject
        Set ShellApplication = New Shell
    #Else
        Dim FileSystemObject    As Object
        Dim ShellApplication    As Object
        Set FileSystemObject = CreateObject("Scripting.FileSystemObject")
        Set ShellApplication = CreateObject("Shell.Application")
    #End If
    Const ZipExtensionName  As String = "zip"
    Const ZipExtension      As String = "." & ZipExtensionName
    Const ErrorPathFile     As Long = 75
    Const ErrorOther        As Long = -1
    Const ErrorNone         As Long = 0
    Const MaxZipVersion     As Integer = 1000
    Dim ZipHeader           As String
    Dim ZipPath             As String
    Dim ZipName             As String
    Dim ZipFile             As String
    Dim ZipBase             As String
    Dim ZipTemp             As String
    Dim Version             As Integer
    Dim result              As Long
    If FileSystemObject.FileExists(Path) Then
        ZipName = FileSystemObject.GetBaseName(Path) & ZipExtension
        ZipPath = FileSystemObject.GetFile(Path).ParentFolder
    ElseIf FileSystemObject.FolderExists(Path) Then
        ZipName = FileSystemObject.GetBaseName(Path) & ZipExtension
        ZipPath = FileSystemObject.getFolder(Path).ParentFolder
    Else
    End If
    If ZipName = "" Then
        Destination = ""
    Else
        If Destination <> "" Then
            If FileSystemObject.GetExtensionName(Destination) = "" Then
                ZipPath = Destination
            Else
                ZipName = FileSystemObject.GetFileName(Destination)
                ZipPath = FileSystemObject.GetParentFolderName(Destination)
            End If
        Else
        End If
        ZipFile = FileSystemObject.BuildPath(ZipPath, ZipName)
        If FileSystemObject.FileExists(ZipFile) Then
            If Overwrite = True Then
                FileSystemObject.DeleteFile ZipFile, True
            Else
                ZipBase = FileSystemObject.GetBaseName(ZipFile)
                Version = Version + 1
                Do
                    Version = Version + 1
                    ZipFile = FileSystemObject.BuildPath(ZipPath, ZipBase & Format(Version, " \(0\)") & ZipExtension)
                Loop Until FileSystemObject.FileExists(ZipFile) = False Or Version > MaxZipVersion
                If Version > MaxZipVersion Then
                    err.Raise ErrorPathFile, "Zip Create", "File could not be created."
                End If
            End If
        End If
        ZipTemp = FileSystemObject.BuildPath(ZipPath, FileSystemObject.GetBaseName(FileSystemObject.GetTempName()) & ZipExtension)
        ZipHeader = Chr(80) & Chr(75) & Chr(5) & Chr(6) & String(18, vbNullChar)
        With FileSystemObject.OpenTextFile(ZipTemp, ForWriting, True)
            .Write ZipHeader
            .Close
        End With
        ZipTemp = FileSystemObject.GetAbsolutePathName(ZipTemp)
        Path = FileSystemObject.GetAbsolutePathName(Path)
        With ShellApplication
            Debug.Print Timer, "Zipping started . ";
            .Namespace(CVar(ZipTemp)).CopyHere CVar(Path)
            On Error Resume Next
            Do Until .Namespace(CVar(ZipTemp)).items.count = 1
                Application.Wait (Now + TimeValue("0:00:01"))
                Debug.Print ".";
            Loop
            Debug.Print
            On Error GoTo 0
            Debug.Print Timer, "Zipping finished."
        End With
        FileSystemObject.MoveFile ZipTemp, ZipFile
    End If
    Set ShellApplication = Nothing
    Set FileSystemObject = Nothing
    If err.Number <> ErrorNone Then
        Destination = ""
        result = err.Number
    ElseIf Destination = "" Then
        result = ErrorOther
    End If
    Zip = result
End Function

Sub ExportNotes()
    Dim fso As Object
    Set fso = VBA.CreateObject("Scripting.FileSystemObject")
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Dim strPath As String
    strPath = memoPath
    If strPath = "" Then Exit Sub
    On Error Resume Next
    fso.CopyFile Workbooks("MemoryKnots.xlam").FullName, strPath
    Workbooks("MemoryKnots.xlam").SHEETS.Copy
    ActiveWorkbook.SHEETS("MemoryKnots_Settings").Delete
    ActiveWorkbook.SaveAs fileName:=strPath & "MemoryKnots.xlsx", _
                          FileFormat:=xlOpenXMLWorkbook, CreateBackup:=False
    ActiveWorkbook.Saved = True
    ActiveWorkbook.Close
    CreateObject("WScript.Shell").PopUp "Successfully exported to " & Chr(10) & strPath, 1
    ActiveWindow.Close
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
End Sub

Function PickFolder()
    With Application.FileDialog(msoFileDialogFolderPicker)
        .initialFileName = Environ("USERprofile") & "\Desktop\"
        If .Show = -1 Then
            PickFolder = .SelectedItems(1) & "\"
        Else
            Exit Function
        End If
    End With
End Function

Sub ImportNotes()
    '#INCLUDE IsWorkBookOpen
    Dim strADMIN As String
    Dim answer As Integer
    answer = MsgBox("ATTENTION!" & Chr(10) & Chr(10) & _
                    "Present Notebooks will be DELETED and REPLACED from IMPORT file" & Chr(10) & Chr(10) & _
                    "Proceed? (YES) or Cancel import? (NO)", _
                    vbYesNo)
    If answer = vbYes Then
    Else
        Exit Sub
    End If
    Dim AddinWorkbook As Workbook
    Set AddinWorkbook = Workbooks("MemoryKnots.xlam")
    Dim ImportWorkbook As Workbook
    If IsWorkBookOpen("MemoryKnots.xlsx") Then
        Set ImportWorkbook = Workbooks("MemoryKnots.xlsx")
    Else
        If Dir(memoPath & "MemoryKnots.xlsx") > Len(memoPath) Then
            Set ImportWorkbook = Workbooks.Open(memoPath & "MemoryKnots.xlsx")
        Else
            CreateObject("WScript.Shell").PopUp "MemoryKnots.xlsx not found. Use EXPORT first.", 1
            GoTo cleanup
        End If
    End If
    ImportWorkbook.Save
    Application.ScreenUpdating = False
    AddinWorkbook.IsAddin = False
    Dim ws As Worksheet
    Application.DisplayAlerts = False
    For Each ws In AddinWorkbook.Worksheets
        If ws.Name <> "MemoryKnots_Settings" Then ws.Delete
    Next ws
    Dim cell As Range
    For Each ws In ImportWorkbook.Worksheets
        If left(ws.Name, 1) = "o" Then
            For Each cell In ws.Columns(2)
                If cell.Value = "" Then Exit For
                If cell.OFFSET(0, -1) = "" Then
                    cell.OFFSET(0, -1) = Now()
                End If
            Next cell
        End If
    Next ws
    For Each ws In ImportWorkbook.Worksheets
        If ws.Name <> "MemoryKnots_Settings" Then
            ws.Copy After:=AddinWorkbook.SHEETS(AddinWorkbook.SHEETS.count)
        End If
    Next ws
cleanup:
    Application.DisplayAlerts = True
    AddinWorkbook.IsAddin = True
    Set ws = Nothing
    Set ImportWorkbook = Nothing
    Set AddinWorkbook = Nothing
    Application.ScreenUpdating = True
End Sub

Sub testgetfile()
    '#INCLUDE GetFileToImport
    Debug.Print GetFileToImport("xlsx", False)
End Sub

Function GetFileToImport(Optional fileType As String, Optional multiSelect As Boolean) As String
    Dim blArray As Boolean
    Dim strErrMsg As String, strTitle As String
    strTitle = "Import Notebooks"
    If IsMissing(fileType) Then
        Exit Function
    End If
    If strErrMsg = vbNullString Then
        With Application.FileDialog(msoFileDialogFilePicker)
            .initialFileName = "MemoryKnots.xlsx"
            .AllowMultiSelect = multiSelect
            .Filters.clear
            If blArray Then .Filters.Add "File type", "*." & fileType
            .title = strTitle
            If .Show <> 0 Then
                GetFileToImport = .SelectedItems(1)
            End If
        End With
    Else
        MsgBox strErrMsg, vbCritical, "Error!"
    End If
End Function

Function IsWorkBookOpen(Name As String) As Boolean
    Dim xWb As Workbook
    On Error Resume Next
    Set xWb = Application.Workbooks.item(Name)
    IsWorkBookOpen = (Not xWb Is Nothing)
End Function



'F_Wav	1

'Option Compare Database
Option Explicit
Rem @Subfolder Wav>FromVoice
Rem found at http://www.vbarchiv.net
Public Declare PtrSafe Function sndPlaySound Lib "winmm.dll" Alias "sndPlaySoundA" _
(ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
Const SND_SYNC = &H0
Const SND_ASYNC = &H1
Const SND_FILENAME = &H20000
Public Declare PtrSafe Function mciSendString Lib "winmm.dll" _
Alias "mciSendStringA" ( _
ByVal lpstrCommand As String, _
ByVal lpstrReturnString As String, _
ByVal uReturnLength As Long, _
ByVal hwndCallback As Long) As Long
Public Enum BitsPerSec
    Bits16 = 16
    Bits8 = 8
End Enum

Public Enum SampelsPerSec
    Sampels8000 = 8000
    Sampels11025 = 11025
    Sampels12000 = 12000
    Sampels16000 = 16000
    Sampels22050 = 22050
    Sampels24000 = 24000
    Sampels32000 = 32000
    Sampels44100 = 44100
    Sampels48000 = 48000
End Enum

Public Enum Channels
    Mono = 1
    Stereo = 2
End Enum

Public Sub play(file As String)
    Dim wavefile
    wavefile = file
    Call sndPlaySound(wavefile, SND_ASYNC Or SND_FILENAME)
End Sub

Public Sub StartRecord(ByVal BPS As BitsPerSec, _
                       ByVal SPS As SampelsPerSec, ByVal Mode As Channels)
    Dim retStr As String
    Dim cBack As Long
    Dim BytesPerSec As Long
    retStr = Space$(128)
    BytesPerSec = (Mode * BPS * SPS) / 8
    mciSendString "open new type waveaudio alias capture", retStr, 128, cBack
    mciSendString "set capture time format milliseconds" & _
                  " bitspersample " & CStr(BPS) & _
                  " samplespersec " & CStr(SPS) & _
                  " channels " & CStr(Mode) & _
                  " bytespersec " & CStr(BytesPerSec) & _
                  " alignment 4", retStr, 128, cBack
    mciSendString "record capture", retStr, 128, cBack
End Sub

Public Sub SaveRecord(strFile)
    Dim retStr As String
    Dim TempName As String
    Dim cBack As Long
    Dim fs, f
    TempName = strFile        'Left$(strFile, 3) & "Temp.wav"
    retStr = Space$(128)
    mciSendString "stop capture", retStr, 128, cBack
    mciSendString "save capture " & TempName, retStr, 128, cBack
    mciSendString "close capture", retStr, 128, cBack
End Sub

Public Sub StartRecord_Click()
    '#INCLUDE StartRecord
    F_Wav.StartRecord Bits16, Sampels32000, Mono
End Sub

Public Sub EndRecord_Click()
    '#INCLUDE SaveRecord
    F_Wav.SaveRecord Environ("USERPROFILE") & "\Desktop\test.wav"
End Sub

Public Sub Play_Click()
    '#INCLUDE play
    F_Wav.play Environ("USERPROFILE") & "\Desktop\test.wav"
End Sub

Rem @Subfolder Wav>FromString
Sub TestStringToWavFile()
    'needs reference Microsoft Speech Object Library
    'run this to make a wav file from a text input
    '#INCLUDE StringToWavFile
    Dim sP As String, sFN As String, sStr As String, sFP As String
    'set parameter values - insert your own profile name first
    'paths
    sP = Environ("USERPROFILE") & "\Desktop\"        'for example
    sFN = "Mytest.wav"        'overwrites if file name same
    sFP = sP & sFN
    'string to use for the recording
    sStr = "This is a short test string to be spoken in a user's wave file."
    'make voice wav file from string
    StringToWavFile sStr, sFP
End Sub

Function StringToWavFile(sIn As String, sPath As String) As Boolean
    'needs reference Microsoft Speech Object Library
    'makes a spoken wav file from parameter text string
    'sPath parameter needs full path and file name to new wav file
    'If wave file does not initially exist it will be made
    'If wave file does initially exist it will be overwritten
    Dim fs As New SpFileStream
    Dim Voice As New SpVoice
    Dim audioType As Long
    'set the audio format
    fs.Format.Type = SAFT22kHz16BitMono
    'create wav file for writing without events
    fs.Open sPath, SSFMCreateForWrite, False
    'Set wav file stream as output for Voice object
    Set Voice.AudioOutputStream = fs
    'send output to default wav file "SimpTTS.wav" and wait till done
    Voice.Speak sIn, SVSFDefault
    'Close file
    fs.Close
    'wait
    Voice.WaitUntilDone (6000)
    'release object variables
    Set fs = Nothing
    Set Voice.AudioOutputStream = Nothing
    'transfers
    StringToWavFile = True
End Function



'uMemoryKnots	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uMemoryKnots
'* Created    : 06-10-2022 10:38
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


'Public WithEvents WorksheetSelectionChangeCheck As Excel.Worksheet

Dim memoPath As String
Dim FolderToZip As String
Dim MemoryKnotsWB As Workbook
Dim MemoryKnotsWS As Worksheet
Dim cell As Range
Dim i As Long
Dim str As String
Dim strTMP As String
Dim tmpWS As Worksheet
Dim KeepLoading As Boolean
Dim RestoreTo As Worksheet

Private Sub AddBook_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    str = InputBox("New NoteBook name")
    If str = "" Then Exit Sub
    Set MemoryKnotsWS = MemoryKnotsWB.SHEETS.Add(After:=MemoryKnotsWB.SHEETS(MemoryKnotsWB.SHEETS.count))
    noteBOOKS.AddItem ("o" & UCase(str))
    With MemoryKnotsWS
        .Name = "o" & UCase(str)
        .[A1] = "DATE"
        .[B1] = "NOTES"
        .[A1:B1].Font.Bold = True
        '        .Visible = xlSheetHidden
    End With
End Sub

Sub AddNotes()
    '    noteLIST.ListIndex = -1
    Call ListboxClearSelection(noteLIST)
    noteBOX.TEXT = ""
    Me.Width = 400
    noteBOX.SetFocus
End Sub

Private Sub AddNote_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call AddNotes
End Sub

Private Sub Clear_FilterNoteBooks_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    On Error Resume Next
    Dim tmpl As String
    tmpl = noteBOOKS.list(noteBOOKS.ListIndex)
    FilterNoteBooks.TEXT = ""
    For i = 0 To noteBOOKS.ListCount - 1
        If noteBOOKS.list(i) = tmpl Then
            noteBOOKS.SELECTED(i) = True
        End If
    Next i
End Sub

Private Sub Clear_FilterNoteList_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    FilterNoteList.TEXT = ""
    noteLIST.SetFocus

    '    For i = 0 To noteLIST.ListCount - 1
    '        If noteLIST.List(i) = tmpl Then
    '            noteLIST.Selected(i) = True
    '        End If
    '    Next i
End Sub

Private Sub CloseNoteBook_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If noteBOOKS.ListIndex < 0 Then
        MsgBox "No selection"
        Exit Sub
    End If
    
    MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).visible = False
    If Not tmpWS Is Nothing Then
        tmpWS.Activate
    End If
End Sub

Private Sub cmdCopyAll_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If

    Dim msg As String
    Dim i As Long, j As Long
    With noteLIST
        For i = 0 To .ListCount - 1
            msg = msg & .list(i) & vbCrLf
        Next i
    End With
    msg = left(msg, Len(msg) - 2)
    Call CLIP(msg)
    MsgBox "Selection copied"

End Sub

Private Sub cmdCopyAllLinked_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If
   
    If Listbox_Selected(noteLIST, 1) < 2 Then
        MsgBox "What's the sound of one hand clapping?" & Chr(10) & Chr(10) & _
                                                                            Space(50) & "~Fortune Cookie"
        Exit Sub
    End If
   
    Dim link As String
    link = InputBox("Choose link")
    If link = "" Then
        MsgBox "No input"
        Exit Sub
    End If
    
    Dim msg As String
    Dim i As Long, j As Long
    With noteLIST
        For i = 0 To .ListCount - 1
            msg = msg & .list(i) & link
        Next i
    End With
    msg = left(msg, Len(msg) - 1)
    Call CLIP(msg)
End Sub

Private Sub cmdCopySelected_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If

    Dim answer As Long
    answer = MsgBox("(YES) link with line break" & Chr(10) & _
                    "(NO) link with your choice", vbYesNoCancel)

    If answer = vbCancel Then Exit Sub

    Dim msg As String
    Dim i As Long, j As Long
    With noteLIST
        For i = 0 To .ListCount - 1
            If .SELECTED(i) Then
                If answer = vbYes Then
                    msg = msg & .list(i) & vbCrLf
                Else
                    msg = msg & .list(i) & link
                End If
            End If
        Next i
    End With
    
    If answer = vbYes Then
        msg = left(msg, Len(msg) - 2)
    Else
        msg = left(msg, Len(msg) - 1)
    End If
    
    Call CLIP(msg)
    MsgBox "Selection copied"
End Sub

Private Sub cmdExport_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call ExportNotes
End Sub

Private Sub cmdExportAsImage_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call ExportAsImage
End Sub

Private Sub cmdExportAsImageMini_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call ExportAsImage
End Sub

Sub ExportAsImage()
    If Not TypeName(Selection) = "Range" Then Exit Sub

    Dim JPGfolder As String
    JPGfolder = memoPath        '& "JPG"
    'On Error Resume Next
    'MkDir JPGfolder
    'On Error GoTo 0

    Dim action As Long

    'If Selection.Areas.count > 1 Then
    action = MsgBox("(YES) = for each area in selection" & Chr(10) & _
                    "(NO) = for each cell in selection", vbYesNoCancel)
    If action = vbCancel Then Exit Sub
    'Else
    '    action = vbNo
    'End If

    On Error Resume Next        'goto 0
    Application.DisplayAlerts = False

    Dim JPGcell As Range
    Dim result As String
    Dim ImageExtension As String
    ImageExtension = InputBox("Choose extension" & Chr(10) & _
                              "(1) = jpg" & Chr(10) & _
                              "(2) = bmp" & Chr(10) & _
                              "(3) = gib" & Chr(10) & _
                              "(4) = ico" & Chr(10) & _
                              "(5) = cur" & Chr(10) & _
                              "(6) = wmf", Default:=2)
    If Not IsNumeric(ImageExtension) Or ImageExtension < 1 Or ImageExtension > 6 Then
        Exit Sub
    End If

    Select Case ImageExtension
        Case Is = 1
            ImageExtension = "jpg"
        Case Is = 2
            ImageExtension = "bmp"
        Case Is = 3
            ImageExtension = "gib"
        Case Is = 4
            ImageExtension = "ico"
        Case Is = 5
            ImageExtension = "cur"
        Case Is = 6
            ImageExtension = "wmf"
    End Select


    Select Case action

        Case Is = vbNo
            For Each JPGcell In Selection
                Call ExportRangeAsImage(ActiveSheet, JPGcell, JPGfolder, JPGcell.Value, ImageExtension)
                Application.Wait (Now + TimeValue("0:00:01"))

                Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
                Set cell = MemoryKnotsWS.Cells(rows.count, 1).End(xlUp).OFFSET(1, 0)
                cell = Now()
                cell.OFFSET(0, 1) = JPGcell.Value & "." & ImageExtension
                noteLIST.AddItem JPGcell.Value & "." & ImageExtension

            Next JPGcell

        Case Is = vbYes

            For i = 1 To Selection.Areas.count
                result = ""
                result = InputBox("name for image of area: " & Selection.Areas(i).Address)

                Call ExportRangeAsImage(ActiveSheet, Selection.Areas(i), JPGfolder, result, ImageExtension)
                Application.Wait (Now + TimeValue("0:00:01"))

                Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
                Set cell = MemoryKnotsWS.Cells(rows.count, 1).End(xlUp).OFFSET(1, 0)
                cell = Now()
                cell.OFFSET(0, 1) = result & "." & ImageExtension
                noteLIST.AddItem result & "." & ImageExtension
    
            Next i

    End Select

    Application.DisplayAlerts = True
End Sub

Private Sub cmdImport_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call ImportNotes
End Sub

Private Sub cmdInsertComment_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If

    If Selection.Cells.count > 1 Then
        MsgBox ("choose 1 cell to insert comment")
        Exit Sub
    End If

    Dim answer As Long

    answer = MsgBox("(YES) link with line break" & Chr(10) & _
                    "(NO) link with your choice", vbYesNoCancel)

    If answer = vbCancel Then Exit Sub

    If answer = vbNo Then
        Dim link As String
        link = InputBox("Choose link")
    End If
    
    Dim msg As String
    With noteLIST
        For i = 0 To .ListCount - 1
            If .SELECTED(i) Then
                If answer = vbYes Then
                    msg = msg & .list(i) & vbCrLf
                Else
                    msg = msg & .list(i) & link
                End If
            End If
        Next i
    End With
    
    If answer = vbYes Then
        msg = left(msg, Len(msg) - 2)
    Else
        msg = left(msg, Len(msg) - 1)
    End If
    
    Dim action As Long
    If ActiveCell.Comment Is Nothing Then
        ActiveCell.AddComment Format(Now(), "yymmdd hhmm") & " " & msg
    Else
        action = MsgBox("(YES) pretend comment" & Chr(10) & _
                        "(NO) replace comment", vbYesNoCancel)
        If action = vbCancel Then Exit Sub
        If action = vbYes Then
            msg = Format(Now(), "yy/mm/dd hh:mm") & Chr(10) & Chr(10) & msg & Chr(10) & Chr(10) & ActiveCell.Comment.TEXT
            ActiveCell.Comment.Delete
            ActiveCell.AddComment msg
        Else
            ActiveCell.Comment.Delete
            ActiveCell.AddComment Format(Now(), "yy/mm/dd hh:mm") & Chr(10) & Chr(10) & msg
        End If
    End If
    ActiveCell.Comment.Shape.TextFrame.AutoSize = True
    
    '    Cells(ActiveCell.Row + 1, ActiveCell.Column).Activate

End Sub

Private Sub cmdInsertSelectedToCells_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Not TypeName(Selection) = "Range" Then Exit Sub
    
    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If


    Dim j As Long

    Dim answer As Long
    answer = MsgBox("(YES) insert vertically" & Chr(10) & _
                    "(NO) insert horizontally", vbYesNoCancel)

    If answer = vbCancel Then Exit Sub

    Dim result As Long

    If answer = vbYes Then
        If Selection.Cells.count = 1 Then
            j = 0
            With noteLIST
                For i = 0 To .ListCount - 1
                    If .SELECTED(i) Then
                        Cells(ActiveCell.row + j, ActiveCell.Column).Value = .list(i)
                        j = j + 1
                    End If
                Next i
            End With
        Else
            result = MsgBox("You've selected " & Selection.Cells.count & " cells." & Chr(10) & Chr(10) & _
                            "Proceed to insert selected items vertically for each cell?", vbYesNo)
            If result = vbNo Then Exit Sub
            If result = vbYes Then
                For Each cell In Selection.Cells
                    j = 0
                    With noteLIST
                        For i = 0 To .ListCount - 1
                            If .SELECTED(i) Then
                                Cells(cell.row + j, cell.Column).Value = .list(i)
                                j = j + 1
                            End If
                        Next i
                    End With
                Next cell
            End If
    
        End If
    Else
        If Selection.Cells.count = 1 Then
            j = 0
            With noteLIST
                For i = 0 To .ListCount - 1
                    If .SELECTED(i) Then
                        Cells(ActiveCell.row, ActiveCell.Column + j).Value = .list(i)
                        j = j + 1
                    End If
                Next i
            End With
        Else
            result = MsgBox("You've selected " & Selection.Cells.count & " cells." & Chr(10) & Chr(10) & _
                            "Proceed to insert selected items vertically for each cell?", vbYesNo)
            If result = vbYes Then
                For Each cell In Selection.Cells
                    j = 0
                    With noteLIST
                        For i = 0 To .ListCount - 1
                            If .SELECTED(i) Then
                                Cells(cell.row, cell.Column + j).Value = .list(i)
                                j = j + 1
                            End If
                        Next i
                    End With
                Next cell
            End If
        End If
    End If
End Sub

Private Sub cmdInsertSelectedMerged_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If TypeName(Selection) <> "Range" Then Exit Sub
    
    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If

    Dim answer As Long
    answer = MsgBox("(YES) link with line break" & Chr(10) & _
                    "(NO) link with your choice", vbYesNoCancel)

    If answer = vbCancel Then Exit Sub

    If answer = vbNo Then
        Dim link As String
        link = InputBox("Choose link")
    End If
    
    Dim msg As String
    With noteLIST
        For i = 0 To .ListCount - 1
            If .SELECTED(i) Then
                If answer = vbYes Then
                    msg = msg & .list(i) & vbCrLf
                Else
                    msg = msg & .list(i) & link
                End If
            End If
        Next i
    End With
    
    If answer = vbYes Then
        ActiveCell.Value = left(msg, Len(msg) - 2)
    Else
        ActiveCell.Value = left(msg, Len(msg) - 1)
    End If
    '    Cells(ActiveCell.Row + 1, ActiveCell.Column).Activate

End Sub

Private Sub cmdMail_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If
    
    Dim WshShell As Object
    Set WshShell = CreateObject("WScript.Shell")
    '   Dim FolderToZip As String
    FolderToZip = WshShell.SpecialFolders("MyDocuments")
    FolderToZip = FolderToZip & "\FolderToZip\"
    
    Call FoldersCreate("FolderToZip")
    
    Dim AttachPath As String
    AttachPath = MailAttachments
    
    On Error Resume Next
    Kill memoPath & "zipNotes.zip"
    On Error GoTo 0
    
    Dim msg As String
    With noteLIST
        For i = 0 To .ListCount - 1
            If .SELECTED(i) Then
                msg = msg & .list(i) & vbCrLf
            End If
        Next i
    End With
    
    If OutlookCheck = True Then
        'For Tips see: http://www.rondebruin.nl/win/winmail/Outlook/tips.htm
        'Working in Office 2000-2016

        Dim OutApp As Object
        Dim OutMail As Object

        Set OutApp = CreateObject("Outlook.Application")
        Set OutMail = OutApp.CreateItem(0)

        On Error Resume Next
        With OutMail
            .To = ""
            .CC = ""
            .BCC = ""
            .Subject = "MemoryKnots"
            .body = msg
            If AttachPath <> "" Then
                .Attachments.Add (MailAttachments)
            End If
            .Display
            '        .Send
        End With
        
        Set OutMail = Nothing
        Set OutApp = Nothing
    Else
        Call CLIP(msg)
        MsgBox "Outlook was not found" & Chr(10) & _
                                                 "Notes have been COPIED" & Chr(10) & _
                                                 "Please go to your mail and PASTE" & Chr(10) & _
                                                 "If you've included wav/image notes, they have been zipped at " & Chr(10) & _
                                                 memoPath & "zipNotes.zip"
    End If
    
    '   On Error GoTo 0
    On Error Resume Next
    Kill FolderToZip & "*.*"
    RmDir FolderToZip

End Sub

Function MailAttachments()
    Dim fso As Object
    Set fso = VBA.CreateObject("Scripting.FileSystemObject")

    Dim FileToCopy As String
    With noteLIST
        For i = 0 To .ListCount - 1
            If .SELECTED(i) = True Then
                If (Right(.list(i), 3) = "wav" _
                    Or Right(.list(i), 3) = "jpg" Or _
                    Right(.list(i), 3) = "bmp" Or _
                    Right(.list(i), 3) = "gib" Or _
                    Right(.list(i), 3) = "ico" Or _
                    Right(.list(i), 3) = "cur" Or _
                    Right(.list(i), 3) = "wmf") Then
                    FileToCopy = memoPath & .list(i)
                    fso.CopyFile FileToCopy, FolderToZip
                End If
            End If
        Next i
    End With

    If MailAttachmentsCount > 0 Then
        Call Zip(FolderToZip, memoPath & "zipNotes.zip")
        '        Call ZipFolder(FolderToZip, MemoPath & "wav.zip")
        MailAttachments = memoPath & "zipNotes.zip"
    Else
        MailAttachments = ""
    End If

End Function

Function MailAttachmentsCount()
    Dim Path As String, count As Integer

    Path = FolderToZip & "*.*"

    fileName = Dir(Path)

    Do While fileName <> ""
        count = count + 1
        fileName = Dir()
    Loop
    MailAttachmentsCount = count
End Function

Private Sub cmdMoveNote_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Listbox_Selected(noteLIST, 1) = 0 Then Exit Sub
    '    Set cell = MemoryKnotsWB.Sheets(noteBOOKS.List(noteBOOKS.ListIndex)).Columns("B:B").Find( _
    '        What:=noteLIST.List(noteLIST.ListIndex), _
    '        LookIn:=xlFormulas, _
    '        LookAt:=xlWhole, _
    '        SearchOrder:=xlByRows, _
    '        SearchDirection:=xlNext, _
    '        MatchCase:=False, _
    '        SearchFormat:=False)
    
    noteSELECT.clear
    For i = 0 To noteBOOKS.ListCount - 1
        noteSELECT.AddItem noteBOOKS.list(i)
    Next i
    noteSELECT.ListIndex = -1
    FrameSelect.Width = 84
    FrameSelect.ZOrder (0)
    FrameSelect.visible = True
      
End Sub

Private Sub cmdMoveOK_Click()

    'If noteSELECT.ListIndex <> -1 Then
    '    strTMP = noteSELECT.List(noteSELECT.ListIndex)
    '    cell.EntireRow.Copy MemoryKnotsWB.Sheets(strTMP).Range("A" & Rows.Count).End(xlUp).Offset(1, 0)
    '    cell.EntireRow.Delete
    '    noteBOX.Value = ""
    '    noteLIST.RemoveItem (noteLIST.ListIndex)
    '
    '    noteBOOKS.ListIndex = -1
    '    For i = 0 To noteBOOKS.ListCount - 1
    '        If noteBOOKS.List(i) = strTMP Then
    '            noteBOOKS.Selected(i) = True
    '        Exit For
    '        End If
    '    Next i
    '
    '    noteSELECT.Clear
    '    FrameSelect.Visible = False
    'Else
    '    strTMP = ""
    '    noteSELECT.Clear
    '    FrameSelect.Visible = False
    'End If

    If noteSELECT.ListIndex = -1 Then
        MsgBox "List empty or no item selected"
        noteSELECT.clear
        FrameSelect.visible = False
        Exit Sub
    Else

        Dim moveWhat As Variant
        moveWhat = Split(Listbox_Selected(noteLIST, 2), ",")
        Dim moveTo As String
        moveTo = noteSELECT.list(noteSELECT.ListIndex)
            
        For i = UBound(moveWhat) To LBound(moveWhat) Step -1
        
            Set cell = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).Columns("B:B").Find( _
        What:=noteLIST.list(moveWhat(i)), _
        LookIn:=xlFormulas, _
        LookAt:=xlWhole, _
        SearchOrder:=xlByRows, _
        SearchDirection:=xlNext, _
        MatchCase:=True, _
        SearchFormat:=False)
            
            cell.EntireRow.Copy MemoryKnotsWB.SHEETS(moveTo).Range("A" & rows.count).End(xlUp).OFFSET(1, 0)
            cell.EntireRow.Delete
    
        Next i
        noteSELECT.clear
        FrameSelect.visible = False
        
    End If
            
    For i = UBound(moveWhat) To LBound(moveWhat) Step -1
        noteLIST.RemoveItem (i)
    Next i
        
    If ToggleExtra.Value = False Then
        FrameExtra.Width = 5
        FrameExtra.visible = False
    End If
End Sub

Private Sub cmdMoveX_Click()
    '    strTMP = ""
    noteSELECT.clear
    FrameSelect.visible = False
End Sub

Private Sub cmdNewNoteFromSelection_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call ListboxClearSelection(noteLIST)
    noteBOX.TEXT = SelectionValues(Chr(10))
    Me.Width = 400
    noteBOX.SetFocus
End Sub

Private Sub cmdNewNoteFromSelectionMini_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call ListboxClearSelection(noteLIST)
    noteBOXmini.TEXT = SelectionValues(Chr(10))
    noteBOXmini.SetFocus
End Sub

Private Sub cmdNewNotesFromSelection_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim i As Long
    Dim varr As Variant
    varr = Split(SelectionValues("``"), "``")
    Call ListboxClearSelection(noteLIST)
    noteBOX.TEXT = ""
    For i = 0 To UBound(varr)
        noteBOX.TEXT = varr(i)
        Call NoteSave
    Next
End Sub

Private Sub cmdNewNotesFromSelectionMini_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim i As Long
    Dim varr As Variant
    varr = Split(SelectionValues("``"), "``")
    Call ListboxClearSelection(noteLIST)
    noteBOXmini.TEXT = ""
    For i = 0 To UBound(varr)
        noteBOXmini.TEXT = varr(i)
        Call NoteSaveMini
    Next
End Sub

Private Sub cmdPlayWAV_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If Listbox_Selected(noteLIST, 1) = 1 Then
        If Right(noteLIST.list(noteLIST.ListIndex), 3) = "wav" Then
            VoiceToWav.play memoPath & noteLIST.list(noteLIST.ListIndex)
        Else
            MsgBox "Not wav file, or file was manually deleted"
        End If
    End If
End Sub

Private Sub cmdSettingsNotebooks_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim result As String
    result = InputBox("Change noteBOOKS font size", Default:=Me.noteBOOKS.Font.Size)
    If result = "" Then Exit Sub
    If Not IsNumeric(result) Then
        MsgBox "Font size must be numeric"
        Exit Sub
    End If
    ThisWorkbook.SHEETS("MemoryKnots_Settings").Range("noteBooksFontSize").Value = result
    Me.noteBOOKS.Font.Size = result
End Sub

Private Sub cmdSettingsNotebox_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim result As String
    result = InputBox("Change noteLIST font size", Default:=Me.noteBOX.Font.Size)
    If result = "" Then Exit Sub
    If Not IsNumeric(result) Then
        MsgBox "Font size must be numeric"
        Exit Sub
    End If
    ThisWorkbook.SHEETS("MemoryKnots_Settings").Range("noteBoxFontSize").Value = result
    Me.noteBOX.Font.Size = result
End Sub

Private Sub cmdSettingsNotelist_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Dim result As String
    result = InputBox("Change noteLIST font size", Default:=Me.noteLIST.Font.Size)
    If result = "" Then Exit Sub
    If Not IsNumeric(result) Then
        MsgBox "Font size must be numeric"
        Exit Sub
    End If
    ThisWorkbook.SHEETS("MemoryKnots_Settings").Range("noteListFontSize").Value = result
    Me.noteLIST.Font.Size = result
End Sub

Private Sub cmdSpeechToWavStartRecording_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call VoiceNoteRecord
End Sub

Sub VoiceNoteRecord()
    VoiceToWav.StartRecord Bits16, Sampels32000, Mono
    cmdSpeechToWavStopRecording.visible = True
    cmdSpeechToWavStartRecording.visible = False
End Sub

Private Sub cmdSpeechToWavStartRecordingMini_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call VoiceNoteRecord
End Sub

Private Sub cmdSpeechToWavStopRecording_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call VoiceNoteSave
End Sub

Sub VoiceNoteSave()
    VoiceToWav.SaveRecord Environ("USERPROFILE") & "\Desktop\" & "tmp.wav"
    
    result = ""
    result = InputBox("Filename")
    If result = "" Then
        Exit Sub
    End If
    result = result & ".wav"
    
    Name Environ("USERPROFILE") & "\Desktop\" & "tmp.wav" As memoPath & result

    Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
    Set cell = MemoryKnotsWS.Cells(rows.count, 1).End(xlUp).OFFSET(1, 0)
    cell = Now()
    cell.OFFSET(0, 1) = result
    noteLIST.AddItem result

    cmdSpeechToWavStopRecording.visible = False
    cmdSpeechToWavStartRecording.visible = True

End Sub

Private Sub cmdSpeechToWavStopRecordingMini_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call VoiceNoteSave
End Sub

Private Sub cmdTextToWav_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call SaveTextToWav(1)
End Sub

Sub SaveTextToWav(NormalOrMini As Long)
    'run this to make a wav file from a text input
    Dim sP As String, sFN As String, sStr As String, sFP As String
    Dim result As String

    'set parameter values - insert your own profile name first
    'paths
    result = InputBox("Record title?" & Chr(10) & Chr(10) & "Overwrites if file name same")
    If result = "" Then
        Exit Sub
    End If
    sFN = result & ".wav"
    
    Select Case NormalOrMini
        Case Is = 1
            result = noteBOX.TEXT
        Case Is = 2
            result = noteBOXmini.TEXT
    End Select

    If result = "" Then
        '        Kill ThisWorkbook.Path & "\" & result
        Exit Sub
    End If
    'string to use for the recording
    sStr = result
    
    'make voice wav file from string
    '"My.wav" 'overwrites if file name same
    sP = memoPath
    sFP = sP & sFN
    StringToWavFile sStr, sFP
    
    Application.ScreenUpdating = False
    Dim tmpSheet As Worksheet
    Set tmpSheet = ActiveSheet
    Dim i As Integer
    Dim j As Variant
        
    Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
    Set cell = MemoryKnotsWS.Cells(rows.count, 1).End(xlUp).OFFSET(1, 0)
    cell = Now()
    cell.OFFSET(0, 1) = sFN
    noteLIST.AddItem sFN
    
    Call ListboxClearSelection(noteLIST)
    Select Case NormalOrMini
        Case Is = 1
            noteBOX.TEXT = ""
        Case Is = 2
            noteBOXmini.TEXT = ""
    End Select

End Sub

Private Sub cmdTextToWavMini_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call SaveTextToWav(2)
End Sub

Private Sub DeleteBook_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If noteBOOKS.ListIndex < 0 Then
        MsgBox "Notebooks list empty or none selected"
        Exit Sub
    End If
    If noteBOOKS.list(noteBOOKS.ListIndex) = "o NOTES" _
                                             Or noteBOOKS.list(noteBOOKS.ListIndex) = "o RESOLVED" Then
        Exit Sub
    End If
    Application.DisplayAlerts = False
    MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).Delete
    noteBOOKS.RemoveItem (noteBOOKS.ListIndex)
    Application.DisplayAlerts = True
End Sub

Private Sub DeleteNote_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '    If noteLIST.ListIndex < 0 Then
    '        MsgBox "Note list empty or none selected"
    '        Exit Sub
    '    End If
    '    Set cell = MemoryKnotsWB.Sheets(noteBOOKS.List(noteBOOKS.ListIndex)).Columns("B:B").Find( _
    '        What:=noteLIST.List(noteLIST.ListIndex), _
    '        LookIn:=xlFormulas, _
    '        LookAt:=xlWhole, _
    '        SearchOrder:=xlByRows, _
    '        SearchDirection:=xlNext, _
    '        MatchCase:=False, _
    '        SearchFormat:=False)
    '    cell.EntireRow.Delete
    '    noteBOX.Value = ""
    '    noteLIST.RemoveItem (noteLIST.ListIndex)

    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If

    'remove item
    Dim deleteWhat As Variant
    deleteWhat = Split(Listbox_Selected(noteLIST, 2), ",")
            
    'move backwards when deleting
    For i = UBound(deleteWhat) To LBound(deleteWhat) Step -1
    
        Set cell = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).Columns("B:B").Find( _
        What:=noteLIST.list(deleteWhat(i)), _
        LookIn:=xlFormulas, _
        LookAt:=xlWhole, _
        SearchOrder:=xlByRows, _
        SearchDirection:=xlNext, _
        MatchCase:=False, _
        SearchFormat:=False)
        
        cell.EntireRow.Delete
        On Error Resume Next
        With noteLIST
            If Right(.list(i), 3) = "wav" Or Right(.list(i), 3) = "jpg" Or Right(.list(i), 3) = "bmp" Or Right(.list(i), 3) = "gib" _
                                                                                                                              Or Right(.list(i), 3) = "ico" Or Right(.list(i), 3) = "cur" Or Right(.list(i), 3) = "wmf" Then
                Kill memoPath & noteLIST.list(deleteWhat(i))
            End If
        End With
        noteLIST.RemoveItem (deleteWhat(i))
    
    Next i
    
    noteBOX.TEXT = ""
    If ToggleExtra.Value = False Then
        FrameExtra.Width = 5
        FrameExtra.visible = False
    End If
    
    Me.Width = 174
End Sub

Private Sub DynamicImage_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call Shell("explorer.exe" & " " & memoPath & noteLIST.list(noteLIST.ListIndex), vbNormalFocus)
End Sub

Private Sub FilterNoteBooks_Change()
    On Error GoTo eh
    'Reload list so if you type and delete you'll get the items back
    Call LoadNoteBooks
    
    Dim i               As Long
    Dim n               As Long
    Dim str             As String
    Dim sTemp           As String
   
    'Equals is always case sensitive
    'Remove LCase if you want it to be case sensitive
    str = LCase(FilterNoteBooks.TEXT)
   
    n = noteBOOKS.ListCount
   
    For i = n - 1 To 0 Step -1        'Work backwards when deleting items
        'Equals is always case sensitive
        'Remove LCase if you want it to be case sensitive
        sTemp = LCase(noteBOOKS.list(i))
       
        If InStr(sTemp, str) = 0 Then
            noteBOOKS.RemoveItem (i)
            'Exit Sub   'Uncomment to Exit if value found
        End If
    Next i
    
    noteBOOKS.SELECTED(0) = True
    Exit Sub
eh:
End Sub

Private Sub FilterNoteList_Change()
    On Error GoTo eh
    'Reload list so if you type and delete you'll get the items back
    Call LoadNoteList
    
    Dim i               As Long
    Dim n               As Long
    Dim str             As String
    Dim sTemp           As String
   
    'Equals is always case sensitive
    'Remove LCase if you want it to be case sensitive
    str = LCase(FilterNoteList.TEXT)
   
    n = noteLIST.ListCount
   
    For i = n - 1 To 0 Step -1        'Work backwards when deleting items
        'Equals is always case sensitive
        'Remove LCase if you want it to be case sensitive
        sTemp = LCase(noteLIST.list(i))
       
        If InStr(sTemp, str) = 0 Then
            noteLIST.RemoveItem (i)
            'Exit Sub   'Uncomment to Exit if value found
        End If
    Next i
    
    noteLIST.SELECTED(0) = True
    Exit Sub
eh:
End Sub

Private Sub cmdResolved_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)

    If noteBOOKS.list(noteBOOKS.ListIndex) = "o RESOLVED" Then Exit Sub

    If Listbox_Selected(noteLIST, 1) = 0 Or noteLIST.ListCount = 0 Then
        MsgBox "List empty or no item selected"
        Exit Sub
    End If

    Dim resolveWhat As Variant
    resolveWhat = Split(Listbox_Selected(noteLIST, 2), ",")
            
    For i = LBound(resolveWhat) To UBound(resolveWhat)
    
        Set cell = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).Columns("B:B").Find( _
        What:=noteLIST.list(resolveWhat(i)), _
        LookIn:=xlFormulas, _
        LookAt:=xlWhole, _
        SearchOrder:=xlByRows, _
        SearchDirection:=xlNext, _
        MatchCase:=False, _
        SearchFormat:=False)
            
        cell.EntireRow.Copy MemoryKnotsWB.SHEETS("o RESOLVED").Range("A" & rows.count).End(xlUp).OFFSET(1, 0)
        cell.EntireRow.Delete
    
    Next i
    For i = UBound(resolveWhat) To LBound(resolveWhat) Step -1
        noteLIST.RemoveItem resolveWhat(i)
    Next i
    
    noteBOX.Value = ""
    
    If ToggleExtra.Value = False Then
        FrameExtra.Width = 5
        FrameExtra.visible = False
    End If
    
End Sub

Private Sub info_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub noteBOOKS_Change()
    On Error GoTo eh
    Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
    noteLIST.clear
    Call LoadNoteList
eh:
End Sub

Private Sub noteBOOKS_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If noteBOOKS.ListIndex = -1 Then Exit Sub
    If noteBOOKS.list(noteBOOKS.ListIndex) = "o NOTES" Or _
                                             noteBOOKS.list(noteBOOKS.ListIndex) = "o RESOLVED" Then
        MsgBox "Can't touch this" & Chr(10) & _
                                            "          ~mc Hammer"
        Exit Sub
    End If

    Dim result As String
    result = InputBox("New NoteBook name")
    If result = "" Then Exit Sub
    If WorksheetExists("o" & UCase(result)) Then
        MsgBox "Name taken"
        Exit Sub
    End If
    Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
    
    With MemoryKnotsWS
        .Name = "o" & UCase(result)
    End With
    
    noteBOOKS.list(noteBOOKS.ListIndex) = "o" & UCase(result)
    Set MemoryKnotsWS = Nothing
End Sub

Private Sub noteBOX_Exit(ByVal Cancel As MSForms.ReturnBoolean)
    Me.Width = 174
End Sub

Private Sub noteLIST_Change()
    DynamicImage.visible = False

    If Listbox_Selected(noteLIST, 1) <= 1 Then        'noteLIST.ListCount > 0 And noteLIST.ListIndex >= 0 And
        noteBOX.TEXT = noteLIST.list(noteLIST.ListIndex)
        If ToggleExtra.Value = False Then
            FrameExtra.Width = 5
            FrameExtra.visible = False
        End If
    Else
        noteBOX.TEXT = ""
        FrameExtra.Width = 23
        FrameExtra.ZOrder (0)
        FrameExtra.visible = True
    End If
      
    If Listbox_Selected(noteLIST, 1) = 1 Then
        If Right(noteLIST.list(Listbox_Selected(noteLIST, 2)), 3) = "wav" Then
            cmdPlayWAV.visible = True
            cmdPlayWAV.ZOrder (0)
            DynamicImage.visible = False
            Me.Width = 174
        ElseIf Right(noteLIST.list(noteLIST.ListIndex), 3) = "jpg" Or _
                                                             Right(noteLIST.list(noteLIST.ListIndex), 3) = "bmp" Or _
                                                             Right(noteLIST.list(noteLIST.ListIndex), 3) = "gib" Or _
                                                             Right(noteLIST.list(noteLIST.ListIndex), 3) = "ico" Or _
                                                             Right(noteLIST.list(noteLIST.ListIndex), 3) = "cur" Or _
                                                             Right(noteLIST.list(noteLIST.ListIndex), 3) = "wmf" Then
            cmdPlayWAV.visible = False
            DynamicImage.visible = True
            '                On Error Resume Next
            '                DynamicImage.Picture = LoadPicture(MemoPath & noteLIST.List(noteLIST.ListIndex))
            '                DynamicImage.ZOrder (0)
            '                Me.Width = 400
        Else
            cmdPlayWAV.visible = False
            DynamicImage.visible = False

        End If
    Else
        cmdPlayWAV.visible = False
        DynamicImage.visible = False
        Me.Width = 174
    End If
End Sub

Private Sub noteLIST_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    If noteLIST.ListCount = 0 Then Exit Sub
    If Right(noteLIST.list(noteLIST.ListIndex), 3) = "wav" Then
        str = InputBox("Rename WAV file" & Chr(10) & Chr(10) & "Will replace file with same name.")
        If str = "" Then
            Exit Sub
        Else
            On Error Resume Next
            Name memoPath & noteLIST.list(noteLIST.ListIndex) As _
                                                              memoPath & str & ".wav"
        
            Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
            Set cell = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).Columns("B:B").Find( _
        What:=noteLIST.list(noteLIST.ListIndex), _
        LookIn:=xlFormulas, _
        LookAt:=xlWhole, _
        SearchOrder:=xlByRows, _
        SearchDirection:=xlNext, _
        MatchCase:=False, _
        SearchFormat:=False)
        
            cell.OFFSET(0, -1) = Now()
            cell = str & ".wav"
        
            noteLIST.list(noteLIST.ListIndex) = str & ".wav"
            
        End If
    ElseIf Right(noteLIST.list(noteLIST.ListIndex), 3) = "jpg" Or Right(noteLIST.list(noteLIST.ListIndex), 3) = "bmp" Or Right(noteLIST.list(noteLIST.ListIndex), 3) = "gib" _
                                                                                                                                                                       Or Right(noteLIST.list(noteLIST.ListIndex), 3) = "ico" Or Right(noteLIST.list(noteLIST.ListIndex), 3) = "cur" Or Right(noteLIST.list(noteLIST.ListIndex), 3) = "wmf" Then

        str = InputBox("Rename file" & Chr(10) & Chr(10) & "Will replace file with same name.")
        If str = "" Then
            Exit Sub
        Else
            On Error Resume Next
            Name memoPath & noteLIST.list(noteLIST.ListIndex) As _
                                                              memoPath & str & Right(noteLIST.list(noteLIST.ListIndex), 3)
        
            Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
            Set cell = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).Columns("B:B").Find( _
        What:=noteLIST.list(noteLIST.ListIndex), _
        LookIn:=xlFormulas, _
        LookAt:=xlWhole, _
        SearchOrder:=xlByRows, _
        SearchDirection:=xlNext, _
        MatchCase:=False, _
        SearchFormat:=False)
        
            cell.OFFSET(0, -1) = Now()
            cell = str & Right(noteLIST.list(noteLIST.ListIndex), 3)
        
            noteLIST.list(noteLIST.ListIndex) = str & Right(noteLIST.list(noteLIST.ListIndex), 3)
            noteBOX.TEXT = str & Right(noteLIST.list(noteLIST.ListIndex), 3)
        End If
    Else
        Me.Width = 400
        noteBOX.SetFocus
    End If
End Sub

Private Sub OpenNoteBook_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    If noteBOOKS.ListIndex < 0 Then
        MsgBox "No selection"
        Exit Sub
    End If

    Set tmpWS = ActiveSheet
    With MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
        .visible = True
        .Activate
    End With

End Sub

Private Sub OpenBakupFolder_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call Shell("explorer.exe" & " " & memoPath, vbNormalFocus)
End Sub

Private Sub cmdNoteSave_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call NoteSave
End Sub

Sub NoteSave()
    If noteBOX.TEXT = "" Then
        MsgBox "Write a note first"
        Exit Sub
    End If

    Dim msg As String
    '    If ToggleRangeNote.Value = True And Selection.Cells.count = 1 Then
    '        msg = ActiveCell.Address(False, False) & " " & noteBOX.Text
    '    Else
    msg = noteBOX.TEXT
    '    End If
    
    Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
    
    If Listbox_Selected(noteLIST, 1) = 0 Then
        Set cell = MemoryKnotsWS.Cells(rows.count, 1).End(xlUp).OFFSET(1, 0)
        cell = Now()
        cell.OFFSET(0, 1) = msg
        noteLIST.AddItem (msg)
    Else
        Set cell = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).Columns("B:B").Find( _
        What:=noteLIST.list(noteLIST.ListIndex), _
        LookIn:=xlFormulas, _
        LookAt:=xlWhole, _
        SearchOrder:=xlByRows, _
        SearchDirection:=xlNext, _
        MatchCase:=False, _
        SearchFormat:=False)
        
        cell.OFFSET(0, -1) = Now()
        cell = msg
        
        noteLIST.list(noteLIST.ListIndex) = msg
    End If
    
    Call ListboxClearSelection(noteLIST)
    noteBOX.TEXT = ""
End Sub

Private Sub cmdNoteSaveMini_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    Call NoteSaveMini
End Sub

Sub NoteSaveMini()
    If noteBOXmini.TEXT = "" Then
        MsgBox "Write a note first"
        Exit Sub
    End If

    Dim msg As String
    '    If ToggleRangeNote.Value = True And Selection.Cells.count = 1 Then
    '        msg = ActiveCell.Address(False, False) & " " & noteBOXmini.Text
    '    Else
    msg = noteBOXmini.TEXT
    '    End If
    
    Set MemoryKnotsWS = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex))
    
    If Listbox_Selected(noteLIST, 1) = 0 Then
        Set cell = MemoryKnotsWS.Cells(rows.count, 1).End(xlUp).OFFSET(1, 0)
        cell = Now()
        cell.OFFSET(0, 1) = msg
        noteLIST.AddItem (msg)
    Else
        Set cell = MemoryKnotsWB.SHEETS(noteBOOKS.list(noteBOOKS.ListIndex)).Columns("B:B").Find( _
        What:=noteLIST.list(noteLIST.ListIndex), _
        LookIn:=xlFormulas, _
        LookAt:=xlWhole, _
        SearchOrder:=xlByRows, _
        SearchDirection:=xlNext, _
        MatchCase:=False, _
        SearchFormat:=False)
        
        cell.OFFSET(0, -1) = Now()
        cell = msg
        
        noteLIST.list(noteLIST.ListIndex) = msg
    End If
    
    noteBOXmini.TEXT = ""
End Sub

Private Sub cmdSortNoteBooksAZ_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    On Error Resume Next
    Dim tmpl As String
    tmpl = noteBOOKS.list(noteBOOKS.ListIndex)
    Call ListboxSortAZ(noteBOOKS)
    For i = 0 To noteBOOKS.ListCount - 1
        If noteBOOKS.list(i) = tmpl Then
            noteBOOKS.SELECTED(i) = True
        End If
    Next i

End Sub

Private Sub cmdSortNoteBooksZA_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    On Error Resume Next
    Dim tmpl As String
    tmpl = noteBOOKS.list(noteBOOKS.ListIndex)
    Call ListboxSortZA(noteBOOKS)
    '    Call ListboxClearSelection(notebOoks)
    For i = 0 To noteBOOKS.ListCount - 1
        If noteBOOKS.list(i) = tmpl Then
            noteBOOKS.SELECTED(i) = True
        End If
    Next i
End Sub

Private Sub cmdSortNoteListAZ_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    On Error Resume Next
    '    Dim tmpl As String
    '    tmpl = noteLIST.List(noteLIST.ListIndex)
    Call ListboxSortAZ(noteLIST)
    Call ListboxClearSelection(noteLIST)
    '    For i = 0 To noteLIST.ListCount - 1
    '        If noteLIST.List(i) = tmpl Then
    '            noteLIST.Selected(i) = True
    '        End If
    '    Next i
End Sub

Private Sub cmdSortNoteListZA_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    On Error Resume Next
    '    Dim tmpl As String
    '    tmpl = noteLIST.List(noteLIST.ListIndex)
    Call ListboxSortZA(noteLIST)
    Call ListboxClearSelection(noteLIST)
    '    For i = 0 To noteLIST.ListCount - 1
    '        If noteLIST.List(i) = tmpl Then
    '            noteLIST.Selected(i) = True
    '        End If
    '    Next i
End Sub

Private Sub Toggle_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    'If notbooks.ListIndex = -1 Then
    '    noteBOOKS.Selected(0) = True
    'End If
    Call ListboxClearSelection(noteLIST)
    If Me.Height > 100 Then
        Me.Height = 64        '50
        Me.Width = 174
        Me.Caption = noteBOOKS.list(noteBOOKS.ListIndex)
        cmdNoteSaveMini.visible = True
        noteBOXmini.visible = True
        cmdSpeechToWavStartRecordingMini.visible = True
        cmdSpeechToWavStopRecordingMini.visible = True
        cmdTextToWavMini.visible = True
        cmdNewNoteFromSelectionMini.visible = True
        cmdNewNotesFromSelectionMini.visible = True
        cmdExportAsImageMini.visible = True
        noteBOXmini.SetFocus
    Else
        Me.Height = 336
        'Me.Width = 174
        Me.Caption = "Notebooks"
        cmdNoteSaveMini.visible = False
        noteBOXmini.visible = False
        cmdSpeechToWavStartRecordingMini.visible = False
        cmdSpeechToWavStopRecordingMini.visible = False
        cmdTextToWavMini.visible = False
        cmdNewNoteFromSelectionMini.visible = False
        cmdNewNotesFromSelectionMini.visible = False
        cmdExportAsImageMini.visible = False
        noteBOOKS.SetFocus
    End If
End Sub

Private Sub ToggleExtra_Click()
    If ToggleExtra.Value = True Then
        FrameExtra.Width = 23
        FrameExtra.ZOrder (0)
        FrameExtra.visible = True
    Else
        FrameExtra.Width = 5
        FrameExtra.visible = False
    End If
End Sub

Private Sub UserForm_Initialize()
    '/load position
    If GetSetting("My Settings Folder", Me.Name, "Left Position") = "" _
                                                                    And GetSetting("My Settings Folder", Me.Name, "Top Position") = "" Then
        Me.StartUpPosition = 1        ' CenterOwner
    Else
        Me.left = GetSetting("My Settings Folder", Me.Name, "Left Position")
        Me.top = GetSetting("My Settings Folder", Me.Name, "Top Position")
    End If
    'load position/

    Me.Width = 174
    Me.noteBOOKS.Font.Size = ThisWorkbook.SHEETS("MemoryKnots_Settings").Range("noteBooksFontSize").Value
    Me.noteLIST.Font.Size = ThisWorkbook.SHEETS("MemoryKnots_Settings").Range("noteListFontSize").Value
    Me.noteBOX.Font.Size = ThisWorkbook.SHEETS("MemoryKnots_Settings").Range("noteBoxFontSize").Value
    Me.noteBOXmini.Font.Size = 8        'ThisWorkbook.Sheets("MemoryKnots_Settings").Range("noteBoxFontSize").Value
    

    Set MemoryKnotsWB = Workbooks(ThisWorkbook.Name)

    '    Set MemoryKnotsWS = MemoryKnotsWB.Sheets(1)
        
    Call LoadNoteBooks

    noteBOOKS.SELECTED(0) = True

    Set WorksheetSelectionChangeCheck = ActiveSheet
    
    memoPath = Environ$("USERPROFILE") & "\My Documents\vbArc\MemoryKnots\"
    FoldersCreate memoPath
End Sub

'Sub WorksheetSelectionChangeCheck_SelectionChange(ByVal Target As Range)
'    If ToggleRangeNote.Value = False Then Exit Sub
'    FilterNoteBooks.Text = ""
'    FilterNoteList.Text = ""
'
'    Dim noteLISTvalues As String
'
'    For i = 0 To noteBOOKS.ListCount - 1
'        noteLISTvalues = noteLISTvalues & " " & noteBOOKS.List(i)
'        Debug.Print noteLISTvalues
'    Next i
'
'    If InStr(LCase(noteBOOKS.List(noteBOOKS.ListIndex)), LCase(ActiveSheet.Name)) > 0 _
'    And Selection.Cells.count = 1 Then
'    For i = 0 To noteLIST.ListCount - 1
'        noteLISTvalues = noteLISTvalues & " " & noteLIST.List(i)
'        Debug.Print noteLISTvalues
'    Next i
'    If InStr(noteLISTvalues, ActiveCell.Address(False, False)) > 0 Then
'        FilterNoteList.Text = ActiveCell.Address(False, False)
'    Else
'        FilterNoteList.Text = ""
'    End If
'End If
'End Sub

'Sub ListboxValues(LBox As MSForms.ListBox)
'
'End Sub
'
'Sub CheckUpdate()
'    On Error GoTo eh
'    If UCase(noteLIST.List(0)) = "UPDATE" Then
'        Call ImportNotes
'    End If
'eh:
'End Sub

Private Sub LoadNoteList()
    noteLIST.clear
    Dim i As Long
    For i = 2 To MemoryKnotsWS.Cells(rows.count, 1).End(xlUp).row
        noteLIST.AddItem MemoryKnotsWS.Cells(i, 2)
    Next
End Sub

Private Sub LoadNoteBooks()
    noteBOOKS.clear
    For i = 1 To MemoryKnotsWB.SHEETS.count
        If MemoryKnotsWB.SHEETS(i).Name Like "o *" Then
            noteBOOKS.AddItem MemoryKnotsWB.SHEETS(i).Name
        End If
    Next
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    '/save position
    'must have uf position set to manual
    SaveSetting "My Settings Folder", Me.Name, "Left Position", Me.left
    SaveSetting "My Settings Folder", Me.Name, "Top Position", Me.top


End Sub



'Sheet15	100



'Sheet16	100



'Sheet17	100



'uAddinManager	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uAddinManager
'* Created    : 06-10-2022 10:33
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub CommandButton1_Click()
    On Error Resume Next
    For i = 0 To body.ListCount - 1
        If body.SELECTED(i) = True Then
            If Not AddIns(body.list(i, 0)).IsOpen Then
                Workbooks.Open (AddIns(body.list(i, 0)).FullName)
                AddIns(body.list(i, 0)).Installed = True
            Else
                Workbooks(AddIns(body.list(i, 0)).Name).Close True
                AddIns(body.list(i, 0)).Installed = False
            End If
        End If
        '    If body.Selected(i) = True Then AddIns(body.List(i, 0)).Installed = Not AddIns(body.List(i, 0)).Installed
    Next
    LoadAddins
End Sub

Private Sub CommandButton2_Click()
    Dim ans As Long
    ans = MsgBox("Irreversible. Proceed?", vbYesNo)
    If ans = vbNo Then Exit Sub
    AddIns(body.list(body.ListIndex, 0)).Installed = False
    Kill AddIns(body.list(body.ListIndex, 0)).FullName
End Sub

Private Sub CommandButton3_Click()
    SortListboxOnColumn body, 0
End Sub

Private Sub CommandButton4_Click()
    SortListboxOnColumn body, 1
End Sub

Private Sub CommandButton5_Click()
    vbArcAddinsForm.Show
    Unload Me
End Sub

Private Sub info_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub Label1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    uUpdateFiles.Show
End Sub

Private Sub UserForm_Initialize()
    LoadAddins
End Sub

Sub LoadAddins()
    '#INCLUDE SortListboxOnColumn
    body.clear
    Dim ad As AddIn
    On Error Resume Next
    For Each ad In AddIns
        body.AddItem
        body.list(body.ListCount - 1, 0) = left(ad.Name, InStr(1, ad.Name, ".") - 1)
        body.list(body.ListCount - 1, 1) = IIf(ad.Installed, " ENABLED", "-")
    Next
    SortListboxOnColumn body, 1
End Sub

Sub SortListboxOnColumn(lBox As MSForms.ListBox, Optional OnColumn As Long = 0)
    Dim vntData As Variant
    Dim vntTempItem As Variant
    Dim lngOuterIndex As Long
    Dim lngInnerIndex As Long
    Dim lngSubItemIndex As Long
    vntData = lBox.list
    For lngOuterIndex = LBound(vntData, 1) To UBound(vntData, 1) - 1
        For lngInnerIndex = lngOuterIndex + 1 To UBound(vntData, 1)
            If vntData(lngOuterIndex, OnColumn) > vntData(lngInnerIndex, OnColumn) Then
                For lngSubItemIndex = 0 To lBox.columnCount - 1
                    vntTempItem = vntData(lngOuterIndex, lngSubItemIndex)
                    vntData(lngOuterIndex, lngSubItemIndex) = vntData(lngInnerIndex, lngSubItemIndex)
                    vntData(lngInnerIndex, lngSubItemIndex) = vntTempItem
                Next
            End If
        Next lngInnerIndex
    Next lngOuterIndex
    lBox.clear
    lBox.list = vntData
End Sub


'uAddinsSync	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uAddinsSync
'* Created    : 06-10-2022 10:34
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub CommandButton1_Click()
    UpdateFiles
End Sub

Private Sub CommandButton2_Click()
    Dim c As MSForms.control
    For Each c In Me.Controls
        If UCase(TypeName(c)) = UCase("CheckBox") Then
            c.Value = True
        End If
    Next
End Sub

Private Sub CommandButton3_Click()
    Dim c As MSForms.control
    For Each c In Me.Controls
        If UCase(TypeName(c)) = UCase("CheckBox") Then
            c.Value = False
        End If
    Next
End Sub

Private Sub UserForm_Activate()
    ResizeUserformToFitControls Me
End Sub

Private Sub UserForm_Initialize()
    AddinsModified
End Sub


'vbArcAddinsForm	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : vbArcAddinsForm
'* Created    : 06-10-2022 10:41
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Private Sub CommandButton1_Click()
    DownloadThis
End Sub

Private Sub CommandButton2_Click()
    
    For i = 0 To ListBox1.ListCount - 1
        If ListBox1.SELECTED(i) = True Then
            If ListBox1.list(i, 1) = "INSTALLED" Then
                AddinName = left(ListBox1.list(i, 0), InStrRev(ListBox1.list(i, 0), ".") - 1)
                AddIns(AddinName).Installed = Not AddIns(AddinName).Installed
                ListBox1.list(i, 2) = IIf(AddIns(AddinName).Installed = True, "ENABLED", "DISABLED")
            End If
        End If
    Next
    
End Sub

Private Sub info_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    uDEV.Show
End Sub

Private Sub UserForm_Initialize()
    Dim v As Variant
    v = vbArcAddins
    Dim i As Long
    On Error Resume Next
    For i = 0 To UBound(v)
        ListBox1.AddItem
        ListBox1.list(i, 0) = Replace(Mid(v(i), InStrRev(v(i), "/") + 1), vbLf, "")
        Debug.Print ListBox1.list(i, 0)
        ListBox1.list(i, 1) = IIf(FileExists(Application.UserLibraryPath & ListBox1.list(i, 0)) = False, "MISSING", "INSTALLED")
        
        AddinName = left(ListBox1.list(i, 0), InStrRev(ListBox1.list(i, 0), ".") - 1)
        Set ad = AddIns(AddinName)
        If Not ad Is Nothing Then
            ListBox1.list(i, 2) = IIf(AddIns(AddinName).Installed = True, "ENABLED", "DISABLED")
        End If
        On Error GoTo 0
        ListBox1.list(i, 3) = Replace(v(i), vbLf, "")
    Next
End Sub

Sub DownloadThis()
    '#INCLUDE DownloadFile
    Dim i As Long
    Dim AddinName As String
    Dim ad As AddIn
    
    For i = 0 To ListBox1.ListCount - 1
        If ListBox1.SELECTED(i) = True Then
            AddinName = left(ListBox1.list(i, 0), InStrRev(ListBox1.list(i, 0), ".") - 1)
            On Error Resume Next
            Set ad = AddIns(AddinName)
            If Not ad Is Nothing Then
                If AddIns(AddinName).Installed = True Then AddIns(fileName).Installed = False
            End If
            
            Kill Application.UserLibraryPath & ListBox1.list(i, 0)
            On Error GoTo 0
            DownloadFile ListBox1.list(i, 3), Application.UserLibraryPath & ListBox1.list(i, 0)
            AddIns.Add (Application.UserLibraryPath & ListBox1.list(i, 0))
            AddIns(AddinName).Installed = True
            ListBox1.list(i, 1) = "INSTALLED"
            ListBox1.list(i, 2) = "ENABLED"
        End If
    Next
    
End Sub


'U_Addins	1

Rem @Folder Addins Declarations
#If VBA7 Then
    Private Declare PtrSafe Function URLDownloadToFile Lib "urlmon" _
    Alias "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, _
    ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#Else
    Private Declare Function URLDownloadToFile Lib "urlmon" _
                             Alias "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, _
                                                         ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
#End If

Rem @Folder Addins
Sub AddinManagerButtonClicked(control As IRibbonControl)
    Select Case UCase(control.ID)
        Case UCase("buttonAddinManager")
            uAddinManager.Show
        Case UCase("AddinManagerToggle")
            ThisWorkbook.IsAddin = Not ThisWorkbook.IsAddin
    End Select
End Sub

Sub DownloadFile(FileUrl As String, SaveAs As String)
    URLDownloadToFile 0, FileUrl, SaveAs, 0, 0
End Sub

Function vbArcAddins() As Variant
    '#INCLUDE TXTReadFromUrl
    Dim v
    v = Filter(Split(TXTReadFromUrl("https://github.com/alexofrhodes/vbArc-addins/raw/main/ListOfAddins.txt"), "  " & vbLf), "xlam", True)
    Dim i As Long
    vbArcAddins = v
End Function

Sub DownloadFileFromURL(FileUrl, saveFullName)
    Dim objXmlHttpReq As Object
    Dim objStream As Object
    Set objXmlHttpReq = CreateObject("Microsoft.XMLHTTP")
    objXmlHttpReq.Open "GET", FileUrl, False, "username", "password"
    objXmlHttpReq.send
    If objXmlHttpReq.Status = 200 Then
        Set objStream = CreateObject("ADODB.Stream")
        objStream.Open
        objStream.Type = 1
        objStream.Write objXmlHttpReq.responseBody
        objStream.SaveToFile saveFullName, 2
        objStream.Close
    End If
End Sub

Public Function LastModified(filespec)
End Function

Sub AddinsModified()
    On Error Resume Next
    Application.CalculateFull
    On Error GoTo 0
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    Dim cell As Range
    Set cell = Sheet1.Range("E2")
    Dim ans As Long
    Dim counter As Long
    Dim ctr As MSForms.control
    Dim ReplaceWhat As String, ReplaceWith As String
    Dim spaceCounter As Long
    spaceCounter = ThisWorkbook.SHEETS("uAddins_Settings").Range("K1")
    spaceCounter = spaceCounter + 1
    Do While cell <> ""
        If cell.TEXT = "A" Then
            counter = counter + 1
            Set ctr = uUpdateFiles.Controls.Add("Forms.CheckBox.1")
            ctr.Caption = Sheet1.Range("A1") & vbTab & cell.OFFSET(0, -4) & vbTab & vbTab & cell.OFFSET(0, -2) & vbTab & vbTab & _
                                                                                                               Sheet1.Range("G1") & vbTab & vbTab & cell.OFFSET(0, 2) & vbTab & vbTab & cell.OFFSET(0, 4)
            ctr.left = 6
            ctr.top = 36 - ctr.Height + (counter * ctr.Height)
            ctr.Height = ctr.Height
            ctr.Width = 1000
            ctr.WordWrap = False
            ctr.AutoSize = True
        ElseIf cell.TEXT = "B" Then
            counter = counter + 1
            Set ctr = uUpdateFiles.Controls.Add("Forms.CheckBox.1")
            ReplaceWhat = Sheet1.Range("G1") & cell.OFFSET(0, 2)
            ReplaceWith = Sheet1.Range("A1") & cell.OFFSET(0, -4)
            ctr.Font.Name = "Consolas"
            ctr.Caption = ReplaceWhat & Space(spaceCounter - Len(ReplaceWhat)) & vbTab & cell.OFFSET(0, 4) & vbTab & _
                                                                                                           ReplaceWith & Space(spaceCounter - Len(ReplaceWhat)) & vbTab & cell.OFFSET(0, -2)
            ctr.left = 6
            ctr.top = 36 - ctr.Height + (counter * ctr.Height)
            ctr.Height = ctr.Height
            ctr.Width = 1000
            ctr.WordWrap = False
            ctr.AutoSize = True
        End If
        Set cell = cell.OFFSET(1, 0)
    Loop
    Application.CalculateFull
End Sub

Sub UpdateFiles()
    '#INCLUDE WorkbookIsOpen
    Dim c As MSForms.control
    Dim cell As Range
    Dim r As Range
    Dim workbookName As String, WorkbookFullName As String
    Dim LocalWorkbook As String, GithubWorkbook As String
    For Each c In uUpdateFiles.Controls
        If UCase(TypeName(c)) = UCase("CheckBox") Then
            If c.Value = True Then
                FindMe = Mid(Split(c.Caption, " ")(0), InStrRev(Split(c.Caption, " ")(0), "\") + 1)
                For Each r In ThisWorkbook.SHEETS("uAddins_Settings").Range("A1").CurrentRegion.RESIZE(, 1)
                    If r.TEXT = FindMe Then
                        Set cell = r
                        Exit For
                    End If
                Next
                LocalWorkbook = cell.OFFSET(0, 1)
                GithubWorkbook = cell.OFFSET(0, 7)
                workbookName = cell.TEXT
                Dim WasOpen As Boolean
                Dim fso As Object
                Set fso = CreateObject("Scripting.FileSystemObject")
                If cell.OFFSET(0, 4) = "A" Then
                    WasOpen = WorkbookIsOpen(workbookName)
                    If WasOpen = True Then
                        Workbooks(workbookName).IsAddin = True
                        Workbooks(workbookName).Close
                    End If
                    fso.CopyFile GithubWorkbook, LocalWorkbook, True
                    If WasOpen = True Then Workbooks.Open LocalWorkbook
                ElseIf cell.OFFSET(0, 4) = "B" Then
                    fso.CopyFile LocalWorkbook, GithubWorkbook, True
                End If
                If err.Number = 0 Then uUpdateFiles.Controls.Remove c.Name
            End If
        End If
    Next
End Sub



'Sheet18	100



'Sheet19	100



'Sheet20	100



'Sheet21	100



'Sheet23	100



'B_TODO	1

Private Sub sysAddTODO()
    Rem Author VBATools
    '#INCLUDE ActiveModule
    Dim Module As VBComponent:      Set Module = ActiveModule
    Dim CurentCodePane As CodePane: Set CurentCodePane = Module.CodeModule.CodePane
    Dim nLine  As Long, lStartLine As Long, lStartColumn As Long, lEndLine As Long, lEndColumn As Long
    Dim sFersLine As String, sSpec As String, txtName As String
    txtName = AUTHOR_NAME
    If txtName = vbNullString Then txtName = Environ("UserName")
    On Error GoTo HELL
    With CurentCodePane
        .GetSelection lStartLine, lStartColumn, lEndLine, lEndColumn
        sSpec = VBA.String$(lStartColumn - 1, " ")
        sFersLine = sSpec & "'* @TODO Created: " & VBA.Format$(Now, ctFormat) & " Author: " & txtName & vbCrLf & sSpec & "'*"
        .CodeModule.InsertLines lStartLine, sFersLine
    End With
HELL:
End Sub

Sub ShowTodo()
    Rem Open Navigation Userform
    '#INCLUDE FindCode
    FindCode "@TODO"
End Sub

Rem @Folder TODO
Sub DebugPrintListOfTodoInModule()
    '#INCLUDE dp
    '#INCLUDE ListOfTodoInModule
    dp ListOfTodoInModule
End Sub

Function ListOfTodoInModule(Optional Module As VBComponent)
    '#INCLUDE ActiveModule
    '#INCLUDE GetModuleText
    '#INCLUDE ArrayMultiFilter
    If Module Is Nothing Then Set Module = ActiveModule
    Dim out As String
    Dim Matches As String
    Matches = Join(ArrayMultiFilter(Split(GetModuleText(Module), vbNewLine), _
                                    Array("@TODO"), True), _
                                    vbNewLine)
    out = out & vbNewLine & "'---------"
    out = out & vbNewLine & "'Module: " & Module.Name
    out = out & vbNewLine & "'---------"
    out = out & vbNewLine & "'" & Replace(Matches, vbNewLine, vbNewLine & "'")
    ListOfTodoInModule = out
End Function

Function ListOfToDo(Optional TargetWorkbook As Workbook, Optional includeModuleName As Boolean)
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE GetModuleText
    '#INCLUDE ArrayMultiFilter
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim out As String
    Dim Matches As String
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        Matches = Join(ArrayMultiFilter(Split(GetModuleText(Module), vbNewLine), _
                                        Array("@TODO"), True), _
                                        vbNewLine)
        If Len(Trim(Matches)) <> 0 Then
            If includeModuleName = True Then
                out = out & vbNewLine & "'---------"
                out = out & vbNewLine & "'Module: " & Module.Name
                out = out & vbNewLine & "'---------"
            End If
            out = out & vbNewLine & "'" & Replace(Matches, vbNewLine, vbNewLine & "'")
        End If
    Next
    ListOfToDo = out
End Function

Sub ImportTODOHere()
    Rem Do not move this procedure!!!
    Rem All lines after this procedure will be deleted and replaced.
    '#INCLUDE vbModule
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ListOfToDo
    Dim v
    v = ListOfToDo(, True)
    Dim Module As VBComponent
    Set Module = vbModule("B_TODO", ThisWorkbook)
    Dim ProcEndLine As Long
    ProcEndLine = ProcedureEndLine(Module, "ImportTodoHere")
    With Module.CodeModule
        .DeleteLines ProcEndLine + 1, .CountOfLines - ProcEndLine
        .InsertLines .CountOfLines + 1, vbNewLine & v
    End With
End Sub



'B_FOLDERS	1

Rem @Folder Folders
Sub DebugPrintListOfFoldersInModule()
    '#INCLUDE dp
    '#INCLUDE ListOfVbeFoldersInModule
    dp ListOfVbeFoldersInModule
End Sub

Function ListOfVbeFoldersInModule(Optional Module As VBComponent)
    '#INCLUDE ActiveModule
    '#INCLUDE GetModuleText
    '#INCLUDE ArrayMultiFilter
    If Module Is Nothing Then Set Module = ActiveModule
    Dim out As String
    Dim Matches As String
    Matches = Join(ArrayMultiFilter(Split(GetModuleText(Module), vbNewLine), _
                                    Array("@Folder", "@Subfolder"), True), _
                                    vbNewLine)
    If Len(Trim(Matches)) <> 0 Then
        If includeModuleName = True Then
            out = out & vbNewLine & "'---------"
            out = out & vbNewLine & "'Module: " & Module.Name
            out = out & vbNewLine & "'---------"
        End If
        out = out & vbNewLine & "'" & Replace(Matches, vbNewLine, vbNewLine & "'")
    End If
    ListOfVbeFoldersInModule = out
End Function

Function ListOfVbeFolders(Optional TargetWorkbook As Workbook, Optional includeModuleName As Boolean)
    '#INCLUDE ActiveCodepaneWorkbook
    '#INCLUDE GetModuleText
    '#INCLUDE ArrayMultiFilter
    If TargetWorkbook Is Nothing Then Set TargetWorkbook = ActiveCodepaneWorkbook
    Dim out As String
    Dim Matches As String
    Dim Module As VBComponent
    For Each Module In TargetWorkbook.VBProject.VBComponents
        Matches = Join(ArrayMultiFilter(Split(GetModuleText(Module), vbNewLine), _
                                        Array("@Folder", "@Subfolder"), True), _
                                        vbNewLine)
        If Len(Trim(Matches)) <> 0 Then
            If includeModuleName = True Then
                out = out & vbNewLine & "'---------"
                out = out & vbNewLine & "'Module: " & Module.Name
                out = out & vbNewLine & "'---------"
            End If
            out = out & vbNewLine & "'" & Replace(Matches, vbNewLine, vbNewLine & "'")
        End If
    Next
    ListOfVbeFolders = out
End Function

Sub ImportFoldersHere()
    Rem Do not move this procedure!!!
    Rem All lines after this procedure will be deleted and replaced.
    '#INCLUDE vbModule
    '#INCLUDE ProcedureEndLine
    '#INCLUDE ListOfVbeFolders
    Dim v
    v = ListOfVbeFolders(, True)
    Dim Module As VBComponent
    Set Module = vbModule("B_FOLDERS")
    Dim ProcEndLine As Long
    ProcEndLine = ProcedureEndLine(Module, "ImportFoldersHere")
    With Module.CodeModule
        .DeleteLines ProcEndLine + 1, .CountOfLines - ProcEndLine
        .InsertLines .CountOfLines + 1, vbNewLine & v
    End With
End Sub



'Sheet24	100



'uImageMso	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uImageMso
'* Created    : 06-10-2022 10:38
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Dim Labels() As New clsMsoImage
Dim off As Long
Dim rCount As Long
Dim cCount As Long
Dim Size As Long
Dim matrix As Long
Dim totalImages As Long

Sub SetLabelEvents()
    Dim counter As Integer, obj As MSForms.control
    For Each obj In Me.Controls
        If TypeOf obj Is MSForms.label Then
            counter = counter + 1
            ReDim Preserve Labels(1 To counter)
            Set Labels(counter).LabelEvents = obj
        End If
    Next
    Set obj = Nothing
End Sub

Private Sub CommandButton1_Click()
    ActiveCell.Value = TextBox1.Value
    Me.Hide
End Sub

Private Sub UserForm_Initialize()
    SetUImageMsoVariables
    LoadMSO off
    Me.Caption = off + 1 & " to " & off + matrix & " of " & totalImages
    SetLabelEvents
End Sub

Sub SetUImageMsoVariables()
    Me.Width = 1020
    Me.Height = 550
    
    PreviousBatch.top = Me.Height - PreviousBatch.Height - 35
    '    PreviousBatch.left = Me.Width / 2 - PreviousBatch.Width - 50
    NextBatch.top = Me.Height - NextBatch.Height - 35
    '    NextBatch.left = Me.Width / 2 + NextBatch.Width - 50
    
    CommandButton1.top = Me.Height - CommandButton1.Height - 35
    '    CommandButton1.left = Me.Width / 2 + CommandButton1.Width + 50
    
    TextBox1.top = Me.Height - TextBox1.Height - 35
    '    TextBox1.left = Me.Width / 2 - TextBox1.Width - 150
    rCount = 15
    cCount = 30
    matrix = rCount * cCount
    totalImages = WorksheetFunction.CountA(ThisWorkbook.SHEETS("iXML").Range("ListMsoImage"))
    Size = 32
    off = 0
End Sub

Private Sub NextBatch_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    off = off + matrix
    If off > totalImages - matrix Then off = totalImages - matrix
    Restart
    LoadMSO off
    Me.Caption = off + 1 & " to " & off + matrix & " of " & totalImages
    SetLabelEvents
End Sub

Private Sub PreviousBatch_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    off = off - matrix
    If off < 0 Then off = 0
    Restart
    LoadMSO off
    Me.Caption = off + 1 & " to " & off + matrix & " of " & totalImages
    SetLabelEvents
End Sub

Sub Restart()
    Dim c As MSForms.control
    For Each c In Me.Controls
        If TypeName(c) = "Label" Then Me.Controls.Remove c.Name
    Next
End Sub

Sub LoadMSO(Optional OFFSET As Long = 0)
    Dim cell As Range
    Set cell = ThisWorkbook.SHEETS("iXML").Range("ListMsoImage").Cells(1, 1)
    Set cell = cell.OFFSET(OFFSET)
    Dim rows As Long, cols As Long
    Dim counter As Long
    Dim newImage As MSForms.label
    On Error GoTo Skip
    For rows = 1 To rCount
        For cols = 1 To cCount
            Set newImage = Me.Controls.Add("Forms.Label.1", "Image" & counter, True)
            newImage.top = Size * rows - Size + 5
            newImage.left = Size * cols - Size + 5
            newImage.Height = 36
            newImage.Width = 36
            newImage.Caption = cell
            newImage.Font.Size = 0
            newImage.Picture = Application.CommandBars.GetImageMso(cell, Size, Size)
Skip:
            Set cell = cell.OFFSET(1)
            If cell = "" Then Exit Sub
        Next
    Next
    Debug.Print Me.Controls.count
End Sub


'M_Update	1


Option Explicit
#If VBA7 Then
    Private Declare PtrSafe Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwFlags As Long, ByVal dwReserved As Long) As Long
#Else
    Private Declare Function InternetGetConnectedState Lib "wininet.dll" (ByRef dwflags As Long, ByVal dwReserved As Long) As Long
#End If

Function DayAfterCheck() As Long
    Dim TbRange     As Range
    Set TbRange = ThisWorkbook.SHEETS("vbArc_Addin_Settings").ListObjects("Update").DataBodyRange
    DayAfterCheck = TbRange.Cells(1, 5)
End Function

Public Function GetInternetConnectedState() As Boolean
    GetInternetConnectedState = InternetGetConnectedState(0&, 0&)
End Function

Rem * Created    : 15-09-2019 15:48
Rem * Author     : VBATools
Rem * Contacts   : http://vbatools.ru/ https://vk.com/vbatools
Rem * Copyright  : VBATools.ru
Public Sub StartUpdate()
    '#INCLUDE InvalidateControl
    '#INCLUDE SetControlValue
    '#INCLUDE GetInternetConnectedState
    '#INCLUDE ShowUpdateMsg
    '#INCLUDE isUpdateAvailable
    If Not GetInternetConnectedState Then Exit Sub
    Dim TbRange     As Range
    Set TbRange = ThisWorkbook.SHEETS("vbArc_Addin_Settings").ListObjects("Update").DataBodyRange
    Dim ShowUpdateAvailable As Range
    Set ShowUpdateAvailable = TbRange.Cells(1, 4)
    ShowUpdateAvailable.Value = isUpdateAvailable
    SetControlValue "MainButtonUpdate", "visible", ShowUpdateAvailable.Value
    InvalidateControl "MainButtonUpdate"
    If ShowUpdateAvailable.Value = True Then ShowUpdateMsg
End Sub

Private Sub ShowUpdateMsg()
    '#INCLUDE DayAfterCheck
    '#INCLUDE SkipThisVersion
    On Error GoTo ErrorHandler
    Dim TbRange     As Range
    Set TbRange = ThisWorkbook.SHEETS("vbArc_Addin_Settings").ListObjects("Update").DataBodyRange
    Dim TextUpdate  As String
    TextUpdate = TbRange.Cells(1, 3).Value2
    If TextUpdate <> vbNullString And TbRange.Cells(1, 2).Value2 + DayAfterCheck < Now() Then
        Rem @TODO Move this IF block to a userform which will also show by Update button in vbArc Tab
        If MsgBox("Greetings!" & vbNewLine & _
                  "Update " & TextUpdate & "is available for " & PROJECT_NAME & vbNewLine & vbNewLine & _
                  "To update, go to the website " & AUTHOR_GITHUB & vbNewLine & _
                  "or use the now visible UPDATE icon in your vbArc Tab" & vbNewLine & _
                  "This message will not show again until the next update check." & vbNewLine & _
                  "Skip this version?" & vbNewLine, vbYesNo, "Updating " & PROJECT_NAME) = vbYes Then
            SkipThisVersion
        End If
        TbRange.Cells(1, 2).Value2 = Now()
        ThisWorkbook.Save
    End If
    If TextUpdate <> TbRange.Cells(1, 1).Value2 And TextUpdate <> vbNullString Then TbRange.Cells(1, 4).Value = True
    Exit Sub
ErrorHandler:
    Select Case err.Number
        Case 1004:
        Case Else:
            Debug.Print "Mistake! in ShowUpdateMsg" & vbLf & err.Number & vbLf & err.Description & vbCrLf & "in the line" & Erl
    End Select
    err.clear
End Sub

Private Function isUpdateAvailable() As Boolean
    '#INCLUDE TXTReadFromUrl
    '#INCLUDE DayAfterCheck
    '#INCLUDE ChekDateUpdate
    On Error GoTo ErrorHandler
    Application.DisplayAlerts = False
    Dim TbRange     As Range
    Set TbRange = ThisWorkbook.SHEETS("vbArc_Addin_Settings").ListObjects("Update").DataBodyRange
    Dim NewVersion As String, CurentVersion As String
    If ChekDateUpdate Then
        NewVersion = TXTReadFromUrl(PROJECT_CHANGELOG_URL)
        NewVersion = Split(NewVersion, vbLf)(0)
        NewVersion = Split(NewVersion, " ")(UBound(Split(NewVersion, " ")))
        NewVersion = Trim(Replace(NewVersion, vbLf, ""))
    End If
    If NewVersion <> vbNullString Then
        CurentVersion = TbRange.Cells(1, 1).Value
        TbRange.Cells(1, 3).Value2 = NewVersion
        If CurentVersion < NewVersion Then
            isUpdateAvailable = True
            ThisWorkbook.Save
        Else
            GoTo SaveLabel
        End If
    Else
        GoTo SaveLabel
    End If
    Application.DisplayAlerts = True
    Exit Function
SaveLabel:
    isUpdateAvailable = False
    TbRange.Cells(1, 2).Value2 = Now() + DayAfterCheck
    ThisWorkbook.Save
    Application.DisplayAlerts = True
    Exit Function
ErrorHandler:
    Select Case err.Number
        Case 1004, -2146697211:
        Case Else:
            Debug.Print "Mistake! in isUpdateAvailable" & vbLf & err.Number & vbLf & err.Description & vbCrLf & "in the line" & Erl
    End Select
    err.clear
    isUpdateAvailable = False
End Function

Private Function ChekDateUpdate() As Boolean
    '#INCLUDE DayAfterCheck
    ChekDateUpdate = False
    Dim TbRange     As Range
    Set TbRange = ThisWorkbook.SHEETS("vbArc_Addin_Settings").ListObjects("Update").DataBodyRange
    Dim LastCheckedDate As Date
    LastCheckedDate = CDate(TbRange.Cells(1, 2).Value2)
    If Now > LastCheckedDate + DayAfterCheck Then ChekDateUpdate = True
End Function

Sub SkipThisVersion()
    '#INCLUDE TXTReadFromUrl
    '#INCLUDE InvalidateControl
    '#INCLUDE SetControlValue
    Dim TbRange As Range
    Set TbRange = ThisWorkbook.SHEETS("vbArc_Addin_Settings").ListObjects("Update").DataBodyRange
    Dim latestVersion As String
    Dim changeLog As String
    changeLog = TXTReadFromUrl(PROJECT_CHANGELOG_URL)
    latestVersion = Split(changeLog, vbLf)(0)
    latestVersion = Split(latestVersion, " ")(UBound(Split(latestVersion, " ")))
    Rem to skip this version @TODO add new column?
    TbRange.Cells(1, 1).Value2 = latestVersion
    Rem Hide update button
    SetControlValue "MainButtonUpdate", "visible", "FALSE"
    InvalidateControl "MainButtonUpdate"
End Sub

Private Function ResponseTextHttp(ByVal URL As String) As String
    Dim oHttp       As Object
    On Error Resume Next
    Set oHttp = CreateObject("MSXML2.XMLHTTP")
    If err.Number <> 0 Then
        Set oHttp = CreateObject("MSXML.XMLHTTPRequest")
    End If
    On Error GoTo 0
    If oHttp Is Nothing Then
        ResponseTextHttp = vbNullString
        Exit Function
    End If
    With oHttp
        .Open "GET", URL, False
        .send
        If .Status = 200 Then
            ResponseTextHttp = .responseText
        Else
            ResponseTextHttp = vbNullString
        End If
    End With
    Set oHttp = Nothing
End Function



'F_LoadImage	1

Rem This module provides a LoadPictureGDI function, which can
Rem be used instead of VBAs LoadPicture, to load a wide variety
Rem of image types from disk - including png.
Rem
Rem The png format is used in Office 2007-2010 to provide images that
Rem include an alpha channel for each pixels transparency
Rem
Rem Author:    Stephen Bullen
Rem Date:      31 October, 2006
Rem Email:     stephen@oaltd.co.uk
Rem
Rem Updated :  30 December, 2010
Rem By :       Rob Bovey
Rem Reason :   Also working now in the 64 bit version of Office 2010
Option Explicit
Rem Declare a UDT to store a GUID for the IPicture OLE Interface
Private Type GUID
    Data1 As Long
    Data2 As Integer
    Data3 As Integer
    Data4(0 To 7) As Byte
End Type

#If VBA7 Then
    Rem Declare a UDT to store the bitmap information
Private Type PICTDESC
    Size As Long
    Type As Long
    hPic As LongPtr
    hPal As LongPtr
End Type

Rem Declare a UDT to store the GDI+ Startup information
Private Type GDIPlusStartupInput
    GdiPlusVersion As Long
    DebugEventCallback As LongPtr
    SuppressBackgroundThread As Long
    SuppressExternalCodecs As Long
End Type

Rem Windows API calls into the GDI+ library
Private Declare PtrSafe Function GdiplusStartup Lib "GDIPlus" (token As LongPtr, inputbuf As GDIPlusStartupInput, Optional ByVal outputbuf As LongPtr = 0) As Long
Private Declare PtrSafe Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal fileName As LongPtr, BITMAP As LongPtr) As Long
Private Declare PtrSafe Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal BITMAP As LongPtr, hbmReturn As LongPtr, ByVal background As LongPtr) As Long
Private Declare PtrSafe Function GdipDisposeImage Lib "GDIPlus" (ByVal image As LongPtr) As Long
Private Declare PtrSafe Sub GdiplusShutdown Lib "GDIPlus" (ByVal token As LongPtr)
Private Declare PtrSafe Function OleCreatePictureIndirect Lib "oleaut32" (PicDesc As PICTDESC, RefIID As GUID, ByVal fPictureOwnsHandle As Long, iPic As IPicture) As Long
#Else
Rem Declare a UDT to store the bitmap information
Private Type PICTDESC
    Size As Long
    Type As Long
    hPic As Long
    hPal As Long
End Type

Rem Declare a UDT to store the GDI+ Startup information
Private Type GDIPlusStartupInput
    GdiPlusVersion As Long
    DebugEventCallback As Long
    SuppressBackgroundThread As Long
    SuppressExternalCodecs As Long
End Type

Rem Windows API calls into the GDI+ library
Private Declare Function GdiplusStartup Lib "GDIPlus" (token As Long, inputbuf As GdiplusStartupInput, Optional ByVal outputbuf As Long = 0) As Long
Private Declare Function GdipCreateBitmapFromFile Lib "GDIPlus" (ByVal filename As Long, bitmap As Long) As Long
Private Declare Function GdipCreateHBITMAPFromBitmap Lib "GDIPlus" (ByVal bitmap As Long, hbmReturn As Long, ByVal background As Long) As Long
Private Declare Function GdipDisposeImage Lib "GDIPlus" (ByVal image As Long) As Long
Private Declare Sub GdiplusShutdown Lib "GDIPlus" (ByVal token As Long)
Private Declare Function OleCreatePictureIndirect Lib "oleaut32" (PicDesc As PICTDESC, RefIID As GUID, ByVal fPictureOwnsHandle As Long, IPic As IPicture) As Long
#End If

Rem  Procedure:    LoadPictureGDI
Rem  Purpose:      Loads an image using GDI+
Rem  Returns:      The image as an IPicture Object
Public Function LoadPictureGDI(ByVal sFilename As String) As IPicture
    '#INCLUDE CreateIPicture
    Dim uGdiInput As GDIPlusStartupInput
    Dim lResult As Long
    #If VBA7 Then
        Dim hGdiPlus As LongPtr
        Dim hGdiImage As LongPtr
        Dim hBitmap As LongPtr
    #Else
        Dim hGdiPlus As Long
        Dim hGdiImage As Long
        Dim hBitmap As Long
    #End If
    Rem Initialize GDI+
    uGdiInput.GdiPlusVersion = 1
    lResult = GdiplusStartup(hGdiPlus, uGdiInput)
    If lResult = 0 Then
        Rem Load the image
        lResult = GdipCreateBitmapFromFile(StrPtr(sFilename), hGdiImage)
        If lResult = 0 Then
            Rem Create a bitmap handle from the GDI image
            lResult = GdipCreateHBITMAPFromBitmap(hGdiImage, hBitmap, 0)
            Rem Create the IPicture object from the bitmap handle
            Set LoadPictureGDI = CreateIPicture(hBitmap)
            Rem Tidy up
            GdipDisposeImage hGdiImage
        End If
        Rem Shutdown GDI+
        GdiplusShutdown hGdiPlus
    End If
End Function

Rem  Procedure:    CreateIPicture
Rem  Purpose:      Converts a image handle into an IPicture object.
Rem  Returns:      The IPicture object
#If VBA7 Then
Private Function CreateIPicture(ByVal hPic As LongPtr) As IPicture
#Else
Private Function CreateIPicture(ByVal hPic As Long) As IPicture
#End If
Dim lResult As Long
Dim uPicinfo As PICTDESC
Dim IID_IDispatch As GUID
Dim iPic As IPicture
Rem OLE Picture types
Const PICTYPE_BITMAP = 1
Rem  Create the Interface GUID (for the IPicture interface)
With IID_IDispatch
    .Data1 = &H7BF80980
    .Data2 = &HBF32
    .Data3 = &H101A
    .Data4(0) = &H8B
    .Data4(1) = &HBB
    .Data4(2) = &H0
    .Data4(3) = &HAA
    .Data4(4) = &H0
    .Data4(5) = &H30
    .Data4(6) = &HC
    .Data4(7) = &HAB
End With
Rem  Fill uPicInfo with necessary parts.
With uPicinfo
    .Size = Len(uPicinfo)
    .Type = PICTYPE_BITMAP
    .hPic = hPic
    .hPal = 0
End With
Rem  Create the Picture object.
lResult = OleCreatePictureIndirect(uPicinfo, IID_IDispatch, True, iPic)
Rem  Return the new Picture object.
Set CreateIPicture = iPic
End Function


'A_Test	1

Sub Test1()
    MsgBox 111111
End Sub

Sub Test2()
    MsgBox 222222
End Sub


'clsDate	2

Public WithEvents dForm As MSForms.UserForm
Public WithEvents dFrame As MSForms.Frame
Public WithEvents mFrame As MSForms.Frame
Public WithEvents yFrame As MSForms.Frame
Public WithEvents lblDate As MSForms.label
Public WithEvents lblMonth As MSForms.label
Public WithEvents lblYear As MSForms.label
Public WithEvents lblTodayBack As MSForms.label
Public WithEvents lblSelectedDateBack As MSForms.label
Public WithEvents lblDateBack As MSForms.label
Public WithEvents lblMonthBack As MSForms.label
Public WithEvents lblYearBack As MSForms.label

Public colDate As New Collection
Public aDate As New clsDate
Public colMonth As New Collection
Public aMonth As New clsDate
Public colYear As New Collection
Public aYear As New clsDate

Public Sub createDates(cYear As Integer, cMonth As Integer)
    Dim lLeft As Integer, lTop As Integer
    Dim fDate As Integer
    Set dForm = uDatePicker
    Set dFrame = dForm.frameDate
    PassiveDay = "": SelectedDay = ""
    '  MsgBox cYear & "-" & cMonth
    '************************************
    '***********//frame date start//*****
    With dFrame
        .clear
    End With
    '***********//frame date start//*****
    '************************************
    
    
    If cMonth Mod 12 = 0 Then cMonth = 12 Else cMonth = cMonth Mod 12
    dt = DateSerial(cYear, cMonth, 1)
    firstDate = Weekday(dt, 2)
    ilk = DateSerial(Year(dt), Month(dt), 1 - (firstDate - 1))
   
    lLeft = 6: lTop = 6
    For i = ilk To ilk + 41
        gunsayi = Format(Day(i), "#0")
       
        Set lblDate = dFrame.Controls.Add("Forms.Label.1", "lblDate" & gunsayi)
        With lblDate
            Debug.Print lblDate.Name
            .left = lLeft
            .top = lTop
            .Width = 32
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9
            .ForeColor = &H48372C
            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
            .Caption = gunsayi
            .Tag = i
            
            If CInt(Year(CDate(i))) = CInt(Year(CDate(dt))) And CInt(Month(CDate(i))) = CInt(Month(CDate(dt))) Then
                .Enabled = True
            Else
                .Enabled = False
            End If
             
            If Weekday(i, 2) = 7 Or Weekday(i, 2) = 6 Then
                .ForeColor = &H2144FF
            End If
            
            If i = Date And .Enabled = True Then
                
                Set lblTodayBack = dFrame.Controls.Add("Forms.Label.1", "lblTodayBack")
                With lblTodayBack
                    .Height = 1.2
                    .Width = 22
                    .top = lblDate.top + 16
                    .left = lblDate.left + 5
                    .BackColor = &H2144FF
                    .ZOrder (1)
                End With
            End If
            
            Set aDate = New clsDate
            Set aDate.lblDate = lblDate
            Set aDate.dFrame = dFrame
            Set aDate.dForm = dForm
            colDate.Add aDate
            
            
        End With
        
        
        If lLeft <= 238 Then
            lLeft = lLeft + 44
            
        Else
            lLeft = 6
            lTop = lTop + 30
        End If
    
    Next i
    Set lblSelectedDateBack = dFrame.Controls.Add("Forms.Label.1", "lblSelectedDateBack")
    With lblSelectedDateBack
        .Height = 26
        .Width = 30
        .Picture = dForm.lblSelectedDateBack.Picture
                
        .visible = False
        .ZOrder (1)
    End With
        
    Set lblDateBack = dFrame.Controls.Add("Forms.Label.1", "lblDateBack")
    With lblDateBack
        .Height = 26
        .Width = 30
        .Picture = dForm.lblDateBack.Picture
        .visible = False
        .ZOrder (1)
            
    End With

End Sub

Public Sub createMonth(snMonth As Integer)
    Dim lTop As Integer, i As Integer
    Dim fDate As Integer
    
    Set dForm = uDatePicker
    Set mFrame = dForm.frameMonth
    
    With mFrame
        .clear
    End With
    
    
    lTop = 4
    For i = 1 To 12
        Set lblMonth = mFrame.Controls.Add("Forms.Label.1", "lblMonth" & i)
        With lblMonth
            .left = 0
            .top = lTop
            .Width = 90
            .Height = 14
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9
            
            If i = snMonth Then
                .ForeColor = vbWhite
                PassiveMonth = lblMonth.Name
            Else
                .ForeColor = vbGrayText
            End If
             
            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
            .Caption = getMonth(i)
            .Tag = i
        End With
        lTop = lTop + 18
        
        Set aMonth = New clsDate
        Set aMonth.lblMonth = lblMonth
        Set aMonth.mFrame = mFrame
        Set aMonth.dForm = dForm
        colMonth.Add aMonth
        
        
        
    Next i
    Set lblMonth = Nothing
    
    Set lblMonthBack = mFrame.Controls.Add("Forms.Label.1", "lblMonthBack")
    With lblMonthBack
        .left = 0
        .top = (snMonth - 1) * 18
        .Width = 90
        .BackColor = &H2144FF
        .TextAlign = fmTextAlignCenter
        .BorderStyle = fmBorderStyleNone
        .ZOrder (1)
    End With
        
           
End Sub

Public Sub createYear(snYear As Integer)
    Dim lTop As Integer, i As Integer
    
    Set dForm = uDatePicker
    Set yFrame = dForm.frameYear
    
    With yFrame
        .clear
    End With
    
    
    lTop = 4
    For i = 1 To 12
        Set lblYear = yFrame.Controls.Add("Forms.Label.1", "lblYear" & i)
        With lblYear
            .left = 0
            .top = lTop
            .Width = 90
            .Height = 14
            .Font.Name = "MontSerrat Medium"
            .Font.Size = 9
            .ForeColor = vbGrayText
            .Caption = Format(Date, "yyyy") + i - 4
            
            If .Caption = snYear Then
                .ForeColor = vbWhite
                PassiveYear = lblYear.Name
            Else
                .ForeColor = vbGrayText
            End If
             
            .TextAlign = fmTextAlignCenter
            .BackStyle = fmBackStyleTransparent
            
            .Tag = i
        End With
        lTop = lTop + 18
        
        Set aYear = New clsDate
        Set aYear.lblYear = lblYear
        Set aYear.yFrame = yFrame
        Set aYear.dForm = dForm
        colYear.Add aYear
        
    Next i
    
    
    Set lblYearBack = yFrame.Controls.Add("Forms.Label.1", "lblYearBack")
    With lblYearBack
        .left = 0
        .top = yFrame.Controls(PassiveYear).top - 4
        .Width = 90
        .BackColor = &H2144FF
        .TextAlign = fmTextAlignCenter
        .BorderStyle = fmBorderStyleNone
        .ZOrder (1)
    End With
         
           
End Sub

Private Sub dForm_Click()
    framevisibleFalse
End Sub

Private Sub dFrame_Click()
    framevisibleFalse
End Sub

Sub framevisibleFalse()
    uDatePicker.frameMonth.visible = False
    uDatePicker.frameYear.visible = False
End Sub

Private Sub lblDate_Click()

    If SelectedDay <> "" Then
        If Weekday(SelectedDayTag, 2) = 7 Or Weekday(SelectedDayTag, 2) = 6 Then
            dFrame.Controls(SelectedDay).ForeColor = &H2144FF
        Else
            dFrame.Controls(SelectedDay).ForeColor = &H48372C
        End If
        
    Else
    
    End If
    SelectDate lblDate
End Sub

Private Sub lblDate_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
    SelectDate lblDate
    Unload uDatePicker
    
End Sub

Sub SelectDate(ctrl As control)
    Dim curDate As Date
    With uDatePicker
        .lblSelectedDate = ctrl.Caption
        .lblSelectedMonth = .lblMonthName
        .lblSelectedYear = .txtYearName
        .lblSelectedDateName = Format(ctrl.Tag, "dddd")
        .txtSelectedDate = Format(ctrl.Tag, "dd.mm.yyyy")
       
      
        lblSelectedDateBackPosition ctrl
        ctrl.ForeColor = vbWhite
        SelectedDay = ctrl.Name
        SelectedDayTag = ctrl.Tag
    End With
End Sub

Private Sub lblDate_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    framevisibleFalse
    lblDateBackPosition lblDate
    dayMouseOut
    lblDate.ForeColor = vbWhite
    PassiveDay = lblDate.Name
    PassiveDayTag = lblDate.Tag
End Sub

Private Sub lblDateBackPosition(ctrl As control)
    MouseMoveIcon
    With dFrame.Controls("lblDateBack")
        .visible = True
        .top = ctrl.top - 5
        .left = ctrl.left + 1
    End With
End Sub

Private Sub lblMonth_Click()
    With uDatePicker
        .txtMonthNumber = lblMonth.Tag
        .frameMonth.visible = False
        .lblMonthName = getMonth(.txtMonthNumber)
        createDates .txtYearName, .txtMonthNumber
    End With
End Sub

Private Sub lblYear_Click()
    With uDatePicker
        .txtYearName = lblYear
        .frameYear.visible = False
        createDates .txtYearName, .txtMonthNumber
    End With
    
End Sub

Private Sub lblMonth_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '    MsgBox PassiveMonth
    lblMonthBackPosition lblMonth
    monthMouseOut
    lblMonth.ForeColor = vbWhite
    PassiveMonth = lblMonth.Name
   
End Sub

Private Sub lblYear_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    
    lblYearBackPosition lblYear
    yearMouseOut
    lblYear.ForeColor = vbWhite
    PassiveYear = lblYear.Name
   
End Sub

Private Sub lblSelectedDateBackPosition(ctrl As control)
    With dFrame.Controls("lblSelectedDateBack")
        .visible = True
        .top = ctrl.top - 5
        .left = ctrl.left + 1
    End With
End Sub

Private Sub lblYearBackPosition(ctrl As control)
    MouseMoveIcon
    dForm.Controls("lblYearBack").top = ctrl.top - 4
End Sub

Private Sub lblMonthBackPosition(ctrl As control)
    MouseMoveIcon
    dForm.Controls("lblMonthBack").top = ctrl.top - 4
End Sub

Public Sub dayMouseOut()
    On Error Resume Next
    If PassiveDay <> "" Then
        
        If Weekday(PassiveDayTag, 2) = 7 Or Weekday(PassiveDayTag, 2) = 6 Then
            dFrame.Controls(PassiveDay).ForeColor = &H2144FF
        Else
            dFrame.Controls(PassiveDay).ForeColor = &H48372C
        End If
        
    End If
    If SelectedDay <> "" Then
        dFrame.Controls(SelectedDay).ForeColor = vbWhite
    End If
        
     
End Sub

Private Sub monthMouseOut()

    If PassiveMonth <> "" Then
        mFrame.Controls(PassiveMonth).ForeColor = vbGrayText
    End If
End Sub

Private Sub yearMouseOut()

    If PassiveYear <> "" Then
        yFrame.Controls(PassiveYear).ForeColor = vbGrayText
    End If
End Sub


'U_DatePicker	1

Rem usage:
Rem uDatePicker.Datepicker TextBox1
Rem uDatePicker.Datepicker activecell
Public PassiveMonth, PassiveDay, PassiveYear, PassiveDayTag, SelectedDay, SelectedDayTag
#If VBA7 Then
    Public Declare PtrSafe Sub ReleaseCapture Lib "user32" ()
    Public Declare PtrSafe Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
    Rem ----------------------------------------------------------------------------------------------------
    Public Declare PtrSafe Sub Sleep Lib "kernel32" (ByVal dwNilliseconds As Long)
    Public Declare PtrSafe Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
    Public Declare PtrSafe Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
    Public Declare PtrSafe Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Public Declare PtrSafe Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare PtrSafe Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
    Public Declare PtrSafe Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare PtrSafe Function LoadCursorBynum Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
    Public Declare PtrSafe Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
    Public Declare PtrSafe Function MoveJanela Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Public Declare PtrSafe Function CreateRoundRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long
    Public Declare PtrSafe Function SetWindowRgn Lib "user32" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long
#Else
    Public Declare Sub ReleaseCapture Lib "user32" ()
    Public Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
    Rem ----------------------------------------------------------------------------------------------------
    Public Declare Sub Sleep Lib "kernel32" (ByVal dwNilliseconds As Long)
    Public Declare Function SetLayeredWindowAttributes Lib "user32" (ByVal hWnd As Long, ByVal crKey As Long, ByVal bAlpha As Byte, ByVal dwFlags As Long) As Long
    Public Declare Function GetWindowLong Lib "user32.dll" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
    Public Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare Function DrawMenuBar Lib "user32" (ByVal hWnd As Long) As Long
    Public Declare Function FindWindowA Lib "user32" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
    Public Declare Function LoadCursorBynum Lib "user32" Alias "LoadCursorA" (ByVal hInstance As Long, ByVal lpCursorName As Long) As Long
    Public Declare Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
    Public Declare Function MoveJanela Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    Public Declare Function CreateRoundRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long
    Public Declare Function SetWindowRgn Lib "user32" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long
#End If
Private Const GWL_EXSTYLE As Long = (-20)
Private Const WS_EX_DLGMODALFRAME As Long = &H1
Private Const GWL_STYLE As Long = (-16)
Private Const WS_CAPTION = 55000000
Private Const WS_EX_LAYERED = &H80000
Rem Private Const LWA_COLORKEY = &H1
Private Const LWA_ALPHA = &H2
Private Const IDC_HAND = 32649&
Public MeuForm As Long
Public ESTILO As Long
Public Const ESTILO_ATUAL As Long = (-16)
Public Const HTCAPTION = 2
Public Const WM_NCLBUTTONDOWN = &HA1
Private lngPixelsX As Long
Private lngPixelsY As Long
Private strThunder As String
Private blnCreate As Boolean
Private lnghWnd_Form As Long
Private lnghWnd_Sub As Long
Private Const cstMask As Long = &H7FFFFFFF

Function HideTitleBarAndBorder(frm As Object)
    Dim lngWindow As Long
    Dim lFrmHdl As Long
    lFrmHdl = FindWindow(vbNullString, frm.Caption)
    lngWindow = GetWindowLong(lFrmHdl, GWL_STYLE)
    lngWindow = lngWindow And (Not WS_CAPTION)
    SetWindowLong lFrmHdl, GWL_STYLE, lngWindow
    lngWindow = GetWindowLong(lFrmHdl, GWL_EXSTYLE)
    lngWindow = lngWindow And Not WS_EX_DLGMODALFRAME
    SetWindowLong lFrmHdl, GWL_EXSTYLE, lngWindow
    DrawMenuBar lFrmHdl
End Function

Function MakeUserformTransparent(frm As Object, colorKey As Variant, Optional color As Variant)
    LWA_COLORKEY = colorKey
    Dim formhandle As Long
    Dim bytOpacity As Byte
    formhandle = FindWindow(vbNullString, frm.Caption)
    If IsMissing(color) Then color = &H8000&
    bytOpacity = 130
    SetWindowLong formhandle, GWL_EXSTYLE, GetWindowLong(formhandle, GWL_EXSTYLE) Or WS_EX_LAYERED
    frm.BackColor = color
    SetLayeredWindowAttributes formhandle, color, bytOpacity, LWA_COLORKEY
End Function

Public Function MouseCursor(CursorType As Long)
    Dim lngRet As Long
    lngRet = LoadCursorBynum(0&, CursorType)
    lngRet = SetCursor(lngRet)
End Function

Public Function MouseMoveIcon()
    '#INCLUDE MouseCursor
    Call MouseCursor(IDC_HAND)
End Function

Public Sub moverForm(form As Object, obj As Object, Button As Integer)
    Dim lngMyHandle As Long, lngCurrentStyle As Long, lngNewStyle As Long
    If val(Application.Version) < 9 Then
        lngMyHandle = FindWindowA("ThunderXFrame", form.Caption)
    Else
        lngMyHandle = FindWindowA("ThunderDFrame", form.Caption)
    End If
    If Button = 1 Then
        With obj
            Call ReleaseCapture
            Call SendMessage(lngMyHandle, WM_NCLBUTTONDOWN, HTCAPTION, 0&)
        End With
    End If
End Sub

Public Sub removeTudo(ObjForm As Object)
    MeuForm = FindWindowA(vbNullString, ObjForm.Caption)
    ESTILO = ESTILO Or WS_CAPTION
    MoveJanela MeuForm, ESTILO_ATUAL, (ESTILO)
End Sub

Public Function getMonth(iMonth As Integer, Optional language As String)
    Select Case iMonth Mod 12
        Case Is = 1, "-11"
            getMonth = "January"
        Case Is = 2, "-10"
            getMonth = "February"
        Case Is = 3, "-9"
            getMonth = "March"
        Case Is = 4, "-8"
            getMonth = "April"
        Case Is = 5, "-7"
            getMonth = "May"
        Case Is = 6, "-6"
            getMonth = "June"
        Case Is = 7, "-5"
            getMonth = "July"
        Case Is = 8, "-4"
            getMonth = "August"
        Case Is = 9, "-3"
            getMonth = "September"
        Case Is = 10, "-2"
            getMonth = "October"
        Case Is = 11, "-1"
            getMonth = "November"
        Case Is = 0, 12
            getMonth = "December"
    End Select
End Function


'uDatePicker	3





Public gDate As New clsDate

Private Sub frameDate_Click()
    frameMonth.visible = False
    frameYear.visible = False
End Sub

Private Sub Label1_Click()

End Sub

Private Sub lblChoose_Click()
    Unload Me
End Sub

Private Sub lblChoose_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    gDate.dFrame.Controls("lblDateBack").visible = False
    gDate.dayMouseOut
    
End Sub

Private Sub lblClose_Click()
    txtSelectedDate = ""
    Unload Me
    
End Sub

Private Sub lblMonthName_Click()
    frameYear.visible = False
    With frameMonth
        .visible = True
        .left = lblMonthName.left
        .top = lblMonthName.top + 20
       
    End With
    gDate.createMonth txtMonthNumber
End Sub

Private Sub lblNextMonth_Click()
    With txtMonthNumber
        .TEXT = .TEXT + 1
        lblMonthName = getMonth(.TEXT)
        
        
        If lblMonthName = "OCAK" Then
            txtYearName = txtYearName + 1
        End If
        '        gDate.createDates txtYearName, .Text

    End With
End Sub

Private Sub lblPreviewMonth_Click()
    With txtMonthNumber
        .TEXT = .TEXT - 1
        
        lblMonthName = getMonth(.TEXT)
        If lblMonthName.Caption = "ARALIK" Then
            txtYearName = txtYearName - 1
        End If
        '       gDate.createDates txtYearName, .Text
    End With
End Sub

Private Sub lblRightBar_Click()
    
End Sub

Private Sub lblRightBar_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    moverForm Me, Me, Button
End Sub

Private Sub lblToday_Click()
    lblMonthName = getMonth(Format(Date, "mm"))
    txtYearName = Format(Date, "yyyy")
    txtMonthNumber = Format(Date, "m")
    gDate.createDates Format(Date, "yyyy"), Format(Date, "mm")
End Sub

Private Sub txtMonthNumber_Change()
    lblMonthName = getMonth(txtMonthNumber)
    gDate.createDates txtYearName, txtMonthNumber
End Sub

Private Sub txtSelectedYear_Change()

End Sub

Private Sub txtYearName_Change()
    If Len(txtYearName.TEXT) = 4 Then _
                               gDate.createDates txtYearName, txtMonthNumber
End Sub

Private Sub txtYearName_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    frameMonth.visible = False
    With frameYear
        .left = txtYearName.left
        .top = txtYearName.top + 20
        .visible = True
    End With
    gDate.createYear txtYearName
End Sub

Private Sub UserForm_Activate()
    lblToday_Click
End Sub

Private Sub UserForm_Click()
    Me.frameMonth.visible = False
    Me.frameYear.visible = False
End Sub

Private Sub UserForm_Initialize()
    Dim sMonth As Integer
    SelectedDay = ""
    removeTudo Me
    HideTitleBarAndBorder Me
    
    With Me
        .Height = 308
        .Width = 480
    End With
    
    IconDesign lblPreviewMonth, "&HE26C"
    IconDesign lblNextMonth, "&HE26B"

End Sub

Private Sub IconDesign(ctrl As control, IconCode As String)
    With ctrl
        .Font.Name = "Segoe MDL2 Assets"
        .Caption = ChrW(IconCode)
        .Font.Size = 12
        .ForeColor = RGB(191, 191, 191)
        .TextAlign = fmTextAlignLeft
        .BorderStyle = fmBorderStyleNone
        .BackStyle = fmBackStyleTransparent
    End With
End Sub

Function Datepicker(Optional DateInput As Object) As String
    Dim str As String
    If VBA.TypeName(DateInput) = "Textbox" Or VBA.TypeName(DateInput) = "Range" Then str = DateInput.Value
    If VBA.TypeName(DateInput) = "CommandButton" Or VBA.TypeName(DateInput) = "Label" Then str = DateInput.Caption
    
    'If DatepInput <> "" Then <--- replaced with next line
    If str <> "" Then
                
        Dim curDate As String
        With uDatePicker
            .txtYearName = Year(DateInput)
            .txtMonthNumber = Format(DateInput, "mm")

        End With

        With gDate
            .createDates txtYearName, txtMonthNumber
            .SelectDate .dFrame.Controls("lblDate" & Day(DateInput))
        End With
    Else

        With uDatePicker
            .lblSelectedDate = Day(Date)
            .lblSelectedMonth = Format(Date, "mmmm")
            .lblSelectedYear = Year(Date)
            curDate = Day(Date) & "." & .txtMonthNumber Mod 12 & "." & .txtYearName
            .lblSelectedDateName = Format(curDate, "dddd")
            .txtSelectedDate = Format(curDate, "dd.mm.yyyy")
            .txtMonthNumber = Format(Date, "mm")
        End With
                
        With gDate.lblDateBack
                
        End With
                
    End If
            
            
    Me.Show
        
    Datepicker = Me.txtSelectedDate.Value
         
    If VBA.TypeName(DateInput) = "TextBox" Or VBA.TypeName(DateInput) = "Range" Then
        DateInput.Value = Me.txtSelectedDate.Value
    ElseIf VBA.TypeName(DateInput) = "CommandButton" Or VBA.TypeName(DateInput) = "Label" Then
        DateInput.Caption = Me.txtSelectedDate.Value
    Else
        'Datepicker = Me.txtSelectedDate.Value <--- put this before If to return the value anyway
    End If

End Function

Private Sub UserForm_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)
    '    moverForm Me, Me, Button
End Sub



'uVbarcUpdate	3


'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'* Module     : uVbarcUpdate
'* Created    : 06-10-2022 10:41
'* Author     : Anastasiou Alex
'* Contacts   : AnastasiouAlex@gmail.com
'*
'* GITHUB     : https://github.com/AlexOfRhodes
'* YOUTUBE    : https://www.youtube.com/channel/UC5QH3fn1zjx0aUjRER_rOjg
'* VK         : https://vk.com/video/playlist/735281600_1
'* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Dim changeLog As String

Private Sub Label1_Click()
    SkipThisVersion
End Sub

Private Sub Label2_Click()
    FollowLink ("https://github.com/alexofrhodes")
End Sub

Private Sub Label3_Click()
    Dim TargetFolder As String
    TargetFolder = getFolder
    If TargetFolder = "" Then Exit Sub
    Dim SaveFileFullPath As String
    SaveFileFullPath = TargetFolder & "\" & getFilePartName(PROJECT_DOWNLAOD_URL, True)
    DownloadFile PROJECT_DOWNLAOD_URL, SaveFileFullPath
    Do While Not FileExists(SaveFileFullPath)
        DoEvents
    Loop
    FollowLink TargetFolder
    If openAfterDownload Then Workbooks.Open (SaveFileFullPath)
End Sub

Private Sub UserForm_Initialize()
    If GetInternetConnectedState = False Then
        MsgBox "Seems Internet is not available"
        Unload Me
    End If
    
    changeLog = TXTReadFromUrl(PROJECT_CHANGELOG_URL)
    TextBox1.TEXT = changeLog
    
    
End Sub

Sub DownloadLatestVersion()
    
End Sub


'Sheet25	100


